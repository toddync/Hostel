<html class="dark"><head>
		<meta charset="UTF-8">
		<title>Hostel</title>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css">
		<link rel="stylesheet" href="/style.css">
		<link rel="stylesheet" href="/styleDash.css">
		<link rel="stylesheet" href="/app.css">

		<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
		<script src="/d3.js"></script>
	</head>
	<body>

<main id="app"></main><script>document.getElementById('app').innerHTML=''</script><!---->


<style></style>
<script>(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.js
  var require_core = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.js"(exports, module) {
      "use strict";
      module.exports = function() {
        var Chart2 = function(item, config) {
          this.construct(item, config);
          return this;
        };
        Chart2.defaults = {
          global: {
            responsive: true,
            responsiveAnimationDuration: 0,
            maintainAspectRatio: true,
            events: ["mousemove", "mouseout", "click", "touchstart", "touchmove"],
            hover: {
              onHover: null,
              mode: "nearest",
              intersect: true,
              animationDuration: 400
            },
            onClick: null,
            defaultColor: "rgba(0,0,0,0.1)",
            defaultFontColor: "#666",
            defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
            defaultFontSize: 12,
            defaultFontStyle: "normal",
            showLines: true,
            // Element defaults defined in element extensions
            elements: {},
            // Legend callback string
            legendCallback: function(chart) {
              var text2 = [];
              text2.push('<ul class="' + chart.id + '-legend">');
              for (var i2 = 0; i2 < chart.data.datasets.length; i2++) {
                text2.push('<li><span style="background-color:' + chart.data.datasets[i2].backgroundColor + '"></span>');
                if (chart.data.datasets[i2].label) {
                  text2.push(chart.data.datasets[i2].label);
                }
                text2.push("</li>");
              }
              text2.push("</ul>");
              return text2.join("");
            }
          }
        };
        Chart2.Chart = Chart2;
        return Chart2;
      };
    }
  });

  // node_modules/.pnpm/color-name@1.1.3/node_modules/color-name/index.js
  var require_color_name = __commonJS({
    "node_modules/.pnpm/color-name@1.1.3/node_modules/color-name/index.js"(exports, module) {
      "use strict";
      module.exports = {
        "aliceblue": [240, 248, 255],
        "antiquewhite": [250, 235, 215],
        "aqua": [0, 255, 255],
        "aquamarine": [127, 255, 212],
        "azure": [240, 255, 255],
        "beige": [245, 245, 220],
        "bisque": [255, 228, 196],
        "black": [0, 0, 0],
        "blanchedalmond": [255, 235, 205],
        "blue": [0, 0, 255],
        "blueviolet": [138, 43, 226],
        "brown": [165, 42, 42],
        "burlywood": [222, 184, 135],
        "cadetblue": [95, 158, 160],
        "chartreuse": [127, 255, 0],
        "chocolate": [210, 105, 30],
        "coral": [255, 127, 80],
        "cornflowerblue": [100, 149, 237],
        "cornsilk": [255, 248, 220],
        "crimson": [220, 20, 60],
        "cyan": [0, 255, 255],
        "darkblue": [0, 0, 139],
        "darkcyan": [0, 139, 139],
        "darkgoldenrod": [184, 134, 11],
        "darkgray": [169, 169, 169],
        "darkgreen": [0, 100, 0],
        "darkgrey": [169, 169, 169],
        "darkkhaki": [189, 183, 107],
        "darkmagenta": [139, 0, 139],
        "darkolivegreen": [85, 107, 47],
        "darkorange": [255, 140, 0],
        "darkorchid": [153, 50, 204],
        "darkred": [139, 0, 0],
        "darksalmon": [233, 150, 122],
        "darkseagreen": [143, 188, 143],
        "darkslateblue": [72, 61, 139],
        "darkslategray": [47, 79, 79],
        "darkslategrey": [47, 79, 79],
        "darkturquoise": [0, 206, 209],
        "darkviolet": [148, 0, 211],
        "deeppink": [255, 20, 147],
        "deepskyblue": [0, 191, 255],
        "dimgray": [105, 105, 105],
        "dimgrey": [105, 105, 105],
        "dodgerblue": [30, 144, 255],
        "firebrick": [178, 34, 34],
        "floralwhite": [255, 250, 240],
        "forestgreen": [34, 139, 34],
        "fuchsia": [255, 0, 255],
        "gainsboro": [220, 220, 220],
        "ghostwhite": [248, 248, 255],
        "gold": [255, 215, 0],
        "goldenrod": [218, 165, 32],
        "gray": [128, 128, 128],
        "green": [0, 128, 0],
        "greenyellow": [173, 255, 47],
        "grey": [128, 128, 128],
        "honeydew": [240, 255, 240],
        "hotpink": [255, 105, 180],
        "indianred": [205, 92, 92],
        "indigo": [75, 0, 130],
        "ivory": [255, 255, 240],
        "khaki": [240, 230, 140],
        "lavender": [230, 230, 250],
        "lavenderblush": [255, 240, 245],
        "lawngreen": [124, 252, 0],
        "lemonchiffon": [255, 250, 205],
        "lightblue": [173, 216, 230],
        "lightcoral": [240, 128, 128],
        "lightcyan": [224, 255, 255],
        "lightgoldenrodyellow": [250, 250, 210],
        "lightgray": [211, 211, 211],
        "lightgreen": [144, 238, 144],
        "lightgrey": [211, 211, 211],
        "lightpink": [255, 182, 193],
        "lightsalmon": [255, 160, 122],
        "lightseagreen": [32, 178, 170],
        "lightskyblue": [135, 206, 250],
        "lightslategray": [119, 136, 153],
        "lightslategrey": [119, 136, 153],
        "lightsteelblue": [176, 196, 222],
        "lightyellow": [255, 255, 224],
        "lime": [0, 255, 0],
        "limegreen": [50, 205, 50],
        "linen": [250, 240, 230],
        "magenta": [255, 0, 255],
        "maroon": [128, 0, 0],
        "mediumaquamarine": [102, 205, 170],
        "mediumblue": [0, 0, 205],
        "mediumorchid": [186, 85, 211],
        "mediumpurple": [147, 112, 219],
        "mediumseagreen": [60, 179, 113],
        "mediumslateblue": [123, 104, 238],
        "mediumspringgreen": [0, 250, 154],
        "mediumturquoise": [72, 209, 204],
        "mediumvioletred": [199, 21, 133],
        "midnightblue": [25, 25, 112],
        "mintcream": [245, 255, 250],
        "mistyrose": [255, 228, 225],
        "moccasin": [255, 228, 181],
        "navajowhite": [255, 222, 173],
        "navy": [0, 0, 128],
        "oldlace": [253, 245, 230],
        "olive": [128, 128, 0],
        "olivedrab": [107, 142, 35],
        "orange": [255, 165, 0],
        "orangered": [255, 69, 0],
        "orchid": [218, 112, 214],
        "palegoldenrod": [238, 232, 170],
        "palegreen": [152, 251, 152],
        "paleturquoise": [175, 238, 238],
        "palevioletred": [219, 112, 147],
        "papayawhip": [255, 239, 213],
        "peachpuff": [255, 218, 185],
        "peru": [205, 133, 63],
        "pink": [255, 192, 203],
        "plum": [221, 160, 221],
        "powderblue": [176, 224, 230],
        "purple": [128, 0, 128],
        "rebeccapurple": [102, 51, 153],
        "red": [255, 0, 0],
        "rosybrown": [188, 143, 143],
        "royalblue": [65, 105, 225],
        "saddlebrown": [139, 69, 19],
        "salmon": [250, 128, 114],
        "sandybrown": [244, 164, 96],
        "seagreen": [46, 139, 87],
        "seashell": [255, 245, 238],
        "sienna": [160, 82, 45],
        "silver": [192, 192, 192],
        "skyblue": [135, 206, 235],
        "slateblue": [106, 90, 205],
        "slategray": [112, 128, 144],
        "slategrey": [112, 128, 144],
        "snow": [255, 250, 250],
        "springgreen": [0, 255, 127],
        "steelblue": [70, 130, 180],
        "tan": [210, 180, 140],
        "teal": [0, 128, 128],
        "thistle": [216, 191, 216],
        "tomato": [255, 99, 71],
        "turquoise": [64, 224, 208],
        "violet": [238, 130, 238],
        "wheat": [245, 222, 179],
        "white": [255, 255, 255],
        "whitesmoke": [245, 245, 245],
        "yellow": [255, 255, 0],
        "yellowgreen": [154, 205, 50]
      };
    }
  });

  // node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/conversions.js
  var require_conversions = __commonJS({
    "node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/conversions.js"(exports, module) {
      var cssKeywords = require_color_name();
      var reverseKeywords = {};
      for (key in cssKeywords) {
        if (cssKeywords.hasOwnProperty(key)) {
          reverseKeywords[cssKeywords[key]] = key;
        }
      }
      var key;
      var convert = module.exports = {
        rgb: { channels: 3, labels: "rgb" },
        hsl: { channels: 3, labels: "hsl" },
        hsv: { channels: 3, labels: "hsv" },
        hwb: { channels: 3, labels: "hwb" },
        cmyk: { channels: 4, labels: "cmyk" },
        xyz: { channels: 3, labels: "xyz" },
        lab: { channels: 3, labels: "lab" },
        lch: { channels: 3, labels: "lch" },
        hex: { channels: 1, labels: ["hex"] },
        keyword: { channels: 1, labels: ["keyword"] },
        ansi16: { channels: 1, labels: ["ansi16"] },
        ansi256: { channels: 1, labels: ["ansi256"] },
        hcg: { channels: 3, labels: ["h", "c", "g"] },
        apple: { channels: 3, labels: ["r16", "g16", "b16"] },
        gray: { channels: 1, labels: ["gray"] }
      };
      for (model in convert) {
        if (convert.hasOwnProperty(model)) {
          if (!("channels" in convert[model])) {
            throw new Error("missing channels property: " + model);
          }
          if (!("labels" in convert[model])) {
            throw new Error("missing channel labels property: " + model);
          }
          if (convert[model].labels.length !== convert[model].channels) {
            throw new Error("channel and label counts mismatch: " + model);
          }
          channels = convert[model].channels;
          labels = convert[model].labels;
          delete convert[model].channels;
          delete convert[model].labels;
          Object.defineProperty(convert[model], "channels", { value: channels });
          Object.defineProperty(convert[model], "labels", { value: labels });
        }
      }
      var channels;
      var labels;
      var model;
      convert.rgb.hsl = function(rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var min = Math.min(r, g, b);
        var max = Math.max(r, g, b);
        var delta = max - min;
        var h;
        var s2;
        var l;
        if (max === min) {
          h = 0;
        } else if (r === max) {
          h = (g - b) / delta;
        } else if (g === max) {
          h = 2 + (b - r) / delta;
        } else if (b === max) {
          h = 4 + (r - g) / delta;
        }
        h = Math.min(h * 60, 360);
        if (h < 0) {
          h += 360;
        }
        l = (min + max) / 2;
        if (max === min) {
          s2 = 0;
        } else if (l <= 0.5) {
          s2 = delta / (max + min);
        } else {
          s2 = delta / (2 - max - min);
        }
        return [h, s2 * 100, l * 100];
      };
      convert.rgb.hsv = function(rgb) {
        var rdif;
        var gdif;
        var bdif;
        var h;
        var s2;
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var v = Math.max(r, g, b);
        var diff = v - Math.min(r, g, b);
        var diffc = function(c) {
          return (v - c) / 6 / diff + 1 / 2;
        };
        if (diff === 0) {
          h = s2 = 0;
        } else {
          s2 = diff / v;
          rdif = diffc(r);
          gdif = diffc(g);
          bdif = diffc(b);
          if (r === v) {
            h = bdif - gdif;
          } else if (g === v) {
            h = 1 / 3 + rdif - bdif;
          } else if (b === v) {
            h = 2 / 3 + gdif - rdif;
          }
          if (h < 0) {
            h += 1;
          } else if (h > 1) {
            h -= 1;
          }
        }
        return [
          h * 360,
          s2 * 100,
          v * 100
        ];
      };
      convert.rgb.hwb = function(rgb) {
        var r = rgb[0];
        var g = rgb[1];
        var b = rgb[2];
        var h = convert.rgb.hsl(rgb)[0];
        var w = 1 / 255 * Math.min(r, Math.min(g, b));
        b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
        return [h, w * 100, b * 100];
      };
      convert.rgb.cmyk = function(rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var c;
        var m;
        var y;
        var k;
        k = Math.min(1 - r, 1 - g, 1 - b);
        c = (1 - r - k) / (1 - k) || 0;
        m = (1 - g - k) / (1 - k) || 0;
        y = (1 - b - k) / (1 - k) || 0;
        return [c * 100, m * 100, y * 100, k * 100];
      };
      function comparativeDistance(x, y) {
        return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
      }
      convert.rgb.keyword = function(rgb) {
        var reversed = reverseKeywords[rgb];
        if (reversed) {
          return reversed;
        }
        var currentClosestDistance = Infinity;
        var currentClosestKeyword;
        for (var keyword in cssKeywords) {
          if (cssKeywords.hasOwnProperty(keyword)) {
            var value = cssKeywords[keyword];
            var distance = comparativeDistance(rgb, value);
            if (distance < currentClosestDistance) {
              currentClosestDistance = distance;
              currentClosestKeyword = keyword;
            }
          }
        }
        return currentClosestKeyword;
      };
      convert.keyword.rgb = function(keyword) {
        return cssKeywords[keyword];
      };
      convert.rgb.xyz = function(rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
        b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
        var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
        var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
        var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
        return [x * 100, y * 100, z * 100];
      };
      convert.rgb.lab = function(rgb) {
        var xyz = convert.rgb.xyz(rgb);
        var x = xyz[0];
        var y = xyz[1];
        var z = xyz[2];
        var l;
        var a;
        var b;
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
        l = 116 * y - 16;
        a = 500 * (x - y);
        b = 200 * (y - z);
        return [l, a, b];
      };
      convert.hsl.rgb = function(hsl) {
        var h = hsl[0] / 360;
        var s2 = hsl[1] / 100;
        var l = hsl[2] / 100;
        var t1;
        var t2;
        var t3;
        var rgb;
        var val;
        if (s2 === 0) {
          val = l * 255;
          return [val, val, val];
        }
        if (l < 0.5) {
          t2 = l * (1 + s2);
        } else {
          t2 = l + s2 - l * s2;
        }
        t1 = 2 * l - t2;
        rgb = [0, 0, 0];
        for (var i2 = 0; i2 < 3; i2++) {
          t3 = h + 1 / 3 * -(i2 - 1);
          if (t3 < 0) {
            t3++;
          }
          if (t3 > 1) {
            t3--;
          }
          if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3;
          } else if (2 * t3 < 1) {
            val = t2;
          } else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
          } else {
            val = t1;
          }
          rgb[i2] = val * 255;
        }
        return rgb;
      };
      convert.hsl.hsv = function(hsl) {
        var h = hsl[0];
        var s2 = hsl[1] / 100;
        var l = hsl[2] / 100;
        var smin = s2;
        var lmin = Math.max(l, 0.01);
        var sv;
        var v;
        l *= 2;
        s2 *= l <= 1 ? l : 2 - l;
        smin *= lmin <= 1 ? lmin : 2 - lmin;
        v = (l + s2) / 2;
        sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l + s2);
        return [h, sv * 100, v * 100];
      };
      convert.hsv.rgb = function(hsv) {
        var h = hsv[0] / 60;
        var s2 = hsv[1] / 100;
        var v = hsv[2] / 100;
        var hi = Math.floor(h) % 6;
        var f = h - Math.floor(h);
        var p = 255 * v * (1 - s2);
        var q = 255 * v * (1 - s2 * f);
        var t2 = 255 * v * (1 - s2 * (1 - f));
        v *= 255;
        switch (hi) {
          case 0:
            return [v, t2, p];
          case 1:
            return [q, v, p];
          case 2:
            return [p, v, t2];
          case 3:
            return [p, q, v];
          case 4:
            return [t2, p, v];
          case 5:
            return [v, p, q];
        }
      };
      convert.hsv.hsl = function(hsv) {
        var h = hsv[0];
        var s2 = hsv[1] / 100;
        var v = hsv[2] / 100;
        var vmin = Math.max(v, 0.01);
        var lmin;
        var sl;
        var l;
        l = (2 - s2) * v;
        lmin = (2 - s2) * vmin;
        sl = s2 * vmin;
        sl /= lmin <= 1 ? lmin : 2 - lmin;
        sl = sl || 0;
        l /= 2;
        return [h, sl * 100, l * 100];
      };
      convert.hwb.rgb = function(hwb) {
        var h = hwb[0] / 360;
        var wh = hwb[1] / 100;
        var bl = hwb[2] / 100;
        var ratio = wh + bl;
        var i2;
        var v;
        var f;
        var n2;
        if (ratio > 1) {
          wh /= ratio;
          bl /= ratio;
        }
        i2 = Math.floor(6 * h);
        v = 1 - bl;
        f = 6 * h - i2;
        if ((i2 & 1) !== 0) {
          f = 1 - f;
        }
        n2 = wh + f * (v - wh);
        var r;
        var g;
        var b;
        switch (i2) {
          default:
          case 6:
          case 0:
            r = v;
            g = n2;
            b = wh;
            break;
          case 1:
            r = n2;
            g = v;
            b = wh;
            break;
          case 2:
            r = wh;
            g = v;
            b = n2;
            break;
          case 3:
            r = wh;
            g = n2;
            b = v;
            break;
          case 4:
            r = n2;
            g = wh;
            b = v;
            break;
          case 5:
            r = v;
            g = wh;
            b = n2;
            break;
        }
        return [r * 255, g * 255, b * 255];
      };
      convert.cmyk.rgb = function(cmyk) {
        var c = cmyk[0] / 100;
        var m = cmyk[1] / 100;
        var y = cmyk[2] / 100;
        var k = cmyk[3] / 100;
        var r;
        var g;
        var b;
        r = 1 - Math.min(1, c * (1 - k) + k);
        g = 1 - Math.min(1, m * (1 - k) + k);
        b = 1 - Math.min(1, y * (1 - k) + k);
        return [r * 255, g * 255, b * 255];
      };
      convert.xyz.rgb = function(xyz) {
        var x = xyz[0] / 100;
        var y = xyz[1] / 100;
        var z = xyz[2] / 100;
        var r;
        var g;
        var b;
        r = x * 3.2406 + y * -1.5372 + z * -0.4986;
        g = x * -0.9689 + y * 1.8758 + z * 0.0415;
        b = x * 0.0557 + y * -0.204 + z * 1.057;
        r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
        g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
        b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
        r = Math.min(Math.max(0, r), 1);
        g = Math.min(Math.max(0, g), 1);
        b = Math.min(Math.max(0, b), 1);
        return [r * 255, g * 255, b * 255];
      };
      convert.xyz.lab = function(xyz) {
        var x = xyz[0];
        var y = xyz[1];
        var z = xyz[2];
        var l;
        var a;
        var b;
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
        l = 116 * y - 16;
        a = 500 * (x - y);
        b = 200 * (y - z);
        return [l, a, b];
      };
      convert.lab.xyz = function(lab) {
        var l = lab[0];
        var a = lab[1];
        var b = lab[2];
        var x;
        var y;
        var z;
        y = (l + 16) / 116;
        x = a / 500 + y;
        z = y - b / 200;
        var y2 = Math.pow(y, 3);
        var x2 = Math.pow(x, 3);
        var z2 = Math.pow(z, 3);
        y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
        x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
        z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
        x *= 95.047;
        y *= 100;
        z *= 108.883;
        return [x, y, z];
      };
      convert.lab.lch = function(lab) {
        var l = lab[0];
        var a = lab[1];
        var b = lab[2];
        var hr;
        var h;
        var c;
        hr = Math.atan2(b, a);
        h = hr * 360 / 2 / Math.PI;
        if (h < 0) {
          h += 360;
        }
        c = Math.sqrt(a * a + b * b);
        return [l, c, h];
      };
      convert.lch.lab = function(lch) {
        var l = lch[0];
        var c = lch[1];
        var h = lch[2];
        var a;
        var b;
        var hr;
        hr = h / 360 * 2 * Math.PI;
        a = c * Math.cos(hr);
        b = c * Math.sin(hr);
        return [l, a, b];
      };
      convert.rgb.ansi16 = function(args) {
        var r = args[0];
        var g = args[1];
        var b = args[2];
        var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
        value = Math.round(value / 50);
        if (value === 0) {
          return 30;
        }
        var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
        if (value === 2) {
          ansi += 60;
        }
        return ansi;
      };
      convert.hsv.ansi16 = function(args) {
        return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
      };
      convert.rgb.ansi256 = function(args) {
        var r = args[0];
        var g = args[1];
        var b = args[2];
        if (r === g && g === b) {
          if (r < 8) {
            return 16;
          }
          if (r > 248) {
            return 231;
          }
          return Math.round((r - 8) / 247 * 24) + 232;
        }
        var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
        return ansi;
      };
      convert.ansi16.rgb = function(args) {
        var color = args % 10;
        if (color === 0 || color === 7) {
          if (args > 50) {
            color += 3.5;
          }
          color = color / 10.5 * 255;
          return [color, color, color];
        }
        var mult = (~~(args > 50) + 1) * 0.5;
        var r = (color & 1) * mult * 255;
        var g = (color >> 1 & 1) * mult * 255;
        var b = (color >> 2 & 1) * mult * 255;
        return [r, g, b];
      };
      convert.ansi256.rgb = function(args) {
        if (args >= 232) {
          var c = (args - 232) * 10 + 8;
          return [c, c, c];
        }
        args -= 16;
        var rem;
        var r = Math.floor(args / 36) / 5 * 255;
        var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
        var b = rem % 6 / 5 * 255;
        return [r, g, b];
      };
      convert.rgb.hex = function(args) {
        var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
        var string = integer.toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      };
      convert.hex.rgb = function(args) {
        var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!match) {
          return [0, 0, 0];
        }
        var colorString = match[0];
        if (match[0].length === 3) {
          colorString = colorString.split("").map(function(char) {
            return char + char;
          }).join("");
        }
        var integer = parseInt(colorString, 16);
        var r = integer >> 16 & 255;
        var g = integer >> 8 & 255;
        var b = integer & 255;
        return [r, g, b];
      };
      convert.rgb.hcg = function(rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var max = Math.max(Math.max(r, g), b);
        var min = Math.min(Math.min(r, g), b);
        var chroma = max - min;
        var grayscale;
        var hue;
        if (chroma < 1) {
          grayscale = min / (1 - chroma);
        } else {
          grayscale = 0;
        }
        if (chroma <= 0) {
          hue = 0;
        } else if (max === r) {
          hue = (g - b) / chroma % 6;
        } else if (max === g) {
          hue = 2 + (b - r) / chroma;
        } else {
          hue = 4 + (r - g) / chroma + 4;
        }
        hue /= 6;
        hue %= 1;
        return [hue * 360, chroma * 100, grayscale * 100];
      };
      convert.hsl.hcg = function(hsl) {
        var s2 = hsl[1] / 100;
        var l = hsl[2] / 100;
        var c = 1;
        var f = 0;
        if (l < 0.5) {
          c = 2 * s2 * l;
        } else {
          c = 2 * s2 * (1 - l);
        }
        if (c < 1) {
          f = (l - 0.5 * c) / (1 - c);
        }
        return [hsl[0], c * 100, f * 100];
      };
      convert.hsv.hcg = function(hsv) {
        var s2 = hsv[1] / 100;
        var v = hsv[2] / 100;
        var c = s2 * v;
        var f = 0;
        if (c < 1) {
          f = (v - c) / (1 - c);
        }
        return [hsv[0], c * 100, f * 100];
      };
      convert.hcg.rgb = function(hcg) {
        var h = hcg[0] / 360;
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        if (c === 0) {
          return [g * 255, g * 255, g * 255];
        }
        var pure = [0, 0, 0];
        var hi = h % 1 * 6;
        var v = hi % 1;
        var w = 1 - v;
        var mg = 0;
        switch (Math.floor(hi)) {
          case 0:
            pure[0] = 1;
            pure[1] = v;
            pure[2] = 0;
            break;
          case 1:
            pure[0] = w;
            pure[1] = 1;
            pure[2] = 0;
            break;
          case 2:
            pure[0] = 0;
            pure[1] = 1;
            pure[2] = v;
            break;
          case 3:
            pure[0] = 0;
            pure[1] = w;
            pure[2] = 1;
            break;
          case 4:
            pure[0] = v;
            pure[1] = 0;
            pure[2] = 1;
            break;
          default:
            pure[0] = 1;
            pure[1] = 0;
            pure[2] = w;
        }
        mg = (1 - c) * g;
        return [
          (c * pure[0] + mg) * 255,
          (c * pure[1] + mg) * 255,
          (c * pure[2] + mg) * 255
        ];
      };
      convert.hcg.hsv = function(hcg) {
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        var v = c + g * (1 - c);
        var f = 0;
        if (v > 0) {
          f = c / v;
        }
        return [hcg[0], f * 100, v * 100];
      };
      convert.hcg.hsl = function(hcg) {
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        var l = g * (1 - c) + 0.5 * c;
        var s2 = 0;
        if (l > 0 && l < 0.5) {
          s2 = c / (2 * l);
        } else if (l >= 0.5 && l < 1) {
          s2 = c / (2 * (1 - l));
        }
        return [hcg[0], s2 * 100, l * 100];
      };
      convert.hcg.hwb = function(hcg) {
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        var v = c + g * (1 - c);
        return [hcg[0], (v - c) * 100, (1 - v) * 100];
      };
      convert.hwb.hcg = function(hwb) {
        var w = hwb[1] / 100;
        var b = hwb[2] / 100;
        var v = 1 - b;
        var c = v - w;
        var g = 0;
        if (c < 1) {
          g = (v - c) / (1 - c);
        }
        return [hwb[0], c * 100, g * 100];
      };
      convert.apple.rgb = function(apple) {
        return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
      };
      convert.rgb.apple = function(rgb) {
        return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
      };
      convert.gray.rgb = function(args) {
        return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
      };
      convert.gray.hsl = convert.gray.hsv = function(args) {
        return [0, 0, args[0]];
      };
      convert.gray.hwb = function(gray) {
        return [0, 100, gray[0]];
      };
      convert.gray.cmyk = function(gray) {
        return [0, 0, 0, gray[0]];
      };
      convert.gray.lab = function(gray) {
        return [gray[0], 0, 0];
      };
      convert.gray.hex = function(gray) {
        var val = Math.round(gray[0] / 100 * 255) & 255;
        var integer = (val << 16) + (val << 8) + val;
        var string = integer.toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      };
      convert.rgb.gray = function(rgb) {
        var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
        return [val / 255 * 100];
      };
    }
  });

  // node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/route.js
  var require_route = __commonJS({
    "node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/route.js"(exports, module) {
      var conversions = require_conversions();
      function buildGraph() {
        var graph = {};
        var models = Object.keys(conversions);
        for (var len = models.length, i2 = 0; i2 < len; i2++) {
          graph[models[i2]] = {
            // http://jsperf.com/1-vs-infinity
            // micro-opt, but this is simple.
            distance: -1,
            parent: null
          };
        }
        return graph;
      }
      function deriveBFS(fromModel) {
        var graph = buildGraph();
        var queue = [fromModel];
        graph[fromModel].distance = 0;
        while (queue.length) {
          var current = queue.pop();
          var adjacents = Object.keys(conversions[current]);
          for (var len = adjacents.length, i2 = 0; i2 < len; i2++) {
            var adjacent = adjacents[i2];
            var node = graph[adjacent];
            if (node.distance === -1) {
              node.distance = graph[current].distance + 1;
              node.parent = current;
              queue.unshift(adjacent);
            }
          }
        }
        return graph;
      }
      function link(from, to) {
        return function(args) {
          return to(from(args));
        };
      }
      function wrapConversion(toModel, graph) {
        var path = [graph[toModel].parent, toModel];
        var fn = conversions[graph[toModel].parent][toModel];
        var cur = graph[toModel].parent;
        while (graph[cur].parent) {
          path.unshift(graph[cur].parent);
          fn = link(conversions[graph[cur].parent][cur], fn);
          cur = graph[cur].parent;
        }
        fn.conversion = path;
        return fn;
      }
      module.exports = function(fromModel) {
        var graph = deriveBFS(fromModel);
        var conversion = {};
        var models = Object.keys(graph);
        for (var len = models.length, i2 = 0; i2 < len; i2++) {
          var toModel = models[i2];
          var node = graph[toModel];
          if (node.parent === null) {
            continue;
          }
          conversion[toModel] = wrapConversion(toModel, graph);
        }
        return conversion;
      };
    }
  });

  // node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/index.js
  var require_color_convert = __commonJS({
    "node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/index.js"(exports, module) {
      var conversions = require_conversions();
      var route = require_route();
      var convert = {};
      var models = Object.keys(conversions);
      function wrapRaw(fn) {
        var wrappedFn = function(args) {
          if (args === void 0 || args === null) {
            return args;
          }
          if (arguments.length > 1) {
            args = Array.prototype.slice.call(arguments);
          }
          return fn(args);
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      function wrapRounded(fn) {
        var wrappedFn = function(args) {
          if (args === void 0 || args === null) {
            return args;
          }
          if (arguments.length > 1) {
            args = Array.prototype.slice.call(arguments);
          }
          var result = fn(args);
          if (typeof result === "object") {
            for (var len = result.length, i2 = 0; i2 < len; i2++) {
              result[i2] = Math.round(result[i2]);
            }
          }
          return result;
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      models.forEach(function(fromModel) {
        convert[fromModel] = {};
        Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
        Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
        var routes = route(fromModel);
        var routeModels = Object.keys(routes);
        routeModels.forEach(function(toModel) {
          var fn = routes[toModel];
          convert[fromModel][toModel] = wrapRounded(fn);
          convert[fromModel][toModel].raw = wrapRaw(fn);
        });
      });
      module.exports = convert;
    }
  });

  // node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js
  var require_color_name2 = __commonJS({
    "node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js"(exports, module) {
      "use strict";
      module.exports = {
        "aliceblue": [240, 248, 255],
        "antiquewhite": [250, 235, 215],
        "aqua": [0, 255, 255],
        "aquamarine": [127, 255, 212],
        "azure": [240, 255, 255],
        "beige": [245, 245, 220],
        "bisque": [255, 228, 196],
        "black": [0, 0, 0],
        "blanchedalmond": [255, 235, 205],
        "blue": [0, 0, 255],
        "blueviolet": [138, 43, 226],
        "brown": [165, 42, 42],
        "burlywood": [222, 184, 135],
        "cadetblue": [95, 158, 160],
        "chartreuse": [127, 255, 0],
        "chocolate": [210, 105, 30],
        "coral": [255, 127, 80],
        "cornflowerblue": [100, 149, 237],
        "cornsilk": [255, 248, 220],
        "crimson": [220, 20, 60],
        "cyan": [0, 255, 255],
        "darkblue": [0, 0, 139],
        "darkcyan": [0, 139, 139],
        "darkgoldenrod": [184, 134, 11],
        "darkgray": [169, 169, 169],
        "darkgreen": [0, 100, 0],
        "darkgrey": [169, 169, 169],
        "darkkhaki": [189, 183, 107],
        "darkmagenta": [139, 0, 139],
        "darkolivegreen": [85, 107, 47],
        "darkorange": [255, 140, 0],
        "darkorchid": [153, 50, 204],
        "darkred": [139, 0, 0],
        "darksalmon": [233, 150, 122],
        "darkseagreen": [143, 188, 143],
        "darkslateblue": [72, 61, 139],
        "darkslategray": [47, 79, 79],
        "darkslategrey": [47, 79, 79],
        "darkturquoise": [0, 206, 209],
        "darkviolet": [148, 0, 211],
        "deeppink": [255, 20, 147],
        "deepskyblue": [0, 191, 255],
        "dimgray": [105, 105, 105],
        "dimgrey": [105, 105, 105],
        "dodgerblue": [30, 144, 255],
        "firebrick": [178, 34, 34],
        "floralwhite": [255, 250, 240],
        "forestgreen": [34, 139, 34],
        "fuchsia": [255, 0, 255],
        "gainsboro": [220, 220, 220],
        "ghostwhite": [248, 248, 255],
        "gold": [255, 215, 0],
        "goldenrod": [218, 165, 32],
        "gray": [128, 128, 128],
        "green": [0, 128, 0],
        "greenyellow": [173, 255, 47],
        "grey": [128, 128, 128],
        "honeydew": [240, 255, 240],
        "hotpink": [255, 105, 180],
        "indianred": [205, 92, 92],
        "indigo": [75, 0, 130],
        "ivory": [255, 255, 240],
        "khaki": [240, 230, 140],
        "lavender": [230, 230, 250],
        "lavenderblush": [255, 240, 245],
        "lawngreen": [124, 252, 0],
        "lemonchiffon": [255, 250, 205],
        "lightblue": [173, 216, 230],
        "lightcoral": [240, 128, 128],
        "lightcyan": [224, 255, 255],
        "lightgoldenrodyellow": [250, 250, 210],
        "lightgray": [211, 211, 211],
        "lightgreen": [144, 238, 144],
        "lightgrey": [211, 211, 211],
        "lightpink": [255, 182, 193],
        "lightsalmon": [255, 160, 122],
        "lightseagreen": [32, 178, 170],
        "lightskyblue": [135, 206, 250],
        "lightslategray": [119, 136, 153],
        "lightslategrey": [119, 136, 153],
        "lightsteelblue": [176, 196, 222],
        "lightyellow": [255, 255, 224],
        "lime": [0, 255, 0],
        "limegreen": [50, 205, 50],
        "linen": [250, 240, 230],
        "magenta": [255, 0, 255],
        "maroon": [128, 0, 0],
        "mediumaquamarine": [102, 205, 170],
        "mediumblue": [0, 0, 205],
        "mediumorchid": [186, 85, 211],
        "mediumpurple": [147, 112, 219],
        "mediumseagreen": [60, 179, 113],
        "mediumslateblue": [123, 104, 238],
        "mediumspringgreen": [0, 250, 154],
        "mediumturquoise": [72, 209, 204],
        "mediumvioletred": [199, 21, 133],
        "midnightblue": [25, 25, 112],
        "mintcream": [245, 255, 250],
        "mistyrose": [255, 228, 225],
        "moccasin": [255, 228, 181],
        "navajowhite": [255, 222, 173],
        "navy": [0, 0, 128],
        "oldlace": [253, 245, 230],
        "olive": [128, 128, 0],
        "olivedrab": [107, 142, 35],
        "orange": [255, 165, 0],
        "orangered": [255, 69, 0],
        "orchid": [218, 112, 214],
        "palegoldenrod": [238, 232, 170],
        "palegreen": [152, 251, 152],
        "paleturquoise": [175, 238, 238],
        "palevioletred": [219, 112, 147],
        "papayawhip": [255, 239, 213],
        "peachpuff": [255, 218, 185],
        "peru": [205, 133, 63],
        "pink": [255, 192, 203],
        "plum": [221, 160, 221],
        "powderblue": [176, 224, 230],
        "purple": [128, 0, 128],
        "rebeccapurple": [102, 51, 153],
        "red": [255, 0, 0],
        "rosybrown": [188, 143, 143],
        "royalblue": [65, 105, 225],
        "saddlebrown": [139, 69, 19],
        "salmon": [250, 128, 114],
        "sandybrown": [244, 164, 96],
        "seagreen": [46, 139, 87],
        "seashell": [255, 245, 238],
        "sienna": [160, 82, 45],
        "silver": [192, 192, 192],
        "skyblue": [135, 206, 235],
        "slateblue": [106, 90, 205],
        "slategray": [112, 128, 144],
        "slategrey": [112, 128, 144],
        "snow": [255, 250, 250],
        "springgreen": [0, 255, 127],
        "steelblue": [70, 130, 180],
        "tan": [210, 180, 140],
        "teal": [0, 128, 128],
        "thistle": [216, 191, 216],
        "tomato": [255, 99, 71],
        "turquoise": [64, 224, 208],
        "violet": [238, 130, 238],
        "wheat": [245, 222, 179],
        "white": [255, 255, 255],
        "whitesmoke": [245, 245, 245],
        "yellow": [255, 255, 0],
        "yellowgreen": [154, 205, 50]
      };
    }
  });

  // node_modules/.pnpm/chartjs-color-string@0.6.0/node_modules/chartjs-color-string/color-string.js
  var require_color_string = __commonJS({
    "node_modules/.pnpm/chartjs-color-string@0.6.0/node_modules/chartjs-color-string/color-string.js"(exports, module) {
      var colorNames = require_color_name2();
      module.exports = {
        getRgba,
        getHsla,
        getRgb,
        getHsl,
        getHwb,
        getAlpha,
        hexString,
        rgbString,
        rgbaString,
        percentString,
        percentaString,
        hslString,
        hslaString,
        hwbString,
        keyword
      };
      function getRgba(string) {
        if (!string) {
          return;
        }
        var abbr = /^#([a-fA-F0-9]{3,4})$/i, hex = /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i, rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i, per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i, keyword2 = /(\w+)/;
        var rgb = [0, 0, 0], a = 1, match = string.match(abbr), hexAlpha = "";
        if (match) {
          match = match[1];
          hexAlpha = match[3];
          for (var i2 = 0; i2 < rgb.length; i2++) {
            rgb[i2] = parseInt(match[i2] + match[i2], 16);
          }
          if (hexAlpha) {
            a = Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) / 100;
          }
        } else if (match = string.match(hex)) {
          hexAlpha = match[2];
          match = match[1];
          for (var i2 = 0; i2 < rgb.length; i2++) {
            rgb[i2] = parseInt(match.slice(i2 * 2, i2 * 2 + 2), 16);
          }
          if (hexAlpha) {
            a = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100;
          }
        } else if (match = string.match(rgba)) {
          for (var i2 = 0; i2 < rgb.length; i2++) {
            rgb[i2] = parseInt(match[i2 + 1]);
          }
          a = parseFloat(match[4]);
        } else if (match = string.match(per)) {
          for (var i2 = 0; i2 < rgb.length; i2++) {
            rgb[i2] = Math.round(parseFloat(match[i2 + 1]) * 2.55);
          }
          a = parseFloat(match[4]);
        } else if (match = string.match(keyword2)) {
          if (match[1] == "transparent") {
            return [0, 0, 0, 0];
          }
          rgb = colorNames[match[1]];
          if (!rgb) {
            return;
          }
        }
        for (var i2 = 0; i2 < rgb.length; i2++) {
          rgb[i2] = scale(rgb[i2], 0, 255);
        }
        if (!a && a != 0) {
          a = 1;
        } else {
          a = scale(a, 0, 1);
        }
        rgb[3] = a;
        return rgb;
      }
      function getHsla(string) {
        if (!string) {
          return;
        }
        var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
        var match = string.match(hsl);
        if (match) {
          var alpha = parseFloat(match[4]);
          var h = scale(parseInt(match[1]), 0, 360), s2 = scale(parseFloat(match[2]), 0, 100), l = scale(parseFloat(match[3]), 0, 100), a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
          return [h, s2, l, a];
        }
      }
      function getHwb(string) {
        if (!string) {
          return;
        }
        var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
        var match = string.match(hwb);
        if (match) {
          var alpha = parseFloat(match[4]);
          var h = scale(parseInt(match[1]), 0, 360), w = scale(parseFloat(match[2]), 0, 100), b = scale(parseFloat(match[3]), 0, 100), a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
          return [h, w, b, a];
        }
      }
      function getRgb(string) {
        var rgba = getRgba(string);
        return rgba && rgba.slice(0, 3);
      }
      function getHsl(string) {
        var hsla = getHsla(string);
        return hsla && hsla.slice(0, 3);
      }
      function getAlpha(string) {
        var vals = getRgba(string);
        if (vals) {
          return vals[3];
        } else if (vals = getHsla(string)) {
          return vals[3];
        } else if (vals = getHwb(string)) {
          return vals[3];
        }
      }
      function hexString(rgba, a) {
        var a = a !== void 0 && rgba.length === 3 ? a : rgba[3];
        return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (a >= 0 && a < 1 ? hexDouble(Math.round(a * 255)) : "");
      }
      function rgbString(rgba, alpha) {
        if (alpha < 1 || rgba[3] && rgba[3] < 1) {
          return rgbaString(rgba, alpha);
        }
        return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
      }
      function rgbaString(rgba, alpha) {
        if (alpha === void 0) {
          alpha = rgba[3] !== void 0 ? rgba[3] : 1;
        }
        return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
      }
      function percentString(rgba, alpha) {
        if (alpha < 1 || rgba[3] && rgba[3] < 1) {
          return percentaString(rgba, alpha);
        }
        var r = Math.round(rgba[0] / 255 * 100), g = Math.round(rgba[1] / 255 * 100), b = Math.round(rgba[2] / 255 * 100);
        return "rgb(" + r + "%, " + g + "%, " + b + "%)";
      }
      function percentaString(rgba, alpha) {
        var r = Math.round(rgba[0] / 255 * 100), g = Math.round(rgba[1] / 255 * 100), b = Math.round(rgba[2] / 255 * 100);
        return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
      }
      function hslString(hsla, alpha) {
        if (alpha < 1 || hsla[3] && hsla[3] < 1) {
          return hslaString(hsla, alpha);
        }
        return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
      }
      function hslaString(hsla, alpha) {
        if (alpha === void 0) {
          alpha = hsla[3] !== void 0 ? hsla[3] : 1;
        }
        return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
      }
      function hwbString(hwb, alpha) {
        if (alpha === void 0) {
          alpha = hwb[3] !== void 0 ? hwb[3] : 1;
        }
        return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (alpha !== void 0 && alpha !== 1 ? ", " + alpha : "") + ")";
      }
      function keyword(rgb) {
        return reverseNames[rgb.slice(0, 3)];
      }
      function scale(num, min, max) {
        return Math.min(Math.max(min, num), max);
      }
      function hexDouble(num) {
        var str = num.toString(16).toUpperCase();
        return str.length < 2 ? "0" + str : str;
      }
      var reverseNames = {};
      for (name in colorNames) {
        reverseNames[colorNames[name]] = name;
      }
      var name;
    }
  });

  // node_modules/.pnpm/chartjs-color@2.4.1/node_modules/chartjs-color/index.js
  var require_chartjs_color = __commonJS({
    "node_modules/.pnpm/chartjs-color@2.4.1/node_modules/chartjs-color/index.js"(exports, module) {
      var convert = require_color_convert();
      var string = require_color_string();
      var Color = function(obj) {
        if (obj instanceof Color) {
          return obj;
        }
        if (!(this instanceof Color)) {
          return new Color(obj);
        }
        this.valid = false;
        this.values = {
          rgb: [0, 0, 0],
          hsl: [0, 0, 0],
          hsv: [0, 0, 0],
          hwb: [0, 0, 0],
          cmyk: [0, 0, 0, 0],
          alpha: 1
        };
        var vals;
        if (typeof obj === "string") {
          vals = string.getRgba(obj);
          if (vals) {
            this.setValues("rgb", vals);
          } else if (vals = string.getHsla(obj)) {
            this.setValues("hsl", vals);
          } else if (vals = string.getHwb(obj)) {
            this.setValues("hwb", vals);
          }
        } else if (typeof obj === "object") {
          vals = obj;
          if (vals.r !== void 0 || vals.red !== void 0) {
            this.setValues("rgb", vals);
          } else if (vals.l !== void 0 || vals.lightness !== void 0) {
            this.setValues("hsl", vals);
          } else if (vals.v !== void 0 || vals.value !== void 0) {
            this.setValues("hsv", vals);
          } else if (vals.w !== void 0 || vals.whiteness !== void 0) {
            this.setValues("hwb", vals);
          } else if (vals.c !== void 0 || vals.cyan !== void 0) {
            this.setValues("cmyk", vals);
          }
        }
      };
      Color.prototype = {
        isValid: function() {
          return this.valid;
        },
        rgb: function() {
          return this.setSpace("rgb", arguments);
        },
        hsl: function() {
          return this.setSpace("hsl", arguments);
        },
        hsv: function() {
          return this.setSpace("hsv", arguments);
        },
        hwb: function() {
          return this.setSpace("hwb", arguments);
        },
        cmyk: function() {
          return this.setSpace("cmyk", arguments);
        },
        rgbArray: function() {
          return this.values.rgb;
        },
        hslArray: function() {
          return this.values.hsl;
        },
        hsvArray: function() {
          return this.values.hsv;
        },
        hwbArray: function() {
          var values = this.values;
          if (values.alpha !== 1) {
            return values.hwb.concat([values.alpha]);
          }
          return values.hwb;
        },
        cmykArray: function() {
          return this.values.cmyk;
        },
        rgbaArray: function() {
          var values = this.values;
          return values.rgb.concat([values.alpha]);
        },
        hslaArray: function() {
          var values = this.values;
          return values.hsl.concat([values.alpha]);
        },
        alpha: function(val) {
          if (val === void 0) {
            return this.values.alpha;
          }
          this.setValues("alpha", val);
          return this;
        },
        red: function(val) {
          return this.setChannel("rgb", 0, val);
        },
        green: function(val) {
          return this.setChannel("rgb", 1, val);
        },
        blue: function(val) {
          return this.setChannel("rgb", 2, val);
        },
        hue: function(val) {
          if (val) {
            val %= 360;
            val = val < 0 ? 360 + val : val;
          }
          return this.setChannel("hsl", 0, val);
        },
        saturation: function(val) {
          return this.setChannel("hsl", 1, val);
        },
        lightness: function(val) {
          return this.setChannel("hsl", 2, val);
        },
        saturationv: function(val) {
          return this.setChannel("hsv", 1, val);
        },
        whiteness: function(val) {
          return this.setChannel("hwb", 1, val);
        },
        blackness: function(val) {
          return this.setChannel("hwb", 2, val);
        },
        value: function(val) {
          return this.setChannel("hsv", 2, val);
        },
        cyan: function(val) {
          return this.setChannel("cmyk", 0, val);
        },
        magenta: function(val) {
          return this.setChannel("cmyk", 1, val);
        },
        yellow: function(val) {
          return this.setChannel("cmyk", 2, val);
        },
        black: function(val) {
          return this.setChannel("cmyk", 3, val);
        },
        hexString: function() {
          return string.hexString(this.values.rgb);
        },
        rgbString: function() {
          return string.rgbString(this.values.rgb, this.values.alpha);
        },
        rgbaString: function() {
          return string.rgbaString(this.values.rgb, this.values.alpha);
        },
        percentString: function() {
          return string.percentString(this.values.rgb, this.values.alpha);
        },
        hslString: function() {
          return string.hslString(this.values.hsl, this.values.alpha);
        },
        hslaString: function() {
          return string.hslaString(this.values.hsl, this.values.alpha);
        },
        hwbString: function() {
          return string.hwbString(this.values.hwb, this.values.alpha);
        },
        keyword: function() {
          return string.keyword(this.values.rgb, this.values.alpha);
        },
        rgbNumber: function() {
          var rgb = this.values.rgb;
          return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
        },
        luminosity: function() {
          var rgb = this.values.rgb;
          var lum = [];
          for (var i2 = 0; i2 < rgb.length; i2++) {
            var chan = rgb[i2] / 255;
            lum[i2] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
          }
          return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
        },
        contrast: function(color2) {
          var lum1 = this.luminosity();
          var lum2 = color2.luminosity();
          if (lum1 > lum2) {
            return (lum1 + 0.05) / (lum2 + 0.05);
          }
          return (lum2 + 0.05) / (lum1 + 0.05);
        },
        level: function(color2) {
          var contrastRatio = this.contrast(color2);
          if (contrastRatio >= 7.1) {
            return "AAA";
          }
          return contrastRatio >= 4.5 ? "AA" : "";
        },
        dark: function() {
          var rgb = this.values.rgb;
          var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1e3;
          return yiq < 128;
        },
        light: function() {
          return !this.dark();
        },
        negate: function() {
          var rgb = [];
          for (var i2 = 0; i2 < 3; i2++) {
            rgb[i2] = 255 - this.values.rgb[i2];
          }
          this.setValues("rgb", rgb);
          return this;
        },
        lighten: function(ratio) {
          var hsl = this.values.hsl;
          hsl[2] += hsl[2] * ratio;
          this.setValues("hsl", hsl);
          return this;
        },
        darken: function(ratio) {
          var hsl = this.values.hsl;
          hsl[2] -= hsl[2] * ratio;
          this.setValues("hsl", hsl);
          return this;
        },
        saturate: function(ratio) {
          var hsl = this.values.hsl;
          hsl[1] += hsl[1] * ratio;
          this.setValues("hsl", hsl);
          return this;
        },
        desaturate: function(ratio) {
          var hsl = this.values.hsl;
          hsl[1] -= hsl[1] * ratio;
          this.setValues("hsl", hsl);
          return this;
        },
        whiten: function(ratio) {
          var hwb = this.values.hwb;
          hwb[1] += hwb[1] * ratio;
          this.setValues("hwb", hwb);
          return this;
        },
        blacken: function(ratio) {
          var hwb = this.values.hwb;
          hwb[2] += hwb[2] * ratio;
          this.setValues("hwb", hwb);
          return this;
        },
        greyscale: function() {
          var rgb = this.values.rgb;
          var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
          this.setValues("rgb", [val, val, val]);
          return this;
        },
        clearer: function(ratio) {
          var alpha = this.values.alpha;
          this.setValues("alpha", alpha - alpha * ratio);
          return this;
        },
        opaquer: function(ratio) {
          var alpha = this.values.alpha;
          this.setValues("alpha", alpha + alpha * ratio);
          return this;
        },
        rotate: function(degrees) {
          var hsl = this.values.hsl;
          var hue = (hsl[0] + degrees) % 360;
          hsl[0] = hue < 0 ? 360 + hue : hue;
          this.setValues("hsl", hsl);
          return this;
        },
        /**
         * Ported from sass implementation in C
         * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
         */
        mix: function(mixinColor, weight) {
          var color1 = this;
          var color2 = mixinColor;
          var p = weight === void 0 ? 0.5 : weight;
          var w = 2 * p - 1;
          var a = color1.alpha() - color2.alpha();
          var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
          var w2 = 1 - w1;
          return this.rgb(
            w1 * color1.red() + w2 * color2.red(),
            w1 * color1.green() + w2 * color2.green(),
            w1 * color1.blue() + w2 * color2.blue()
          ).alpha(color1.alpha() * p + color2.alpha() * (1 - p));
        },
        toJSON: function() {
          return this.rgb();
        },
        clone: function() {
          var result = new Color();
          var source = this.values;
          var target = result.values;
          var value, type;
          for (var prop in source) {
            if (source.hasOwnProperty(prop)) {
              value = source[prop];
              type = {}.toString.call(value);
              if (type === "[object Array]") {
                target[prop] = value.slice(0);
              } else if (type === "[object Number]") {
                target[prop] = value;
              } else {
                console.error("unexpected color value:", value);
              }
            }
          }
          return result;
        }
      };
      Color.prototype.spaces = {
        rgb: ["red", "green", "blue"],
        hsl: ["hue", "saturation", "lightness"],
        hsv: ["hue", "saturation", "value"],
        hwb: ["hue", "whiteness", "blackness"],
        cmyk: ["cyan", "magenta", "yellow", "black"]
      };
      Color.prototype.maxes = {
        rgb: [255, 255, 255],
        hsl: [360, 100, 100],
        hsv: [360, 100, 100],
        hwb: [360, 100, 100],
        cmyk: [100, 100, 100, 100]
      };
      Color.prototype.getValues = function(space2) {
        var values = this.values;
        var vals = {};
        for (var i2 = 0; i2 < space2.length; i2++) {
          vals[space2.charAt(i2)] = values[space2][i2];
        }
        if (values.alpha !== 1) {
          vals.a = values.alpha;
        }
        return vals;
      };
      Color.prototype.setValues = function(space2, vals) {
        var values = this.values;
        var spaces = this.spaces;
        var maxes = this.maxes;
        var alpha = 1;
        var i2;
        this.valid = true;
        if (space2 === "alpha") {
          alpha = vals;
        } else if (vals.length) {
          values[space2] = vals.slice(0, space2.length);
          alpha = vals[space2.length];
        } else if (vals[space2.charAt(0)] !== void 0) {
          for (i2 = 0; i2 < space2.length; i2++) {
            values[space2][i2] = vals[space2.charAt(i2)];
          }
          alpha = vals.a;
        } else if (vals[spaces[space2][0]] !== void 0) {
          var chans = spaces[space2];
          for (i2 = 0; i2 < space2.length; i2++) {
            values[space2][i2] = vals[chans[i2]];
          }
          alpha = vals.alpha;
        }
        values.alpha = Math.max(0, Math.min(1, alpha === void 0 ? values.alpha : alpha));
        if (space2 === "alpha") {
          return false;
        }
        var capped;
        for (i2 = 0; i2 < space2.length; i2++) {
          capped = Math.max(0, Math.min(maxes[space2][i2], values[space2][i2]));
          values[space2][i2] = Math.round(capped);
        }
        for (var sname in spaces) {
          if (sname !== space2) {
            values[sname] = convert[space2][sname](values[space2]);
          }
        }
        return true;
      };
      Color.prototype.setSpace = function(space2, args) {
        var vals = args[0];
        if (vals === void 0) {
          return this.getValues(space2);
        }
        if (typeof vals === "number") {
          vals = Array.prototype.slice.call(args);
        }
        this.setValues(space2, vals);
        return this;
      };
      Color.prototype.setChannel = function(space2, index, val) {
        var svalues = this.values[space2];
        if (val === void 0) {
          return svalues[index];
        } else if (val === svalues[index]) {
          return this;
        }
        svalues[index] = val;
        this.setValues(space2, svalues);
        return this;
      };
      if (typeof window !== "undefined") {
        window.Color = Color;
      }
      module.exports = Color;
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.helpers.js
  var require_core_helpers = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.helpers.js"(exports, module) {
      "use strict";
      var color = require_chartjs_color();
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers = {};
        helpers.each = function(loopable, callback, self, reverse) {
          var i2, len;
          if (helpers.isArray(loopable)) {
            len = loopable.length;
            if (reverse) {
              for (i2 = len - 1; i2 >= 0; i2--) {
                callback.call(self, loopable[i2], i2);
              }
            } else {
              for (i2 = 0; i2 < len; i2++) {
                callback.call(self, loopable[i2], i2);
              }
            }
          } else if (typeof loopable === "object") {
            var keys = Object.keys(loopable);
            len = keys.length;
            for (i2 = 0; i2 < len; i2++) {
              callback.call(self, loopable[keys[i2]], keys[i2]);
            }
          }
        };
        helpers.clone = function(obj) {
          var objClone = {};
          helpers.each(obj, function(value, key) {
            if (helpers.isArray(value)) {
              objClone[key] = value.slice(0);
            } else if (typeof value === "object" && value !== null) {
              objClone[key] = helpers.clone(value);
            } else {
              objClone[key] = value;
            }
          });
          return objClone;
        };
        helpers.extend = function(base) {
          var setFn = function(value, key) {
            base[key] = value;
          };
          for (var i2 = 1, ilen = arguments.length; i2 < ilen; i2++) {
            helpers.each(arguments[i2], setFn);
          }
          return base;
        };
        helpers.configMerge = function(_base) {
          var base = helpers.clone(_base);
          helpers.each(Array.prototype.slice.call(arguments, 1), function(extension) {
            helpers.each(extension, function(value, key) {
              var baseHasProperty = base.hasOwnProperty(key);
              var baseVal = baseHasProperty ? base[key] : {};
              if (key === "scales") {
                base[key] = helpers.scaleMerge(baseVal, value);
              } else if (key === "scale") {
                base[key] = helpers.configMerge(baseVal, Chart2.scaleService.getScaleDefaults(value.type), value);
              } else if (baseHasProperty && typeof baseVal === "object" && !helpers.isArray(baseVal) && baseVal !== null && typeof value === "object" && !helpers.isArray(value)) {
                base[key] = helpers.configMerge(baseVal, value);
              } else {
                base[key] = value;
              }
            });
          });
          return base;
        };
        helpers.scaleMerge = function(_base, extension) {
          var base = helpers.clone(_base);
          helpers.each(extension, function(value, key) {
            if (key === "xAxes" || key === "yAxes") {
              if (base.hasOwnProperty(key)) {
                helpers.each(value, function(valueObj, index) {
                  var axisType = helpers.getValueOrDefault(valueObj.type, key === "xAxes" ? "category" : "linear");
                  var axisDefaults = Chart2.scaleService.getScaleDefaults(axisType);
                  if (index >= base[key].length || !base[key][index].type) {
                    base[key].push(helpers.configMerge(axisDefaults, valueObj));
                  } else if (valueObj.type && valueObj.type !== base[key][index].type) {
                    base[key][index] = helpers.configMerge(base[key][index], axisDefaults, valueObj);
                  } else {
                    base[key][index] = helpers.configMerge(base[key][index], valueObj);
                  }
                });
              } else {
                base[key] = [];
                helpers.each(value, function(valueObj) {
                  var axisType = helpers.getValueOrDefault(valueObj.type, key === "xAxes" ? "category" : "linear");
                  base[key].push(helpers.configMerge(Chart2.scaleService.getScaleDefaults(axisType), valueObj));
                });
              }
            } else if (base.hasOwnProperty(key) && typeof base[key] === "object" && base[key] !== null && typeof value === "object") {
              base[key] = helpers.configMerge(base[key], value);
            } else {
              base[key] = value;
            }
          });
          return base;
        };
        helpers.getValueAtIndexOrDefault = function(value, index, defaultValue) {
          if (value === void 0 || value === null) {
            return defaultValue;
          }
          if (helpers.isArray(value)) {
            return index < value.length ? value[index] : defaultValue;
          }
          return value;
        };
        helpers.getValueOrDefault = function(value, defaultValue) {
          return value === void 0 ? defaultValue : value;
        };
        helpers.indexOf = Array.prototype.indexOf ? function(array, item) {
          return array.indexOf(item);
        } : function(array, item) {
          for (var i2 = 0, ilen = array.length; i2 < ilen; ++i2) {
            if (array[i2] === item) {
              return i2;
            }
          }
          return -1;
        };
        helpers.where = function(collection, filterCallback) {
          if (helpers.isArray(collection) && Array.prototype.filter) {
            return collection.filter(filterCallback);
          }
          var filtered = [];
          helpers.each(collection, function(item) {
            if (filterCallback(item)) {
              filtered.push(item);
            }
          });
          return filtered;
        };
        helpers.findIndex = Array.prototype.findIndex ? function(array, callback, scope) {
          return array.findIndex(callback, scope);
        } : function(array, callback, scope) {
          scope = scope === void 0 ? array : scope;
          for (var i2 = 0, ilen = array.length; i2 < ilen; ++i2) {
            if (callback.call(scope, array[i2], i2, array)) {
              return i2;
            }
          }
          return -1;
        };
        helpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {
          if (startIndex === void 0 || startIndex === null) {
            startIndex = -1;
          }
          for (var i2 = startIndex + 1; i2 < arrayToSearch.length; i2++) {
            var currentItem = arrayToSearch[i2];
            if (filterCallback(currentItem)) {
              return currentItem;
            }
          }
        };
        helpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {
          if (startIndex === void 0 || startIndex === null) {
            startIndex = arrayToSearch.length;
          }
          for (var i2 = startIndex - 1; i2 >= 0; i2--) {
            var currentItem = arrayToSearch[i2];
            if (filterCallback(currentItem)) {
              return currentItem;
            }
          }
        };
        helpers.inherits = function(extensions) {
          var me = this;
          var ChartElement = extensions && extensions.hasOwnProperty("constructor") ? extensions.constructor : function() {
            return me.apply(this, arguments);
          };
          var Surrogate = function() {
            this.constructor = ChartElement;
          };
          Surrogate.prototype = me.prototype;
          ChartElement.prototype = new Surrogate();
          ChartElement.extend = helpers.inherits;
          if (extensions) {
            helpers.extend(ChartElement.prototype, extensions);
          }
          ChartElement.__super__ = me.prototype;
          return ChartElement;
        };
        helpers.noop = function() {
        };
        helpers.uid = function() {
          var id = 0;
          return function() {
            return id++;
          };
        }();
        helpers.isNumber = function(n2) {
          return !isNaN(parseFloat(n2)) && isFinite(n2);
        };
        helpers.almostEquals = function(x, y, epsilon) {
          return Math.abs(x - y) < epsilon;
        };
        helpers.almostWhole = function(x, epsilon) {
          var rounded = Math.round(x);
          return rounded - epsilon < x && rounded + epsilon > x;
        };
        helpers.max = function(array) {
          return array.reduce(function(max, value) {
            if (!isNaN(value)) {
              return Math.max(max, value);
            }
            return max;
          }, Number.NEGATIVE_INFINITY);
        };
        helpers.min = function(array) {
          return array.reduce(function(min, value) {
            if (!isNaN(value)) {
              return Math.min(min, value);
            }
            return min;
          }, Number.POSITIVE_INFINITY);
        };
        helpers.sign = Math.sign ? function(x) {
          return Math.sign(x);
        } : function(x) {
          x = +x;
          if (x === 0 || isNaN(x)) {
            return x;
          }
          return x > 0 ? 1 : -1;
        };
        helpers.log10 = Math.log10 ? function(x) {
          return Math.log10(x);
        } : function(x) {
          return Math.log(x) / Math.LN10;
        };
        helpers.toRadians = function(degrees) {
          return degrees * (Math.PI / 180);
        };
        helpers.toDegrees = function(radians) {
          return radians * (180 / Math.PI);
        };
        helpers.getAngleFromPoint = function(centrePoint, anglePoint) {
          var distanceFromXCenter = anglePoint.x - centrePoint.x, distanceFromYCenter = anglePoint.y - centrePoint.y, radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
          var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
          if (angle < -0.5 * Math.PI) {
            angle += 2 * Math.PI;
          }
          return {
            angle,
            distance: radialDistanceFromCenter
          };
        };
        helpers.distanceBetweenPoints = function(pt1, pt2) {
          return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
        };
        helpers.aliasPixel = function(pixelWidth) {
          return pixelWidth % 2 === 0 ? 0 : 0.5;
        };
        helpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t2) {
          var previous = firstPoint.skip ? middlePoint : firstPoint, current = middlePoint, next = afterPoint.skip ? middlePoint : afterPoint;
          var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
          var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
          var s01 = d01 / (d01 + d12);
          var s12 = d12 / (d01 + d12);
          s01 = isNaN(s01) ? 0 : s01;
          s12 = isNaN(s12) ? 0 : s12;
          var fa = t2 * s01;
          var fb = t2 * s12;
          return {
            previous: {
              x: current.x - fa * (next.x - previous.x),
              y: current.y - fa * (next.y - previous.y)
            },
            next: {
              x: current.x + fb * (next.x - previous.x),
              y: current.y + fb * (next.y - previous.y)
            }
          };
        };
        helpers.EPSILON = Number.EPSILON || 1e-14;
        helpers.splineCurveMonotone = function(points) {
          var pointsWithTangents = (points || []).map(function(point) {
            return {
              model: point._model,
              deltaK: 0,
              mK: 0
            };
          });
          var pointsLen = pointsWithTangents.length;
          var i2, pointBefore, pointCurrent, pointAfter;
          for (i2 = 0; i2 < pointsLen; ++i2) {
            pointCurrent = pointsWithTangents[i2];
            if (pointCurrent.model.skip) {
              continue;
            }
            pointBefore = i2 > 0 ? pointsWithTangents[i2 - 1] : null;
            pointAfter = i2 < pointsLen - 1 ? pointsWithTangents[i2 + 1] : null;
            if (pointAfter && !pointAfter.model.skip) {
              var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x;
              pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
            }
            if (!pointBefore || pointBefore.model.skip) {
              pointCurrent.mK = pointCurrent.deltaK;
            } else if (!pointAfter || pointAfter.model.skip) {
              pointCurrent.mK = pointBefore.deltaK;
            } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
              pointCurrent.mK = 0;
            } else {
              pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
            }
          }
          var alphaK, betaK, tauK, squaredMagnitude;
          for (i2 = 0; i2 < pointsLen - 1; ++i2) {
            pointCurrent = pointsWithTangents[i2];
            pointAfter = pointsWithTangents[i2 + 1];
            if (pointCurrent.model.skip || pointAfter.model.skip) {
              continue;
            }
            if (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
              pointCurrent.mK = pointAfter.mK = 0;
              continue;
            }
            alphaK = pointCurrent.mK / pointCurrent.deltaK;
            betaK = pointAfter.mK / pointCurrent.deltaK;
            squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
            if (squaredMagnitude <= 9) {
              continue;
            }
            tauK = 3 / Math.sqrt(squaredMagnitude);
            pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
            pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
          }
          var deltaX;
          for (i2 = 0; i2 < pointsLen; ++i2) {
            pointCurrent = pointsWithTangents[i2];
            if (pointCurrent.model.skip) {
              continue;
            }
            pointBefore = i2 > 0 ? pointsWithTangents[i2 - 1] : null;
            pointAfter = i2 < pointsLen - 1 ? pointsWithTangents[i2 + 1] : null;
            if (pointBefore && !pointBefore.model.skip) {
              deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
              pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
              pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
            }
            if (pointAfter && !pointAfter.model.skip) {
              deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
              pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
              pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
            }
          }
        };
        helpers.nextItem = function(collection, index, loop2) {
          if (loop2) {
            return index >= collection.length - 1 ? collection[0] : collection[index + 1];
          }
          return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
        };
        helpers.previousItem = function(collection, index, loop2) {
          if (loop2) {
            return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
          }
          return index <= 0 ? collection[0] : collection[index - 1];
        };
        helpers.niceNum = function(range, round) {
          var exponent = Math.floor(helpers.log10(range));
          var fraction = range / Math.pow(10, exponent);
          var niceFraction;
          if (round) {
            if (fraction < 1.5) {
              niceFraction = 1;
            } else if (fraction < 3) {
              niceFraction = 2;
            } else if (fraction < 7) {
              niceFraction = 5;
            } else {
              niceFraction = 10;
            }
          } else if (fraction <= 1) {
            niceFraction = 1;
          } else if (fraction <= 2) {
            niceFraction = 2;
          } else if (fraction <= 5) {
            niceFraction = 5;
          } else {
            niceFraction = 10;
          }
          return niceFraction * Math.pow(10, exponent);
        };
        var easingEffects = helpers.easingEffects = {
          linear: function(t2) {
            return t2;
          },
          easeInQuad: function(t2) {
            return t2 * t2;
          },
          easeOutQuad: function(t2) {
            return -1 * t2 * (t2 - 2);
          },
          easeInOutQuad: function(t2) {
            if ((t2 /= 1 / 2) < 1) {
              return 1 / 2 * t2 * t2;
            }
            return -1 / 2 * (--t2 * (t2 - 2) - 1);
          },
          easeInCubic: function(t2) {
            return t2 * t2 * t2;
          },
          easeOutCubic: function(t2) {
            return 1 * ((t2 = t2 / 1 - 1) * t2 * t2 + 1);
          },
          easeInOutCubic: function(t2) {
            if ((t2 /= 1 / 2) < 1) {
              return 1 / 2 * t2 * t2 * t2;
            }
            return 1 / 2 * ((t2 -= 2) * t2 * t2 + 2);
          },
          easeInQuart: function(t2) {
            return t2 * t2 * t2 * t2;
          },
          easeOutQuart: function(t2) {
            return -1 * ((t2 = t2 / 1 - 1) * t2 * t2 * t2 - 1);
          },
          easeInOutQuart: function(t2) {
            if ((t2 /= 1 / 2) < 1) {
              return 1 / 2 * t2 * t2 * t2 * t2;
            }
            return -1 / 2 * ((t2 -= 2) * t2 * t2 * t2 - 2);
          },
          easeInQuint: function(t2) {
            return 1 * (t2 /= 1) * t2 * t2 * t2 * t2;
          },
          easeOutQuint: function(t2) {
            return 1 * ((t2 = t2 / 1 - 1) * t2 * t2 * t2 * t2 + 1);
          },
          easeInOutQuint: function(t2) {
            if ((t2 /= 1 / 2) < 1) {
              return 1 / 2 * t2 * t2 * t2 * t2 * t2;
            }
            return 1 / 2 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2);
          },
          easeInSine: function(t2) {
            return -1 * Math.cos(t2 / 1 * (Math.PI / 2)) + 1;
          },
          easeOutSine: function(t2) {
            return 1 * Math.sin(t2 / 1 * (Math.PI / 2));
          },
          easeInOutSine: function(t2) {
            return -1 / 2 * (Math.cos(Math.PI * t2 / 1) - 1);
          },
          easeInExpo: function(t2) {
            return t2 === 0 ? 1 : 1 * Math.pow(2, 10 * (t2 / 1 - 1));
          },
          easeOutExpo: function(t2) {
            return t2 === 1 ? 1 : 1 * (-Math.pow(2, -10 * t2 / 1) + 1);
          },
          easeInOutExpo: function(t2) {
            if (t2 === 0) {
              return 0;
            }
            if (t2 === 1) {
              return 1;
            }
            if ((t2 /= 1 / 2) < 1) {
              return 1 / 2 * Math.pow(2, 10 * (t2 - 1));
            }
            return 1 / 2 * (-Math.pow(2, -10 * --t2) + 2);
          },
          easeInCirc: function(t2) {
            if (t2 >= 1) {
              return t2;
            }
            return -1 * (Math.sqrt(1 - (t2 /= 1) * t2) - 1);
          },
          easeOutCirc: function(t2) {
            return 1 * Math.sqrt(1 - (t2 = t2 / 1 - 1) * t2);
          },
          easeInOutCirc: function(t2) {
            if ((t2 /= 1 / 2) < 1) {
              return -1 / 2 * (Math.sqrt(1 - t2 * t2) - 1);
            }
            return 1 / 2 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1);
          },
          easeInElastic: function(t2) {
            var s2 = 1.70158;
            var p = 0;
            var a = 1;
            if (t2 === 0) {
              return 0;
            }
            if ((t2 /= 1) === 1) {
              return 1;
            }
            if (!p) {
              p = 1 * 0.3;
            }
            if (a < Math.abs(1)) {
              a = 1;
              s2 = p / 4;
            } else {
              s2 = p / (2 * Math.PI) * Math.asin(1 / a);
            }
            return -(a * Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 * 1 - s2) * (2 * Math.PI) / p));
          },
          easeOutElastic: function(t2) {
            var s2 = 1.70158;
            var p = 0;
            var a = 1;
            if (t2 === 0) {
              return 0;
            }
            if ((t2 /= 1) === 1) {
              return 1;
            }
            if (!p) {
              p = 1 * 0.3;
            }
            if (a < Math.abs(1)) {
              a = 1;
              s2 = p / 4;
            } else {
              s2 = p / (2 * Math.PI) * Math.asin(1 / a);
            }
            return a * Math.pow(2, -10 * t2) * Math.sin((t2 * 1 - s2) * (2 * Math.PI) / p) + 1;
          },
          easeInOutElastic: function(t2) {
            var s2 = 1.70158;
            var p = 0;
            var a = 1;
            if (t2 === 0) {
              return 0;
            }
            if ((t2 /= 1 / 2) === 2) {
              return 1;
            }
            if (!p) {
              p = 1 * (0.3 * 1.5);
            }
            if (a < Math.abs(1)) {
              a = 1;
              s2 = p / 4;
            } else {
              s2 = p / (2 * Math.PI) * Math.asin(1 / a);
            }
            if (t2 < 1) {
              return -0.5 * (a * Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 * 1 - s2) * (2 * Math.PI) / p));
            }
            return a * Math.pow(2, -10 * (t2 -= 1)) * Math.sin((t2 * 1 - s2) * (2 * Math.PI) / p) * 0.5 + 1;
          },
          easeInBack: function(t2) {
            var s2 = 1.70158;
            return 1 * (t2 /= 1) * t2 * ((s2 + 1) * t2 - s2);
          },
          easeOutBack: function(t2) {
            var s2 = 1.70158;
            return 1 * ((t2 = t2 / 1 - 1) * t2 * ((s2 + 1) * t2 + s2) + 1);
          },
          easeInOutBack: function(t2) {
            var s2 = 1.70158;
            if ((t2 /= 1 / 2) < 1) {
              return 1 / 2 * (t2 * t2 * (((s2 *= 1.525) + 1) * t2 - s2));
            }
            return 1 / 2 * ((t2 -= 2) * t2 * (((s2 *= 1.525) + 1) * t2 + s2) + 2);
          },
          easeInBounce: function(t2) {
            return 1 - easingEffects.easeOutBounce(1 - t2);
          },
          easeOutBounce: function(t2) {
            if ((t2 /= 1) < 1 / 2.75) {
              return 1 * (7.5625 * t2 * t2);
            } else if (t2 < 2 / 2.75) {
              return 1 * (7.5625 * (t2 -= 1.5 / 2.75) * t2 + 0.75);
            } else if (t2 < 2.5 / 2.75) {
              return 1 * (7.5625 * (t2 -= 2.25 / 2.75) * t2 + 0.9375);
            }
            return 1 * (7.5625 * (t2 -= 2.625 / 2.75) * t2 + 0.984375);
          },
          easeInOutBounce: function(t2) {
            if (t2 < 1 / 2) {
              return easingEffects.easeInBounce(t2 * 2) * 0.5;
            }
            return easingEffects.easeOutBounce(t2 * 2 - 1) * 0.5 + 1 * 0.5;
          }
        };
        helpers.requestAnimFrame = function() {
          if (typeof window === "undefined") {
            return function(callback) {
              callback();
            };
          }
          return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
            return window.setTimeout(callback, 1e3 / 60);
          };
        }();
        helpers.getRelativePosition = function(evt, chart) {
          var mouseX, mouseY;
          var e2 = evt.originalEvent || evt, canvas = evt.currentTarget || evt.srcElement, boundingRect = canvas.getBoundingClientRect();
          var touches = e2.touches;
          if (touches && touches.length > 0) {
            mouseX = touches[0].clientX;
            mouseY = touches[0].clientY;
          } else {
            mouseX = e2.clientX;
            mouseY = e2.clientY;
          }
          var paddingLeft = parseFloat(helpers.getStyle(canvas, "padding-left"));
          var paddingTop = parseFloat(helpers.getStyle(canvas, "padding-top"));
          var paddingRight = parseFloat(helpers.getStyle(canvas, "padding-right"));
          var paddingBottom = parseFloat(helpers.getStyle(canvas, "padding-bottom"));
          var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
          var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;
          mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas.width / chart.currentDevicePixelRatio);
          mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas.height / chart.currentDevicePixelRatio);
          return {
            x: mouseX,
            y: mouseY
          };
        };
        helpers.addEvent = function(node, eventType, method) {
          if (node.addEventListener) {
            node.addEventListener(eventType, method);
          } else if (node.attachEvent) {
            node.attachEvent("on" + eventType, method);
          } else {
            node["on" + eventType] = method;
          }
        };
        helpers.removeEvent = function(node, eventType, handler) {
          if (node.removeEventListener) {
            node.removeEventListener(eventType, handler, false);
          } else if (node.detachEvent) {
            node.detachEvent("on" + eventType, handler);
          } else {
            node["on" + eventType] = helpers.noop;
          }
        };
        function parseMaxStyle(styleValue, node, parentProperty) {
          var valueInPixels;
          if (typeof styleValue === "string") {
            valueInPixels = parseInt(styleValue, 10);
            if (styleValue.indexOf("%") !== -1) {
              valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
            }
          } else {
            valueInPixels = styleValue;
          }
          return valueInPixels;
        }
        function isConstrainedValue(value) {
          return value !== void 0 && value !== null && value !== "none";
        }
        function getConstraintDimension(domNode, maxStyle, percentageProperty) {
          var view = document.defaultView;
          var parentNode = domNode.parentNode;
          var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
          var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
          var hasCNode = isConstrainedValue(constrainedNode);
          var hasCContainer = isConstrainedValue(constrainedContainer);
          var infinity = Number.POSITIVE_INFINITY;
          if (hasCNode || hasCContainer) {
            return Math.min(
              hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,
              hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity
            );
          }
          return "none";
        }
        helpers.getConstraintWidth = function(domNode) {
          return getConstraintDimension(domNode, "max-width", "clientWidth");
        };
        helpers.getConstraintHeight = function(domNode) {
          return getConstraintDimension(domNode, "max-height", "clientHeight");
        };
        helpers.getMaximumWidth = function(domNode) {
          var container = domNode.parentNode;
          var paddingLeft = parseInt(helpers.getStyle(container, "padding-left"), 10);
          var paddingRight = parseInt(helpers.getStyle(container, "padding-right"), 10);
          var w = container.clientWidth - paddingLeft - paddingRight;
          var cw = helpers.getConstraintWidth(domNode);
          return isNaN(cw) ? w : Math.min(w, cw);
        };
        helpers.getMaximumHeight = function(domNode) {
          var container = domNode.parentNode;
          var paddingTop = parseInt(helpers.getStyle(container, "padding-top"), 10);
          var paddingBottom = parseInt(helpers.getStyle(container, "padding-bottom"), 10);
          var h = container.clientHeight - paddingTop - paddingBottom;
          var ch = helpers.getConstraintHeight(domNode);
          return isNaN(ch) ? h : Math.min(h, ch);
        };
        helpers.getStyle = function(el, property) {
          return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
        };
        helpers.retinaScale = function(chart) {
          var pixelRatio = chart.currentDevicePixelRatio = window.devicePixelRatio || 1;
          if (pixelRatio === 1) {
            return;
          }
          var canvas = chart.canvas;
          var height = chart.height;
          var width = chart.width;
          canvas.height = height * pixelRatio;
          canvas.width = width * pixelRatio;
          chart.ctx.scale(pixelRatio, pixelRatio);
          canvas.style.height = height + "px";
          canvas.style.width = width + "px";
        };
        helpers.clear = function(chart) {
          chart.ctx.clearRect(0, 0, chart.width, chart.height);
        };
        helpers.fontString = function(pixelSize, fontStyle, fontFamily) {
          return fontStyle + " " + pixelSize + "px " + fontFamily;
        };
        helpers.longestText = function(ctx, font, arrayOfThings, cache) {
          cache = cache || {};
          var data = cache.data = cache.data || {};
          var gc = cache.garbageCollect = cache.garbageCollect || [];
          if (cache.font !== font) {
            data = cache.data = {};
            gc = cache.garbageCollect = [];
            cache.font = font;
          }
          ctx.font = font;
          var longest = 0;
          helpers.each(arrayOfThings, function(thing) {
            if (thing !== void 0 && thing !== null && helpers.isArray(thing) !== true) {
              longest = helpers.measureText(ctx, data, gc, longest, thing);
            } else if (helpers.isArray(thing)) {
              helpers.each(thing, function(nestedThing) {
                if (nestedThing !== void 0 && nestedThing !== null && !helpers.isArray(nestedThing)) {
                  longest = helpers.measureText(ctx, data, gc, longest, nestedThing);
                }
              });
            }
          });
          var gcLen = gc.length / 2;
          if (gcLen > arrayOfThings.length) {
            for (var i2 = 0; i2 < gcLen; i2++) {
              delete data[gc[i2]];
            }
            gc.splice(0, gcLen);
          }
          return longest;
        };
        helpers.measureText = function(ctx, data, gc, longest, string) {
          var textWidth = data[string];
          if (!textWidth) {
            textWidth = data[string] = ctx.measureText(string).width;
            gc.push(string);
          }
          if (textWidth > longest) {
            longest = textWidth;
          }
          return longest;
        };
        helpers.numberOfLabelLines = function(arrayOfThings) {
          var numberOfLines = 1;
          helpers.each(arrayOfThings, function(thing) {
            if (helpers.isArray(thing)) {
              if (thing.length > numberOfLines) {
                numberOfLines = thing.length;
              }
            }
          });
          return numberOfLines;
        };
        helpers.drawRoundedRectangle = function(ctx, x, y, width, height, radius) {
          ctx.beginPath();
          ctx.moveTo(x + radius, y);
          ctx.lineTo(x + width - radius, y);
          ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
          ctx.lineTo(x + width, y + height - radius);
          ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
          ctx.lineTo(x + radius, y + height);
          ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
          ctx.lineTo(x, y + radius);
          ctx.quadraticCurveTo(x, y, x + radius, y);
          ctx.closePath();
        };
        helpers.color = !color ? function(value) {
          console.error("Color.js not found!");
          return value;
        } : function(value) {
          if (value instanceof CanvasGradient) {
            value = Chart2.defaults.global.defaultColor;
          }
          return color(value);
        };
        helpers.isArray = Array.isArray ? function(obj) {
          return Array.isArray(obj);
        } : function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
        helpers.arrayEquals = function(a0, a1) {
          var i2, ilen, v0, v1;
          if (!a0 || !a1 || a0.length !== a1.length) {
            return false;
          }
          for (i2 = 0, ilen = a0.length; i2 < ilen; ++i2) {
            v0 = a0[i2];
            v1 = a1[i2];
            if (v0 instanceof Array && v1 instanceof Array) {
              if (!helpers.arrayEquals(v0, v1)) {
                return false;
              }
            } else if (v0 !== v1) {
              return false;
            }
          }
          return true;
        };
        helpers.callback = function(fn, args, thisArg) {
          if (fn && typeof fn.call === "function") {
            fn.apply(thisArg, args);
          }
        };
        helpers.getHoverColor = function(colorValue) {
          return colorValue instanceof CanvasPattern ? colorValue : helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();
        };
        helpers.callCallback = helpers.callback;
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/platforms/platform.dom.js
  var require_platform_dom = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/platforms/platform.dom.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        var eventTypeMap = {
          // Touch events
          touchstart: "mousedown",
          touchmove: "mousemove",
          touchend: "mouseup",
          // Pointer events
          pointerenter: "mouseenter",
          pointerdown: "mousedown",
          pointermove: "mousemove",
          pointerup: "mouseup",
          pointerleave: "mouseout",
          pointerout: "mouseout"
        };
        function readUsedSize(element2, property) {
          var value = helpers.getStyle(element2, property);
          var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
          return matches ? Number(matches[1]) : void 0;
        }
        function initCanvas(canvas, config) {
          var style = canvas.style;
          var renderHeight = canvas.getAttribute("height");
          var renderWidth = canvas.getAttribute("width");
          canvas._chartjs = {
            initial: {
              height: renderHeight,
              width: renderWidth,
              style: {
                display: style.display,
                height: style.height,
                width: style.width
              }
            }
          };
          style.display = style.display || "block";
          if (renderWidth === null || renderWidth === "") {
            var displayWidth = readUsedSize(canvas, "width");
            if (displayWidth !== void 0) {
              canvas.width = displayWidth;
            }
          }
          if (renderHeight === null || renderHeight === "") {
            if (canvas.style.height === "") {
              canvas.height = canvas.width / (config.options.aspectRatio || 2);
            } else {
              var displayHeight = readUsedSize(canvas, "height");
              if (displayWidth !== void 0) {
                canvas.height = displayHeight;
              }
            }
          }
          return canvas;
        }
        function createEvent(type, chart, x, y, nativeEvent) {
          return {
            type,
            chart,
            native: nativeEvent || null,
            x: x !== void 0 ? x : null,
            y: y !== void 0 ? y : null
          };
        }
        function fromNativeEvent(event, chart) {
          var type = eventTypeMap[event.type] || event.type;
          var pos = helpers.getRelativePosition(event, chart);
          return createEvent(type, chart, pos.x, pos.y, event);
        }
        function createResizer(handler) {
          var iframe = document.createElement("iframe");
          iframe.className = "chartjs-hidden-iframe";
          iframe.style.cssText = "display:block;overflow:hidden;border:0;margin:0;top:0;left:0;bottom:0;right:0;height:100%;width:100%;position:absolute;pointer-events:none;z-index:-1;";
          iframe.tabIndex = -1;
          helpers.addEvent(iframe, "load", function() {
            helpers.addEvent(iframe.contentWindow || iframe, "resize", handler);
            handler();
          });
          return iframe;
        }
        function addResizeListener(node, listener, chart) {
          var stub = node._chartjs = {
            ticking: false
          };
          var notify = function() {
            if (!stub.ticking) {
              stub.ticking = true;
              helpers.requestAnimFrame.call(window, function() {
                if (stub.resizer) {
                  stub.ticking = false;
                  return listener(createEvent("resize", chart));
                }
              });
            }
          };
          stub.resizer = createResizer(notify);
          node.insertBefore(stub.resizer, node.firstChild);
        }
        function removeResizeListener(node) {
          if (!node || !node._chartjs) {
            return;
          }
          var resizer = node._chartjs.resizer;
          if (resizer) {
            resizer.parentNode.removeChild(resizer);
            node._chartjs.resizer = null;
          }
          delete node._chartjs;
        }
        return {
          acquireContext: function(item, config) {
            if (typeof item === "string") {
              item = document.getElementById(item);
            } else if (item.length) {
              item = item[0];
            }
            if (item && item.canvas) {
              item = item.canvas;
            }
            var context = item && item.getContext && item.getContext("2d");
            if (context && context.canvas === item) {
              initCanvas(item, config);
              return context;
            }
            return null;
          },
          releaseContext: function(context) {
            var canvas = context.canvas;
            if (!canvas._chartjs) {
              return;
            }
            var initial = canvas._chartjs.initial;
            ["height", "width"].forEach(function(prop) {
              var value = initial[prop];
              if (value === void 0 || value === null) {
                canvas.removeAttribute(prop);
              } else {
                canvas.setAttribute(prop, value);
              }
            });
            helpers.each(initial.style || {}, function(value, key) {
              canvas.style[key] = value;
            });
            canvas.width = canvas.width;
            delete canvas._chartjs;
          },
          addEventListener: function(chart, type, listener) {
            var canvas = chart.canvas;
            if (type === "resize") {
              addResizeListener(canvas.parentNode, listener, chart);
              return;
            }
            var stub = listener._chartjs || (listener._chartjs = {});
            var proxies = stub.proxies || (stub.proxies = {});
            var proxy = proxies[chart.id + "_" + type] = function(event) {
              listener(fromNativeEvent(event, chart));
            };
            helpers.addEvent(canvas, type, proxy);
          },
          removeEventListener: function(chart, type, listener) {
            var canvas = chart.canvas;
            if (type === "resize") {
              removeResizeListener(canvas.parentNode, listener);
              return;
            }
            var stub = listener._chartjs || {};
            var proxies = stub.proxies || {};
            var proxy = proxies[chart.id + "_" + type];
            if (!proxy) {
              return;
            }
            helpers.removeEvent(canvas, type, proxy);
          }
        };
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/platforms/platform.js
  var require_platform = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/platforms/platform.js"(exports, module) {
      "use strict";
      var implementation = require_platform_dom();
      module.exports = function(Chart2) {
        Chart2.platform = {
          /**
           * Called at chart construction time, returns a context2d instance implementing
           * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
           * @param {*} item - The native item from which to acquire context (platform specific)
           * @param {Object} options - The chart options
           * @returns {CanvasRenderingContext2D} context2d instance
           */
          acquireContext: function() {
          },
          /**
           * Called at chart destruction time, releases any resources associated to the context
           * previously returned by the acquireContext() method.
           * @param {CanvasRenderingContext2D} context - The context2d instance
           * @returns {Boolean} true if the method succeeded, else false
           */
          releaseContext: function() {
          },
          /**
           * Registers the specified listener on the given chart.
           * @param {Chart} chart - Chart from which to listen for event
           * @param {String} type - The ({@link IEvent}) type to listen for
           * @param {Function} listener - Receives a notification (an object that implements
           * the {@link IEvent} interface) when an event of the specified type occurs.
           */
          addEventListener: function() {
          },
          /**
           * Removes the specified listener previously registered with addEventListener.
           * @param {Chart} chart -Chart from which to remove the listener
           * @param {String} type - The ({@link IEvent}) type to remove
           * @param {Function} listener - The listener function to remove from the event target.
           */
          removeEventListener: function() {
          }
        };
        Chart2.helpers.extend(Chart2.platform, implementation(Chart2));
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.canvasHelpers.js
  var require_core_canvasHelpers = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.canvasHelpers.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.canvasHelpers = {};
        helpers.drawPoint = function(ctx, pointStyle, radius, x, y) {
          var type, edgeLength, xOffset, yOffset, height, size;
          if (typeof pointStyle === "object") {
            type = pointStyle.toString();
            if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
              ctx.drawImage(pointStyle, x - pointStyle.width / 2, y - pointStyle.height / 2, pointStyle.width, pointStyle.height);
              return;
            }
          }
          if (isNaN(radius) || radius <= 0) {
            return;
          }
          switch (pointStyle) {
            default:
              ctx.beginPath();
              ctx.arc(x, y, radius, 0, Math.PI * 2);
              ctx.closePath();
              ctx.fill();
              break;
            case "triangle":
              ctx.beginPath();
              edgeLength = 3 * radius / Math.sqrt(3);
              height = edgeLength * Math.sqrt(3) / 2;
              ctx.moveTo(x - edgeLength / 2, y + height / 3);
              ctx.lineTo(x + edgeLength / 2, y + height / 3);
              ctx.lineTo(x, y - 2 * height / 3);
              ctx.closePath();
              ctx.fill();
              break;
            case "rect":
              size = 1 / Math.SQRT2 * radius;
              ctx.beginPath();
              ctx.fillRect(x - size, y - size, 2 * size, 2 * size);
              ctx.strokeRect(x - size, y - size, 2 * size, 2 * size);
              break;
            case "rectRounded":
              var offset = radius / Math.SQRT2;
              var leftX = x - offset;
              var topY = y - offset;
              var sideSize = Math.SQRT2 * radius;
              Chart2.helpers.drawRoundedRectangle(ctx, leftX, topY, sideSize, sideSize, radius / 2);
              ctx.fill();
              break;
            case "rectRot":
              size = 1 / Math.SQRT2 * radius;
              ctx.beginPath();
              ctx.moveTo(x - size, y);
              ctx.lineTo(x, y + size);
              ctx.lineTo(x + size, y);
              ctx.lineTo(x, y - size);
              ctx.closePath();
              ctx.fill();
              break;
            case "cross":
              ctx.beginPath();
              ctx.moveTo(x, y + radius);
              ctx.lineTo(x, y - radius);
              ctx.moveTo(x - radius, y);
              ctx.lineTo(x + radius, y);
              ctx.closePath();
              break;
            case "crossRot":
              ctx.beginPath();
              xOffset = Math.cos(Math.PI / 4) * radius;
              yOffset = Math.sin(Math.PI / 4) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              ctx.moveTo(x - xOffset, y + yOffset);
              ctx.lineTo(x + xOffset, y - yOffset);
              ctx.closePath();
              break;
            case "star":
              ctx.beginPath();
              ctx.moveTo(x, y + radius);
              ctx.lineTo(x, y - radius);
              ctx.moveTo(x - radius, y);
              ctx.lineTo(x + radius, y);
              xOffset = Math.cos(Math.PI / 4) * radius;
              yOffset = Math.sin(Math.PI / 4) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              ctx.moveTo(x - xOffset, y + yOffset);
              ctx.lineTo(x + xOffset, y - yOffset);
              ctx.closePath();
              break;
            case "line":
              ctx.beginPath();
              ctx.moveTo(x - radius, y);
              ctx.lineTo(x + radius, y);
              ctx.closePath();
              break;
            case "dash":
              ctx.beginPath();
              ctx.moveTo(x, y);
              ctx.lineTo(x + radius, y);
              ctx.closePath();
              break;
          }
          ctx.stroke();
        };
        helpers.clipArea = function(ctx, clipArea) {
          ctx.save();
          ctx.beginPath();
          ctx.rect(clipArea.left, clipArea.top, clipArea.right - clipArea.left, clipArea.bottom - clipArea.top);
          ctx.clip();
        };
        helpers.unclipArea = function(ctx) {
          ctx.restore();
        };
        helpers.lineTo = function(ctx, previous, target, flip) {
          if (target.steppedLine) {
            if (target.steppedLine === "after") {
              ctx.lineTo(previous.x, target.y);
            } else {
              ctx.lineTo(target.x, previous.y);
            }
            ctx.lineTo(target.x, target.y);
            return;
          }
          if (!target.tension) {
            ctx.lineTo(target.x, target.y);
            return;
          }
          ctx.bezierCurveTo(
            flip ? previous.controlPointPreviousX : previous.controlPointNextX,
            flip ? previous.controlPointPreviousY : previous.controlPointNextY,
            flip ? target.controlPointNextX : target.controlPointPreviousX,
            flip ? target.controlPointNextY : target.controlPointPreviousY,
            target.x,
            target.y
          );
        };
        Chart2.helpers.canvas = helpers;
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.element.js
  var require_core_element = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.element.js"(exports, module) {
      "use strict";
      var color = require_chartjs_color();
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        function interpolate(start, view, model, ease) {
          var keys = Object.keys(model);
          var i2, ilen, key, actual, origin, target, type, c0, c1;
          for (i2 = 0, ilen = keys.length; i2 < ilen; ++i2) {
            key = keys[i2];
            target = model[key];
            if (!view.hasOwnProperty(key)) {
              view[key] = target;
            }
            actual = view[key];
            if (actual === target || key[0] === "_") {
              continue;
            }
            if (!start.hasOwnProperty(key)) {
              start[key] = actual;
            }
            origin = start[key];
            type = typeof target;
            if (type === typeof origin) {
              if (type === "string") {
                c0 = color(origin);
                if (c0.valid) {
                  c1 = color(target);
                  if (c1.valid) {
                    view[key] = c1.mix(c0, ease).rgbString();
                    continue;
                  }
                }
              } else if (type === "number" && isFinite(origin) && isFinite(target)) {
                view[key] = origin + (target - origin) * ease;
                continue;
              }
            }
            view[key] = target;
          }
        }
        Chart2.elements = {};
        Chart2.Element = function(configuration) {
          helpers.extend(this, configuration);
          this.initialize.apply(this, arguments);
        };
        helpers.extend(Chart2.Element.prototype, {
          initialize: function() {
            this.hidden = false;
          },
          pivot: function() {
            var me = this;
            if (!me._view) {
              me._view = helpers.clone(me._model);
            }
            me._start = {};
            return me;
          },
          transition: function(ease) {
            var me = this;
            var model = me._model;
            var start = me._start;
            var view = me._view;
            if (!model || ease === 1) {
              me._view = model;
              me._start = null;
              return me;
            }
            if (!view) {
              view = me._view = {};
            }
            if (!start) {
              start = me._start = {};
            }
            interpolate(start, view, model, ease);
            return me;
          },
          tooltipPosition: function() {
            return {
              x: this._model.x,
              y: this._model.y
            };
          },
          hasValue: function() {
            return helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);
          }
        });
        Chart2.Element.extend = helpers.inherits;
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.plugin.js
  var require_core_plugin = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.plugin.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        Chart2.defaults.global.plugins = {};
        Chart2.plugins = {
          /**
           * Globally registered plugins.
           * @private
           */
          _plugins: [],
          /**
           * This identifier is used to invalidate the descriptors cache attached to each chart
           * when a global plugin is registered or unregistered. In this case, the cache ID is
           * incremented and descriptors are regenerated during following API calls.
           * @private
           */
          _cacheId: 0,
          /**
           * Registers the given plugin(s) if not already registered.
           * @param {Array|Object} plugins plugin instance(s).
           */
          register: function(plugins) {
            var p = this._plugins;
            [].concat(plugins).forEach(function(plugin) {
              if (p.indexOf(plugin) === -1) {
                p.push(plugin);
              }
            });
            this._cacheId++;
          },
          /**
           * Unregisters the given plugin(s) only if registered.
           * @param {Array|Object} plugins plugin instance(s).
           */
          unregister: function(plugins) {
            var p = this._plugins;
            [].concat(plugins).forEach(function(plugin) {
              var idx = p.indexOf(plugin);
              if (idx !== -1) {
                p.splice(idx, 1);
              }
            });
            this._cacheId++;
          },
          /**
           * Remove all registered plugins.
           * @since 2.1.5
           */
          clear: function() {
            this._plugins = [];
            this._cacheId++;
          },
          /**
           * Returns the number of registered plugins?
           * @returns {Number}
           * @since 2.1.5
           */
          count: function() {
            return this._plugins.length;
          },
          /**
           * Returns all registered plugin instances.
           * @returns {Array} array of plugin objects.
           * @since 2.1.5
           */
          getAll: function() {
            return this._plugins;
          },
          /**
           * Calls enabled plugins for `chart` on the specified hook and with the given args.
           * This method immediately returns as soon as a plugin explicitly returns false. The
           * returned value can be used, for instance, to interrupt the current action.
           * @param {Object} chart - The chart instance for which plugins should be called.
           * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
           * @param {Array} [args] - Extra arguments to apply to the hook call.
           * @returns {Boolean} false if any of the plugins return false, else returns true.
           */
          notify: function(chart, hook, args) {
            var descriptors = this.descriptors(chart);
            var ilen = descriptors.length;
            var i2, descriptor, plugin, params, method;
            for (i2 = 0; i2 < ilen; ++i2) {
              descriptor = descriptors[i2];
              plugin = descriptor.plugin;
              method = plugin[hook];
              if (typeof method === "function") {
                params = [chart].concat(args || []);
                params.push(descriptor.options);
                if (method.apply(plugin, params) === false) {
                  return false;
                }
              }
            }
            return true;
          },
          /**
           * Returns descriptors of enabled plugins for the given chart.
           * @returns {Array} [{ plugin, options }]
           * @private
           */
          descriptors: function(chart) {
            var cache = chart._plugins || (chart._plugins = {});
            if (cache.id === this._cacheId) {
              return cache.descriptors;
            }
            var plugins = [];
            var descriptors = [];
            var config = chart && chart.config || {};
            var defaults = Chart2.defaults.global.plugins;
            var options = config.options && config.options.plugins || {};
            this._plugins.concat(config.plugins || []).forEach(function(plugin) {
              var idx = plugins.indexOf(plugin);
              if (idx !== -1) {
                return;
              }
              var id = plugin.id;
              var opts = options[id];
              if (opts === false) {
                return;
              }
              if (opts === true) {
                opts = helpers.clone(defaults[id]);
              }
              plugins.push(plugin);
              descriptors.push({
                plugin,
                options: opts || {}
              });
            });
            cache.descriptors = descriptors;
            cache.id = this._cacheId;
            return descriptors;
          }
        };
        Chart2.pluginService = Chart2.plugins;
        Chart2.PluginBase = Chart2.Element.extend({});
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.animation.js
  var require_core_animation = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.animation.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        Chart2.defaults.global.animation = {
          duration: 1e3,
          easing: "easeOutQuart",
          onProgress: helpers.noop,
          onComplete: helpers.noop
        };
        Chart2.Animation = Chart2.Element.extend({
          chart: null,
          // the animation associated chart instance
          currentStep: 0,
          // the current animation step
          numSteps: 60,
          // default number of steps
          easing: "",
          // the easing to use for this animation
          render: null,
          // render function used by the animation service
          onAnimationProgress: null,
          // user specified callback to fire on each step of the animation
          onAnimationComplete: null
          // user specified callback to fire when the animation finishes
        });
        Chart2.animationService = {
          frameDuration: 17,
          animations: [],
          dropFrames: 0,
          request: null,
          /**
           * @param {Chart} chart - The chart to animate.
           * @param {Chart.Animation} animation - The animation that we will animate.
           * @param {Number} duration - The animation duration in ms.
           * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
           */
          addAnimation: function(chart, animation, duration, lazy) {
            var animations = this.animations;
            var i2, ilen;
            animation.chart = chart;
            if (!lazy) {
              chart.animating = true;
            }
            for (i2 = 0, ilen = animations.length; i2 < ilen; ++i2) {
              if (animations[i2].chart === chart) {
                animations[i2] = animation;
                return;
              }
            }
            animations.push(animation);
            if (animations.length === 1) {
              this.requestAnimationFrame();
            }
          },
          cancelAnimation: function(chart) {
            var index = helpers.findIndex(this.animations, function(animation) {
              return animation.chart === chart;
            });
            if (index !== -1) {
              this.animations.splice(index, 1);
              chart.animating = false;
            }
          },
          requestAnimationFrame: function() {
            var me = this;
            if (me.request === null) {
              me.request = helpers.requestAnimFrame.call(window, function() {
                me.request = null;
                me.startDigest();
              });
            }
          },
          /**
           * @private
           */
          startDigest: function() {
            var me = this;
            var startTime = Date.now();
            var framesToDrop = 0;
            if (me.dropFrames > 1) {
              framesToDrop = Math.floor(me.dropFrames);
              me.dropFrames = me.dropFrames % 1;
            }
            me.advance(1 + framesToDrop);
            var endTime = Date.now();
            me.dropFrames += (endTime - startTime) / me.frameDuration;
            if (me.animations.length > 0) {
              me.requestAnimationFrame();
            }
          },
          /**
           * @private
           */
          advance: function(count) {
            var animations = this.animations;
            var animation, chart;
            var i2 = 0;
            while (i2 < animations.length) {
              animation = animations[i2];
              chart = animation.chart;
              animation.currentStep = (animation.currentStep || 0) + count;
              animation.currentStep = Math.min(animation.currentStep, animation.numSteps);
              helpers.callback(animation.render, [chart, animation], chart);
              helpers.callback(animation.onAnimationProgress, [animation], chart);
              if (animation.currentStep >= animation.numSteps) {
                helpers.callback(animation.onAnimationComplete, [animation], chart);
                chart.animating = false;
                animations.splice(i2, 1);
              } else {
                ++i2;
              }
            }
          }
        };
        Object.defineProperty(Chart2.Animation.prototype, "animationObject", {
          get: function() {
            return this;
          }
        });
        Object.defineProperty(Chart2.Animation.prototype, "chartInstance", {
          get: function() {
            return this.chart;
          },
          set: function(value) {
            this.chart = value;
          }
        });
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.controller.js
  var require_core_controller = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.controller.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        var plugins = Chart2.plugins;
        var platform = Chart2.platform;
        Chart2.types = {};
        Chart2.instances = {};
        Chart2.controllers = {};
        function initConfig(config) {
          config = config || {};
          var data = config.data = config.data || {};
          data.datasets = data.datasets || [];
          data.labels = data.labels || [];
          config.options = helpers.configMerge(
            Chart2.defaults.global,
            Chart2.defaults[config.type],
            config.options || {}
          );
          return config;
        }
        function updateConfig(chart) {
          var newOptions = chart.options;
          if (newOptions.scale) {
            chart.scale.options = newOptions.scale;
          } else if (newOptions.scales) {
            newOptions.scales.xAxes.concat(newOptions.scales.yAxes).forEach(function(scaleOptions) {
              chart.scales[scaleOptions.id].options = scaleOptions;
            });
          }
          chart.tooltip._options = newOptions.tooltips;
        }
        function positionIsHorizontal(position) {
          return position === "top" || position === "bottom";
        }
        helpers.extend(
          Chart2.prototype,
          /** @lends Chart */
          {
            /**
             * @private
             */
            construct: function(item, config) {
              var me = this;
              config = initConfig(config);
              var context = platform.acquireContext(item, config);
              var canvas = context && context.canvas;
              var height = canvas && canvas.height;
              var width = canvas && canvas.width;
              me.id = helpers.uid();
              me.ctx = context;
              me.canvas = canvas;
              me.config = config;
              me.width = width;
              me.height = height;
              me.aspectRatio = height ? width / height : null;
              me.options = config.options;
              me._bufferedRender = false;
              me.chart = me;
              me.controller = me;
              Chart2.instances[me.id] = me;
              Object.defineProperty(me, "data", {
                get: function() {
                  return me.config.data;
                },
                set: function(value) {
                  me.config.data = value;
                }
              });
              if (!context || !canvas) {
                console.error("Failed to create chart: can't acquire context from the given item");
                return;
              }
              me.initialize();
              me.update();
            },
            /**
             * @private
             */
            initialize: function() {
              var me = this;
              plugins.notify(me, "beforeInit");
              helpers.retinaScale(me);
              me.bindEvents();
              if (me.options.responsive) {
                me.resize(true);
              }
              me.ensureScalesHaveIDs();
              me.buildScales();
              me.initToolTip();
              plugins.notify(me, "afterInit");
              return me;
            },
            clear: function() {
              helpers.clear(this);
              return this;
            },
            stop: function() {
              Chart2.animationService.cancelAnimation(this);
              return this;
            },
            resize: function(silent) {
              var me = this;
              var options = me.options;
              var canvas = me.canvas;
              var aspectRatio = options.maintainAspectRatio && me.aspectRatio || null;
              var newWidth = Math.floor(helpers.getMaximumWidth(canvas));
              var newHeight = Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas));
              if (me.width === newWidth && me.height === newHeight) {
                return;
              }
              canvas.width = me.width = newWidth;
              canvas.height = me.height = newHeight;
              canvas.style.width = newWidth + "px";
              canvas.style.height = newHeight + "px";
              helpers.retinaScale(me);
              if (!silent) {
                var newSize = { width: newWidth, height: newHeight };
                plugins.notify(me, "resize", [newSize]);
                if (me.options.onResize) {
                  me.options.onResize(me, newSize);
                }
                me.stop();
                me.update(me.options.responsiveAnimationDuration);
              }
            },
            ensureScalesHaveIDs: function() {
              var options = this.options;
              var scalesOptions = options.scales || {};
              var scaleOptions = options.scale;
              helpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {
                xAxisOptions.id = xAxisOptions.id || "x-axis-" + index;
              });
              helpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {
                yAxisOptions.id = yAxisOptions.id || "y-axis-" + index;
              });
              if (scaleOptions) {
                scaleOptions.id = scaleOptions.id || "scale";
              }
            },
            /**
             * Builds a map of scale ID to scale object for future lookup.
             */
            buildScales: function() {
              var me = this;
              var options = me.options;
              var scales = me.scales = {};
              var items = [];
              if (options.scales) {
                items = items.concat(
                  (options.scales.xAxes || []).map(function(xAxisOptions) {
                    return { options: xAxisOptions, dtype: "category", dposition: "bottom" };
                  }),
                  (options.scales.yAxes || []).map(function(yAxisOptions) {
                    return { options: yAxisOptions, dtype: "linear", dposition: "left" };
                  })
                );
              }
              if (options.scale) {
                items.push({
                  options: options.scale,
                  dtype: "radialLinear",
                  isDefault: true,
                  dposition: "chartArea"
                });
              }
              helpers.each(items, function(item) {
                var scaleOptions = item.options;
                var scaleType = helpers.getValueOrDefault(scaleOptions.type, item.dtype);
                var scaleClass = Chart2.scaleService.getScaleConstructor(scaleType);
                if (!scaleClass) {
                  return;
                }
                if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
                  scaleOptions.position = item.dposition;
                }
                var scale = new scaleClass({
                  id: scaleOptions.id,
                  options: scaleOptions,
                  ctx: me.ctx,
                  chart: me
                });
                scales[scale.id] = scale;
                if (item.isDefault) {
                  me.scale = scale;
                }
              });
              Chart2.scaleService.addScalesToLayout(this);
            },
            buildOrUpdateControllers: function() {
              var me = this;
              var types = [];
              var newControllers = [];
              helpers.each(me.data.datasets, function(dataset, datasetIndex) {
                var meta = me.getDatasetMeta(datasetIndex);
                if (!meta.type) {
                  meta.type = dataset.type || me.config.type;
                }
                types.push(meta.type);
                if (meta.controller) {
                  meta.controller.updateIndex(datasetIndex);
                } else {
                  var ControllerClass = Chart2.controllers[meta.type];
                  if (ControllerClass === void 0) {
                    throw new Error('"' + meta.type + '" is not a chart type.');
                  }
                  meta.controller = new ControllerClass(me, datasetIndex);
                  newControllers.push(meta.controller);
                }
              }, me);
              if (types.length > 1) {
                for (var i2 = 1; i2 < types.length; i2++) {
                  if (types[i2] !== types[i2 - 1]) {
                    me.isCombo = true;
                    break;
                  }
                }
              }
              return newControllers;
            },
            /**
             * Reset the elements of all datasets
             * @private
             */
            resetElements: function() {
              var me = this;
              helpers.each(me.data.datasets, function(dataset, datasetIndex) {
                me.getDatasetMeta(datasetIndex).controller.reset();
              }, me);
            },
            /**
            * Resets the chart back to it's state before the initial animation
            */
            reset: function() {
              this.resetElements();
              this.tooltip.initialize();
            },
            update: function(animationDuration, lazy) {
              var me = this;
              updateConfig(me);
              if (plugins.notify(me, "beforeUpdate") === false) {
                return;
              }
              me.tooltip._data = me.data;
              var newControllers = me.buildOrUpdateControllers();
              helpers.each(me.data.datasets, function(dataset, datasetIndex) {
                me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
              }, me);
              me.updateLayout();
              helpers.each(newControllers, function(controller) {
                controller.reset();
              });
              me.updateDatasets();
              plugins.notify(me, "afterUpdate");
              if (me._bufferedRender) {
                me._bufferedRequest = {
                  lazy,
                  duration: animationDuration
                };
              } else {
                me.render(animationDuration, lazy);
              }
            },
            /**
             * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
             * hook, in which case, plugins will not be called on `afterLayout`.
             * @private
             */
            updateLayout: function() {
              var me = this;
              if (plugins.notify(me, "beforeLayout") === false) {
                return;
              }
              Chart2.layoutService.update(this, this.width, this.height);
              plugins.notify(me, "afterScaleUpdate");
              plugins.notify(me, "afterLayout");
            },
            /**
             * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
             * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
             * @private
             */
            updateDatasets: function() {
              var me = this;
              if (plugins.notify(me, "beforeDatasetsUpdate") === false) {
                return;
              }
              for (var i2 = 0, ilen = me.data.datasets.length; i2 < ilen; ++i2) {
                me.updateDataset(i2);
              }
              plugins.notify(me, "afterDatasetsUpdate");
            },
            /**
             * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
             * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
             * @private
             */
            updateDataset: function(index) {
              var me = this;
              var meta = me.getDatasetMeta(index);
              var args = {
                meta,
                index
              };
              if (plugins.notify(me, "beforeDatasetUpdate", [args]) === false) {
                return;
              }
              meta.controller.update();
              plugins.notify(me, "afterDatasetUpdate", [args]);
            },
            render: function(duration, lazy) {
              var me = this;
              if (plugins.notify(me, "beforeRender") === false) {
                return;
              }
              var animationOptions = me.options.animation;
              var onComplete = function(animation2) {
                plugins.notify(me, "afterRender");
                helpers.callback(animationOptions && animationOptions.onComplete, [animation2], me);
              };
              if (animationOptions && (typeof duration !== "undefined" && duration !== 0 || typeof duration === "undefined" && animationOptions.duration !== 0)) {
                var animation = new Chart2.Animation({
                  numSteps: (duration || animationOptions.duration) / 16.66,
                  // 60 fps
                  easing: animationOptions.easing,
                  render: function(chart, animationObject) {
                    var easingFunction = helpers.easingEffects[animationObject.easing];
                    var currentStep = animationObject.currentStep;
                    var stepDecimal = currentStep / animationObject.numSteps;
                    chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
                  },
                  onAnimationProgress: animationOptions.onProgress,
                  onAnimationComplete: onComplete
                });
                Chart2.animationService.addAnimation(me, animation, duration, lazy);
              } else {
                me.draw();
                onComplete(new Chart2.Animation({ numSteps: 0, chart: me }));
              }
              return me;
            },
            draw: function(easingValue) {
              var me = this;
              me.clear();
              if (easingValue === void 0 || easingValue === null) {
                easingValue = 1;
              }
              me.transition(easingValue);
              if (plugins.notify(me, "beforeDraw", [easingValue]) === false) {
                return;
              }
              helpers.each(me.boxes, function(box) {
                box.draw(me.chartArea);
              }, me);
              if (me.scale) {
                me.scale.draw();
              }
              me.drawDatasets(easingValue);
              me.tooltip.draw();
              plugins.notify(me, "afterDraw", [easingValue]);
            },
            /**
             * @private
             */
            transition: function(easingValue) {
              var me = this;
              for (var i2 = 0, ilen = (me.data.datasets || []).length; i2 < ilen; ++i2) {
                if (me.isDatasetVisible(i2)) {
                  me.getDatasetMeta(i2).controller.transition(easingValue);
                }
              }
              me.tooltip.transition(easingValue);
            },
            /**
             * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
             * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
             * @private
             */
            drawDatasets: function(easingValue) {
              var me = this;
              if (plugins.notify(me, "beforeDatasetsDraw", [easingValue]) === false) {
                return;
              }
              for (var i2 = (me.data.datasets || []).length - 1; i2 >= 0; --i2) {
                if (me.isDatasetVisible(i2)) {
                  me.drawDataset(i2, easingValue);
                }
              }
              plugins.notify(me, "afterDatasetsDraw", [easingValue]);
            },
            /**
             * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
             * hook, in which case, plugins will not be called on `afterDatasetDraw`.
             * @private
             */
            drawDataset: function(index, easingValue) {
              var me = this;
              var meta = me.getDatasetMeta(index);
              var args = {
                meta,
                index,
                easingValue
              };
              if (plugins.notify(me, "beforeDatasetDraw", [args]) === false) {
                return;
              }
              meta.controller.draw(easingValue);
              plugins.notify(me, "afterDatasetDraw", [args]);
            },
            // Get the single element that was clicked on
            // @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
            getElementAtEvent: function(e2) {
              return Chart2.Interaction.modes.single(this, e2);
            },
            getElementsAtEvent: function(e2) {
              return Chart2.Interaction.modes.label(this, e2, { intersect: true });
            },
            getElementsAtXAxis: function(e2) {
              return Chart2.Interaction.modes["x-axis"](this, e2, { intersect: true });
            },
            getElementsAtEventForMode: function(e2, mode, options) {
              var method = Chart2.Interaction.modes[mode];
              if (typeof method === "function") {
                return method(this, e2, options);
              }
              return [];
            },
            getDatasetAtEvent: function(e2) {
              return Chart2.Interaction.modes.dataset(this, e2, { intersect: true });
            },
            getDatasetMeta: function(datasetIndex) {
              var me = this;
              var dataset = me.data.datasets[datasetIndex];
              if (!dataset._meta) {
                dataset._meta = {};
              }
              var meta = dataset._meta[me.id];
              if (!meta) {
                meta = dataset._meta[me.id] = {
                  type: null,
                  data: [],
                  dataset: null,
                  controller: null,
                  hidden: null,
                  // See isDatasetVisible() comment
                  xAxisID: null,
                  yAxisID: null
                };
              }
              return meta;
            },
            getVisibleDatasetCount: function() {
              var count = 0;
              for (var i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
                if (this.isDatasetVisible(i2)) {
                  count++;
                }
              }
              return count;
            },
            isDatasetVisible: function(datasetIndex) {
              var meta = this.getDatasetMeta(datasetIndex);
              return typeof meta.hidden === "boolean" ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
            },
            generateLegend: function() {
              return this.options.legendCallback(this);
            },
            destroy: function() {
              var me = this;
              var canvas = me.canvas;
              var meta, i2, ilen;
              me.stop();
              for (i2 = 0, ilen = me.data.datasets.length; i2 < ilen; ++i2) {
                meta = me.getDatasetMeta(i2);
                if (meta.controller) {
                  meta.controller.destroy();
                  meta.controller = null;
                }
              }
              if (canvas) {
                me.unbindEvents();
                helpers.clear(me);
                platform.releaseContext(me.ctx);
                me.canvas = null;
                me.ctx = null;
              }
              plugins.notify(me, "destroy");
              delete Chart2.instances[me.id];
            },
            toBase64Image: function() {
              return this.canvas.toDataURL.apply(this.canvas, arguments);
            },
            initToolTip: function() {
              var me = this;
              me.tooltip = new Chart2.Tooltip({
                _chart: me,
                _chartInstance: me,
                // deprecated, backward compatibility
                _data: me.data,
                _options: me.options.tooltips
              }, me);
              me.tooltip.initialize();
            },
            /**
             * @private
             */
            bindEvents: function() {
              var me = this;
              var listeners = me._listeners = {};
              var listener = function() {
                me.eventHandler.apply(me, arguments);
              };
              helpers.each(me.options.events, function(type) {
                platform.addEventListener(me, type, listener);
                listeners[type] = listener;
              });
              if (me.options.responsive) {
                listener = function() {
                  me.resize();
                };
                platform.addEventListener(me, "resize", listener);
                listeners.resize = listener;
              }
            },
            /**
             * @private
             */
            unbindEvents: function() {
              var me = this;
              var listeners = me._listeners;
              if (!listeners) {
                return;
              }
              delete me._listeners;
              helpers.each(listeners, function(listener, type) {
                platform.removeEventListener(me, type, listener);
              });
            },
            updateHoverStyle: function(elements, mode, enabled) {
              var method = enabled ? "setHoverStyle" : "removeHoverStyle";
              var element2, i2, ilen;
              for (i2 = 0, ilen = elements.length; i2 < ilen; ++i2) {
                element2 = elements[i2];
                if (element2) {
                  this.getDatasetMeta(element2._datasetIndex).controller[method](element2);
                }
              }
            },
            /**
             * @private
             */
            eventHandler: function(e2) {
              var me = this;
              var tooltip = me.tooltip;
              if (plugins.notify(me, "beforeEvent", [e2]) === false) {
                return;
              }
              me._bufferedRender = true;
              me._bufferedRequest = null;
              var changed = me.handleEvent(e2);
              changed |= tooltip && tooltip.handleEvent(e2);
              plugins.notify(me, "afterEvent", [e2]);
              var bufferedRequest = me._bufferedRequest;
              if (bufferedRequest) {
                me.render(bufferedRequest.duration, bufferedRequest.lazy);
              } else if (changed && !me.animating) {
                me.stop();
                me.render(me.options.hover.animationDuration, true);
              }
              me._bufferedRender = false;
              me._bufferedRequest = null;
              return me;
            },
            /**
             * Handle an event
             * @private
             * @param {IEvent} event the event to handle
             * @return {Boolean} true if the chart needs to re-render
             */
            handleEvent: function(e2) {
              var me = this;
              var options = me.options || {};
              var hoverOptions = options.hover;
              var changed = false;
              me.lastActive = me.lastActive || [];
              if (e2.type === "mouseout") {
                me.active = [];
              } else {
                me.active = me.getElementsAtEventForMode(e2, hoverOptions.mode, hoverOptions);
              }
              if (hoverOptions.onHover) {
                hoverOptions.onHover.call(me, e2.native, me.active);
              }
              if (e2.type === "mouseup" || e2.type === "click") {
                if (options.onClick) {
                  options.onClick.call(me, e2.native, me.active);
                }
              }
              if (me.lastActive.length) {
                me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
              }
              if (me.active.length && hoverOptions.mode) {
                me.updateHoverStyle(me.active, hoverOptions.mode, true);
              }
              changed = !helpers.arrayEquals(me.active, me.lastActive);
              me.lastActive = me.active;
              return changed;
            }
          }
        );
        Chart2.Controller = Chart2;
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.datasetController.js
  var require_core_datasetController = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.datasetController.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        var arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
        function listenArrayEvents(array, listener) {
          if (array._chartjs) {
            array._chartjs.listeners.push(listener);
            return;
          }
          Object.defineProperty(array, "_chartjs", {
            configurable: true,
            enumerable: false,
            value: {
              listeners: [listener]
            }
          });
          arrayEvents.forEach(function(key) {
            var method = "onData" + key.charAt(0).toUpperCase() + key.slice(1);
            var base = array[key];
            Object.defineProperty(array, key, {
              configurable: true,
              enumerable: false,
              value: function() {
                var args = Array.prototype.slice.call(arguments);
                var res = base.apply(this, args);
                helpers.each(array._chartjs.listeners, function(object) {
                  if (typeof object[method] === "function") {
                    object[method].apply(object, args);
                  }
                });
                return res;
              }
            });
          });
        }
        function unlistenArrayEvents(array, listener) {
          var stub = array._chartjs;
          if (!stub) {
            return;
          }
          var listeners = stub.listeners;
          var index = listeners.indexOf(listener);
          if (index !== -1) {
            listeners.splice(index, 1);
          }
          if (listeners.length > 0) {
            return;
          }
          arrayEvents.forEach(function(key) {
            delete array[key];
          });
          delete array._chartjs;
        }
        Chart2.DatasetController = function(chart, datasetIndex) {
          this.initialize(chart, datasetIndex);
        };
        helpers.extend(Chart2.DatasetController.prototype, {
          /**
           * Element type used to generate a meta dataset (e.g. Chart.element.Line).
           * @type {Chart.core.element}
           */
          datasetElementType: null,
          /**
           * Element type used to generate a meta data (e.g. Chart.element.Point).
           * @type {Chart.core.element}
           */
          dataElementType: null,
          initialize: function(chart, datasetIndex) {
            var me = this;
            me.chart = chart;
            me.index = datasetIndex;
            me.linkScales();
            me.addElements();
          },
          updateIndex: function(datasetIndex) {
            this.index = datasetIndex;
          },
          linkScales: function() {
            var me = this;
            var meta = me.getMeta();
            var dataset = me.getDataset();
            if (meta.xAxisID === null) {
              meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
            }
            if (meta.yAxisID === null) {
              meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
            }
          },
          getDataset: function() {
            return this.chart.data.datasets[this.index];
          },
          getMeta: function() {
            return this.chart.getDatasetMeta(this.index);
          },
          getScaleForId: function(scaleID) {
            return this.chart.scales[scaleID];
          },
          reset: function() {
            this.update(true);
          },
          /**
           * @private
           */
          destroy: function() {
            if (this._data) {
              unlistenArrayEvents(this._data, this);
            }
          },
          createMetaDataset: function() {
            var me = this;
            var type = me.datasetElementType;
            return type && new type({
              _chart: me.chart,
              _datasetIndex: me.index
            });
          },
          createMetaData: function(index) {
            var me = this;
            var type = me.dataElementType;
            return type && new type({
              _chart: me.chart,
              _datasetIndex: me.index,
              _index: index
            });
          },
          addElements: function() {
            var me = this;
            var meta = me.getMeta();
            var data = me.getDataset().data || [];
            var metaData = meta.data;
            var i2, ilen;
            for (i2 = 0, ilen = data.length; i2 < ilen; ++i2) {
              metaData[i2] = metaData[i2] || me.createMetaData(i2);
            }
            meta.dataset = meta.dataset || me.createMetaDataset();
          },
          addElementAndReset: function(index) {
            var element2 = this.createMetaData(index);
            this.getMeta().data.splice(index, 0, element2);
            this.updateElement(element2, index, true);
          },
          buildOrUpdateElements: function() {
            var me = this;
            var dataset = me.getDataset();
            var data = dataset.data || (dataset.data = []);
            if (me._data !== data) {
              if (me._data) {
                unlistenArrayEvents(me._data, me);
              }
              listenArrayEvents(data, me);
              me._data = data;
            }
            me.resyncElements();
          },
          update: helpers.noop,
          transition: function(easingValue) {
            var meta = this.getMeta();
            var elements = meta.data || [];
            var ilen = elements.length;
            var i2 = 0;
            for (; i2 < ilen; ++i2) {
              elements[i2].transition(easingValue);
            }
            if (meta.dataset) {
              meta.dataset.transition(easingValue);
            }
          },
          draw: function() {
            var meta = this.getMeta();
            var elements = meta.data || [];
            var ilen = elements.length;
            var i2 = 0;
            if (meta.dataset) {
              meta.dataset.draw();
            }
            for (; i2 < ilen; ++i2) {
              elements[i2].draw();
            }
          },
          removeHoverStyle: function(element2, elementOpts) {
            var dataset = this.chart.data.datasets[element2._datasetIndex], index = element2._index, custom = element2.custom || {}, valueOrDefault = helpers.getValueAtIndexOrDefault, model = element2._model;
            model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
            model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
            model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);
          },
          setHoverStyle: function(element2) {
            var dataset = this.chart.data.datasets[element2._datasetIndex], index = element2._index, custom = element2.custom || {}, valueOrDefault = helpers.getValueAtIndexOrDefault, getHoverColor = helpers.getHoverColor, model = element2._model;
            model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));
            model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));
            model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
          },
          /**
           * @private
           */
          resyncElements: function() {
            var me = this;
            var meta = me.getMeta();
            var data = me.getDataset().data;
            var numMeta = meta.data.length;
            var numData = data.length;
            if (numData < numMeta) {
              meta.data.splice(numData, numMeta - numData);
            } else if (numData > numMeta) {
              me.insertElements(numMeta, numData - numMeta);
            }
          },
          /**
           * @private
           */
          insertElements: function(start, count) {
            for (var i2 = 0; i2 < count; ++i2) {
              this.addElementAndReset(start + i2);
            }
          },
          /**
           * @private
           */
          onDataPush: function() {
            this.insertElements(this.getDataset().data.length - 1, arguments.length);
          },
          /**
           * @private
           */
          onDataPop: function() {
            this.getMeta().data.pop();
          },
          /**
           * @private
           */
          onDataShift: function() {
            this.getMeta().data.shift();
          },
          /**
           * @private
           */
          onDataSplice: function(start, count) {
            this.getMeta().data.splice(start, count);
            this.insertElements(start, arguments.length - 2);
          },
          /**
           * @private
           */
          onDataUnshift: function() {
            this.insertElements(0, arguments.length);
          }
        });
        Chart2.DatasetController.extend = helpers.inherits;
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.layoutService.js
  var require_core_layoutService = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.layoutService.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        function filterByPosition(array, position) {
          return helpers.where(array, function(v) {
            return v.position === position;
          });
        }
        function sortByWeight(array, reverse) {
          array.forEach(function(v, i2) {
            v._tmpIndex_ = i2;
            return v;
          });
          array.sort(function(a, b) {
            var v0 = reverse ? b : a;
            var v1 = reverse ? a : b;
            return v0.weight === v1.weight ? v0._tmpIndex_ - v1._tmpIndex_ : v0.weight - v1.weight;
          });
          array.forEach(function(v) {
            delete v._tmpIndex_;
          });
        }
        Chart2.layoutService = {
          defaults: {},
          /**
           * Register a box to a chart.
           * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
           * @param {Chart} chart - the chart to use
           * @param {ILayoutItem} item - the item to add to be layed out
           */
          addBox: function(chart, item) {
            if (!chart.boxes) {
              chart.boxes = [];
            }
            item.fullWidth = item.fullWidth || false;
            item.position = item.position || "top";
            item.weight = item.weight || 0;
            chart.boxes.push(item);
          },
          /**
           * Remove a layoutItem from a chart
           * @param {Chart} chart - the chart to remove the box from
           * @param {Object} layoutItem - the item to remove from the layout
           */
          removeBox: function(chart, layoutItem) {
            var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
            if (index !== -1) {
              chart.boxes.splice(index, 1);
            }
          },
          /**
           * Sets (or updates) options on the given `item`.
           * @param {Chart} chart - the chart in which the item lives (or will be added to)
           * @param {Object} item - the item to configure with the given options
           * @param {Object} options - the new item options.
           */
          configure: function(chart, item, options) {
            var props = ["fullWidth", "position", "weight"];
            var ilen = props.length;
            var i2 = 0;
            var prop;
            for (; i2 < ilen; ++i2) {
              prop = props[i2];
              if (options.hasOwnProperty(prop)) {
                item[prop] = options[prop];
              }
            }
          },
          /**
           * Fits boxes of the given chart into the given size by having each box measure itself
           * then running a fitting algorithm
           * @param {Chart} chart - the chart
           * @param {Number} width - the width to fit into
           * @param {Number} height - the height to fit into
           */
          update: function(chart, width, height) {
            if (!chart) {
              return;
            }
            var layoutOptions = chart.options.layout;
            var padding = layoutOptions ? layoutOptions.padding : null;
            var leftPadding = 0;
            var rightPadding = 0;
            var topPadding = 0;
            var bottomPadding = 0;
            if (!isNaN(padding)) {
              leftPadding = padding;
              rightPadding = padding;
              topPadding = padding;
              bottomPadding = padding;
            } else {
              leftPadding = padding.left || 0;
              rightPadding = padding.right || 0;
              topPadding = padding.top || 0;
              bottomPadding = padding.bottom || 0;
            }
            var leftBoxes = filterByPosition(chart.boxes, "left");
            var rightBoxes = filterByPosition(chart.boxes, "right");
            var topBoxes = filterByPosition(chart.boxes, "top");
            var bottomBoxes = filterByPosition(chart.boxes, "bottom");
            var chartAreaBoxes = filterByPosition(chart.boxes, "chartArea");
            sortByWeight(leftBoxes, true);
            sortByWeight(rightBoxes, false);
            sortByWeight(topBoxes, true);
            sortByWeight(bottomBoxes, false);
            var chartWidth = width - leftPadding - rightPadding;
            var chartHeight = height - topPadding - bottomPadding;
            var chartAreaWidth = chartWidth / 2;
            var chartAreaHeight = chartHeight / 2;
            var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);
            var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);
            var maxChartAreaWidth = chartWidth;
            var maxChartAreaHeight = chartHeight;
            var minBoxSizes = [];
            function getMinimumBoxSize(box) {
              var minSize;
              var isHorizontal = box.isHorizontal();
              if (isHorizontal) {
                minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);
                maxChartAreaHeight -= minSize.height;
              } else {
                minSize = box.update(verticalBoxWidth, chartAreaHeight);
                maxChartAreaWidth -= minSize.width;
              }
              minBoxSizes.push({
                horizontal: isHorizontal,
                minSize,
                box
              });
            }
            helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);
            var maxHorizontalLeftPadding = 0;
            var maxHorizontalRightPadding = 0;
            var maxVerticalTopPadding = 0;
            var maxVerticalBottomPadding = 0;
            helpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {
              if (horizontalBox.getPadding) {
                var boxPadding = horizontalBox.getPadding();
                maxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);
                maxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);
              }
            });
            helpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {
              if (verticalBox.getPadding) {
                var boxPadding = verticalBox.getPadding();
                maxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);
                maxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);
              }
            });
            var totalLeftBoxesWidth = leftPadding;
            var totalRightBoxesWidth = rightPadding;
            var totalTopBoxesHeight = topPadding;
            var totalBottomBoxesHeight = bottomPadding;
            function fitBox(box) {
              var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {
                return minBox.box === box;
              });
              if (minBoxSize) {
                if (box.isHorizontal()) {
                  var scaleMargin = {
                    left: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),
                    right: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),
                    top: 0,
                    bottom: 0
                  };
                  box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
                } else {
                  box.update(minBoxSize.minSize.width, maxChartAreaHeight);
                }
              }
            }
            helpers.each(leftBoxes.concat(rightBoxes), fitBox);
            helpers.each(leftBoxes, function(box) {
              totalLeftBoxesWidth += box.width;
            });
            helpers.each(rightBoxes, function(box) {
              totalRightBoxesWidth += box.width;
            });
            helpers.each(topBoxes.concat(bottomBoxes), fitBox);
            helpers.each(topBoxes, function(box) {
              totalTopBoxesHeight += box.height;
            });
            helpers.each(bottomBoxes, function(box) {
              totalBottomBoxesHeight += box.height;
            });
            function finalFitVerticalBox(box) {
              var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {
                return minSize.box === box;
              });
              var scaleMargin = {
                left: 0,
                right: 0,
                top: totalTopBoxesHeight,
                bottom: totalBottomBoxesHeight
              };
              if (minBoxSize) {
                box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);
              }
            }
            helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);
            totalLeftBoxesWidth = leftPadding;
            totalRightBoxesWidth = rightPadding;
            totalTopBoxesHeight = topPadding;
            totalBottomBoxesHeight = bottomPadding;
            helpers.each(leftBoxes, function(box) {
              totalLeftBoxesWidth += box.width;
            });
            helpers.each(rightBoxes, function(box) {
              totalRightBoxesWidth += box.width;
            });
            helpers.each(topBoxes, function(box) {
              totalTopBoxesHeight += box.height;
            });
            helpers.each(bottomBoxes, function(box) {
              totalBottomBoxesHeight += box.height;
            });
            var leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);
            totalLeftBoxesWidth += leftPaddingAddition;
            totalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);
            var topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);
            totalTopBoxesHeight += topPaddingAddition;
            totalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);
            var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;
            var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;
            if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
              helpers.each(leftBoxes, function(box) {
                box.height = newMaxChartAreaHeight;
              });
              helpers.each(rightBoxes, function(box) {
                box.height = newMaxChartAreaHeight;
              });
              helpers.each(topBoxes, function(box) {
                if (!box.fullWidth) {
                  box.width = newMaxChartAreaWidth;
                }
              });
              helpers.each(bottomBoxes, function(box) {
                if (!box.fullWidth) {
                  box.width = newMaxChartAreaWidth;
                }
              });
              maxChartAreaHeight = newMaxChartAreaHeight;
              maxChartAreaWidth = newMaxChartAreaWidth;
            }
            var left = leftPadding + leftPaddingAddition;
            var top = topPadding + topPaddingAddition;
            function placeBox(box) {
              if (box.isHorizontal()) {
                box.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;
                box.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;
                box.top = top;
                box.bottom = top + box.height;
                top = box.bottom;
              } else {
                box.left = left;
                box.right = left + box.width;
                box.top = totalTopBoxesHeight;
                box.bottom = totalTopBoxesHeight + maxChartAreaHeight;
                left = box.right;
              }
            }
            helpers.each(leftBoxes.concat(topBoxes), placeBox);
            left += maxChartAreaWidth;
            top += maxChartAreaHeight;
            helpers.each(rightBoxes, placeBox);
            helpers.each(bottomBoxes, placeBox);
            chart.chartArea = {
              left: totalLeftBoxesWidth,
              top: totalTopBoxesHeight,
              right: totalLeftBoxesWidth + maxChartAreaWidth,
              bottom: totalTopBoxesHeight + maxChartAreaHeight
            };
            helpers.each(chartAreaBoxes, function(box) {
              box.left = chart.chartArea.left;
              box.top = chart.chartArea.top;
              box.right = chart.chartArea.right;
              box.bottom = chart.chartArea.bottom;
              box.update(maxChartAreaWidth, maxChartAreaHeight);
            });
          }
        };
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.scaleService.js
  var require_core_scaleService = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.scaleService.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        Chart2.scaleService = {
          // Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
          // use the new chart options to grab the correct scale
          constructors: {},
          // Use a registration function so that we can move to an ES6 map when we no longer need to support
          // old browsers
          // Scale config defaults
          defaults: {},
          registerScaleType: function(type, scaleConstructor, defaults) {
            this.constructors[type] = scaleConstructor;
            this.defaults[type] = helpers.clone(defaults);
          },
          getScaleConstructor: function(type) {
            return this.constructors.hasOwnProperty(type) ? this.constructors[type] : void 0;
          },
          getScaleDefaults: function(type) {
            return this.defaults.hasOwnProperty(type) ? helpers.scaleMerge(Chart2.defaults.scale, this.defaults[type]) : {};
          },
          updateScaleDefaults: function(type, additions) {
            var defaults = this.defaults;
            if (defaults.hasOwnProperty(type)) {
              defaults[type] = helpers.extend(defaults[type], additions);
            }
          },
          addScalesToLayout: function(chart) {
            helpers.each(chart.scales, function(scale) {
              scale.fullWidth = scale.options.fullWidth;
              scale.position = scale.options.position;
              scale.weight = scale.options.weight;
              Chart2.layoutService.addBox(chart, scale);
            });
          }
        };
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.ticks.js
  var require_core_ticks = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.ticks.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        Chart2.Ticks = {
          /**
           * Namespace to hold generators for different types of ticks
           * @namespace Chart.Ticks.generators
           */
          generators: {
            /**
             * Interface for the options provided to the numeric tick generator
             * @interface INumericTickGenerationOptions
             */
            /**
             * The maximum number of ticks to display
             * @name INumericTickGenerationOptions#maxTicks
             * @type Number
             */
            /**
             * The distance between each tick.
             * @name INumericTickGenerationOptions#stepSize
             * @type Number
             * @optional
             */
            /**
             * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum
             * @name INumericTickGenerationOptions#min
             * @type Number
             * @optional
             */
            /**
             * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum
             * @name INumericTickGenerationOptions#max
             * @type Number
             * @optional
             */
            /**
             * Generate a set of linear ticks
             * @method Chart.Ticks.generators.linear
             * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks
             * @param dataRange {IRange} the range of the data
             * @returns {Array<Number>} array of tick values
             */
            linear: function(generationOptions, dataRange) {
              var ticks = [];
              var spacing;
              if (generationOptions.stepSize && generationOptions.stepSize > 0) {
                spacing = generationOptions.stepSize;
              } else {
                var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);
                spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);
              }
              var niceMin = Math.floor(dataRange.min / spacing) * spacing;
              var niceMax = Math.ceil(dataRange.max / spacing) * spacing;
              if (generationOptions.min && generationOptions.max && generationOptions.stepSize) {
                if (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1e3)) {
                  niceMin = generationOptions.min;
                  niceMax = generationOptions.max;
                }
              }
              var numSpaces = (niceMax - niceMin) / spacing;
              if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
                numSpaces = Math.round(numSpaces);
              } else {
                numSpaces = Math.ceil(numSpaces);
              }
              ticks.push(generationOptions.min !== void 0 ? generationOptions.min : niceMin);
              for (var j = 1; j < numSpaces; ++j) {
                ticks.push(niceMin + j * spacing);
              }
              ticks.push(generationOptions.max !== void 0 ? generationOptions.max : niceMax);
              return ticks;
            },
            /**
             * Generate a set of logarithmic ticks
             * @method Chart.Ticks.generators.logarithmic
             * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks
             * @param dataRange {IRange} the range of the data
             * @returns {Array<Number>} array of tick values
             */
            logarithmic: function(generationOptions, dataRange) {
              var ticks = [];
              var getValueOrDefault = helpers.getValueOrDefault;
              var tickVal = getValueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));
              var endExp = Math.floor(helpers.log10(dataRange.max));
              var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
              var exp;
              var significand;
              if (tickVal === 0) {
                exp = Math.floor(helpers.log10(dataRange.minNotZero));
                significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
                ticks.push(tickVal);
                tickVal = significand * Math.pow(10, exp);
              } else {
                exp = Math.floor(helpers.log10(tickVal));
                significand = Math.floor(tickVal / Math.pow(10, exp));
              }
              do {
                ticks.push(tickVal);
                ++significand;
                if (significand === 10) {
                  significand = 1;
                  ++exp;
                }
                tickVal = significand * Math.pow(10, exp);
              } while (exp < endExp || exp === endExp && significand < endSignificand);
              var lastTick = getValueOrDefault(generationOptions.max, tickVal);
              ticks.push(lastTick);
              return ticks;
            }
          },
          /**
           * Namespace to hold formatters for different types of ticks
           * @namespace Chart.Ticks.formatters
           */
          formatters: {
            /**
             * Formatter for value labels
             * @method Chart.Ticks.formatters.values
             * @param value the value to display
             * @return {String|Array} the label to display
             */
            values: function(value) {
              return helpers.isArray(value) ? value : "" + value;
            },
            /**
             * Formatter for linear numeric ticks
             * @method Chart.Ticks.formatters.linear
             * @param tickValue {Number} the value to be formatted
             * @param index {Number} the position of the tickValue parameter in the ticks array
             * @param ticks {Array<Number>} the list of ticks being converted
             * @return {String} string representation of the tickValue parameter
             */
            linear: function(tickValue, index, ticks) {
              var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];
              if (Math.abs(delta) > 1) {
                if (tickValue !== Math.floor(tickValue)) {
                  delta = tickValue - Math.floor(tickValue);
                }
              }
              var logDelta = helpers.log10(Math.abs(delta));
              var tickString = "";
              if (tickValue !== 0) {
                var numDecimal = -1 * Math.floor(logDelta);
                numDecimal = Math.max(Math.min(numDecimal, 20), 0);
                tickString = tickValue.toFixed(numDecimal);
              } else {
                tickString = "0";
              }
              return tickString;
            },
            logarithmic: function(tickValue, index, ticks) {
              var remain = tickValue / Math.pow(10, Math.floor(helpers.log10(tickValue)));
              if (tickValue === 0) {
                return "0";
              } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
                return tickValue.toExponential();
              }
              return "";
            }
          }
        };
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.scale.js
  var require_core_scale = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.scale.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        Chart2.defaults.scale = {
          display: true,
          position: "left",
          // grid line settings
          gridLines: {
            display: true,
            color: "rgba(0, 0, 0, 0.1)",
            lineWidth: 1,
            drawBorder: true,
            drawOnChartArea: true,
            drawTicks: true,
            tickMarkLength: 10,
            zeroLineWidth: 1,
            zeroLineColor: "rgba(0,0,0,0.25)",
            zeroLineBorderDash: [],
            zeroLineBorderDashOffset: 0,
            offsetGridLines: false,
            borderDash: [],
            borderDashOffset: 0
          },
          // scale label
          scaleLabel: {
            // actual label
            labelString: "",
            // display property
            display: false
          },
          // label settings
          ticks: {
            beginAtZero: false,
            minRotation: 0,
            maxRotation: 50,
            mirror: false,
            padding: 0,
            reverse: false,
            display: true,
            autoSkip: true,
            autoSkipPadding: 0,
            labelOffset: 0,
            // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
            callback: Chart2.Ticks.formatters.values
          }
        };
        function computeTextSize(context, tick2, font) {
          return helpers.isArray(tick2) ? helpers.longestText(context, font, tick2) : context.measureText(tick2).width;
        }
        function parseFontOptions(options) {
          var getValueOrDefault = helpers.getValueOrDefault;
          var globalDefaults = Chart2.defaults.global;
          var size = getValueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
          var style = getValueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);
          var family = getValueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);
          return {
            size,
            style,
            family,
            font: helpers.fontString(size, style, family)
          };
        }
        Chart2.Scale = Chart2.Element.extend({
          /**
           * Get the padding needed for the scale
           * @method getPadding
           * @private
           * @returns {Padding} the necessary padding
           */
          getPadding: function() {
            var me = this;
            return {
              left: me.paddingLeft || 0,
              top: me.paddingTop || 0,
              right: me.paddingRight || 0,
              bottom: me.paddingBottom || 0
            };
          },
          // These methods are ordered by lifecyle. Utilities then follow.
          // Any function defined here is inherited by all scale types.
          // Any function can be extended by the scale type
          beforeUpdate: function() {
            helpers.callback(this.options.beforeUpdate, [this]);
          },
          update: function(maxWidth, maxHeight, margins) {
            var me = this;
            me.beforeUpdate();
            me.maxWidth = maxWidth;
            me.maxHeight = maxHeight;
            me.margins = helpers.extend({
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            }, margins);
            me.longestTextCache = me.longestTextCache || {};
            me.beforeSetDimensions();
            me.setDimensions();
            me.afterSetDimensions();
            me.beforeDataLimits();
            me.determineDataLimits();
            me.afterDataLimits();
            me.beforeBuildTicks();
            me.buildTicks();
            me.afterBuildTicks();
            me.beforeTickToLabelConversion();
            me.convertTicksToLabels();
            me.afterTickToLabelConversion();
            me.beforeCalculateTickRotation();
            me.calculateTickRotation();
            me.afterCalculateTickRotation();
            me.beforeFit();
            me.fit();
            me.afterFit();
            me.afterUpdate();
            return me.minSize;
          },
          afterUpdate: function() {
            helpers.callback(this.options.afterUpdate, [this]);
          },
          //
          beforeSetDimensions: function() {
            helpers.callback(this.options.beforeSetDimensions, [this]);
          },
          setDimensions: function() {
            var me = this;
            if (me.isHorizontal()) {
              me.width = me.maxWidth;
              me.left = 0;
              me.right = me.width;
            } else {
              me.height = me.maxHeight;
              me.top = 0;
              me.bottom = me.height;
            }
            me.paddingLeft = 0;
            me.paddingTop = 0;
            me.paddingRight = 0;
            me.paddingBottom = 0;
          },
          afterSetDimensions: function() {
            helpers.callback(this.options.afterSetDimensions, [this]);
          },
          // Data limits
          beforeDataLimits: function() {
            helpers.callback(this.options.beforeDataLimits, [this]);
          },
          determineDataLimits: helpers.noop,
          afterDataLimits: function() {
            helpers.callback(this.options.afterDataLimits, [this]);
          },
          //
          beforeBuildTicks: function() {
            helpers.callback(this.options.beforeBuildTicks, [this]);
          },
          buildTicks: helpers.noop,
          afterBuildTicks: function() {
            helpers.callback(this.options.afterBuildTicks, [this]);
          },
          beforeTickToLabelConversion: function() {
            helpers.callback(this.options.beforeTickToLabelConversion, [this]);
          },
          convertTicksToLabels: function() {
            var me = this;
            var tickOpts = me.options.ticks;
            me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback);
          },
          afterTickToLabelConversion: function() {
            helpers.callback(this.options.afterTickToLabelConversion, [this]);
          },
          //
          beforeCalculateTickRotation: function() {
            helpers.callback(this.options.beforeCalculateTickRotation, [this]);
          },
          calculateTickRotation: function() {
            var me = this;
            var context = me.ctx;
            var tickOpts = me.options.ticks;
            var tickFont = parseFontOptions(tickOpts);
            context.font = tickFont.font;
            var labelRotation = tickOpts.minRotation || 0;
            if (me.options.display && me.isHorizontal()) {
              var originalLabelWidth = helpers.longestText(context, tickFont.font, me.ticks, me.longestTextCache);
              var labelWidth = originalLabelWidth;
              var cosRotation;
              var sinRotation;
              var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;
              while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
                var angleRadians = helpers.toRadians(labelRotation);
                cosRotation = Math.cos(angleRadians);
                sinRotation = Math.sin(angleRadians);
                if (sinRotation * originalLabelWidth > me.maxHeight) {
                  labelRotation--;
                  break;
                }
                labelRotation++;
                labelWidth = cosRotation * originalLabelWidth;
              }
            }
            me.labelRotation = labelRotation;
          },
          afterCalculateTickRotation: function() {
            helpers.callback(this.options.afterCalculateTickRotation, [this]);
          },
          //
          beforeFit: function() {
            helpers.callback(this.options.beforeFit, [this]);
          },
          fit: function() {
            var me = this;
            var minSize = me.minSize = {
              width: 0,
              height: 0
            };
            var opts = me.options;
            var tickOpts = opts.ticks;
            var scaleLabelOpts = opts.scaleLabel;
            var gridLineOpts = opts.gridLines;
            var display = opts.display;
            var isHorizontal = me.isHorizontal();
            var tickFont = parseFontOptions(tickOpts);
            var scaleLabelFontSize = parseFontOptions(scaleLabelOpts).size * 1.5;
            var tickMarkLength = opts.gridLines.tickMarkLength;
            if (isHorizontal) {
              minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
            } else {
              minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
            }
            if (isHorizontal) {
              minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
            } else {
              minSize.height = me.maxHeight;
            }
            if (scaleLabelOpts.display && display) {
              if (isHorizontal) {
                minSize.height += scaleLabelFontSize;
              } else {
                minSize.width += scaleLabelFontSize;
              }
            }
            if (tickOpts.display && display) {
              var largestTextWidth = helpers.longestText(me.ctx, tickFont.font, me.ticks, me.longestTextCache);
              var tallestLabelHeightInLines = helpers.numberOfLabelLines(me.ticks);
              var lineSpace = tickFont.size * 0.5;
              if (isHorizontal) {
                me.longestLabelWidth = largestTextWidth;
                var angleRadians = helpers.toRadians(me.labelRotation);
                var cosRotation = Math.cos(angleRadians);
                var sinRotation = Math.sin(angleRadians);
                var labelHeight = sinRotation * largestTextWidth + tickFont.size * tallestLabelHeightInLines + lineSpace * tallestLabelHeightInLines;
                minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight);
                me.ctx.font = tickFont.font;
                var firstTick = me.ticks[0];
                var firstLabelWidth = computeTextSize(me.ctx, firstTick, tickFont.font);
                var lastTick = me.ticks[me.ticks.length - 1];
                var lastLabelWidth = computeTextSize(me.ctx, lastTick, tickFont.font);
                if (me.labelRotation !== 0) {
                  me.paddingLeft = opts.position === "bottom" ? cosRotation * firstLabelWidth + 3 : cosRotation * lineSpace + 3;
                  me.paddingRight = opts.position === "bottom" ? cosRotation * lineSpace + 3 : cosRotation * lastLabelWidth + 3;
                } else {
                  me.paddingLeft = firstLabelWidth / 2 + 3;
                  me.paddingRight = lastLabelWidth / 2 + 3;
                }
              } else {
                if (tickOpts.mirror) {
                  largestTextWidth = 0;
                } else {
                  largestTextWidth += me.options.ticks.padding;
                }
                minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);
                me.paddingTop = tickFont.size / 2;
                me.paddingBottom = tickFont.size / 2;
              }
            }
            me.handleMargins();
            me.width = minSize.width;
            me.height = minSize.height;
          },
          /**
           * Handle margins and padding interactions
           * @private
           */
          handleMargins: function() {
            var me = this;
            if (me.margins) {
              me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
              me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
              me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
              me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
            }
          },
          afterFit: function() {
            helpers.callback(this.options.afterFit, [this]);
          },
          // Shared Methods
          isHorizontal: function() {
            return this.options.position === "top" || this.options.position === "bottom";
          },
          isFullWidth: function() {
            return this.options.fullWidth;
          },
          // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
          getRightValue: function(rawValue) {
            if (rawValue === null || typeof rawValue === "undefined") {
              return NaN;
            }
            if (typeof rawValue === "number" && !isFinite(rawValue)) {
              return NaN;
            }
            if (typeof rawValue === "object") {
              if (rawValue instanceof Date || rawValue.isValid) {
                return rawValue;
              }
              return this.getRightValue(this.isHorizontal() ? rawValue.x : rawValue.y);
            }
            return rawValue;
          },
          // Used to get the value to display in the tooltip for the data at the given index
          // function getLabelForIndex(index, datasetIndex)
          getLabelForIndex: helpers.noop,
          // Used to get data value locations.  Value can either be an index or a numerical value
          getPixelForValue: helpers.noop,
          // Used to get the data value from a given pixel. This is the inverse of getPixelForValue
          getValueForPixel: helpers.noop,
          // Used for tick location, should
          getPixelForTick: function(index, includeOffset) {
            var me = this;
            if (me.isHorizontal()) {
              var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
              var tickWidth = innerWidth / Math.max(me.ticks.length - (me.options.gridLines.offsetGridLines ? 0 : 1), 1);
              var pixel = tickWidth * index + me.paddingLeft;
              if (includeOffset) {
                pixel += tickWidth / 2;
              }
              var finalVal = me.left + Math.round(pixel);
              finalVal += me.isFullWidth() ? me.margins.left : 0;
              return finalVal;
            }
            var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
            return me.top + index * (innerHeight / (me.ticks.length - 1));
          },
          // Utility for getting the pixel location of a percentage of scale
          getPixelForDecimal: function(decimal) {
            var me = this;
            if (me.isHorizontal()) {
              var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
              var valueOffset = innerWidth * decimal + me.paddingLeft;
              var finalVal = me.left + Math.round(valueOffset);
              finalVal += me.isFullWidth() ? me.margins.left : 0;
              return finalVal;
            }
            return me.top + decimal * me.height;
          },
          getBasePixel: function() {
            return this.getPixelForValue(this.getBaseValue());
          },
          getBaseValue: function() {
            var me = this;
            var min = me.min;
            var max = me.max;
            return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
          },
          // Actually draw the scale on the canvas
          // @param {rectangle} chartArea : the area of the chart to draw full grid lines on
          draw: function(chartArea) {
            var me = this;
            var options = me.options;
            if (!options.display) {
              return;
            }
            var context = me.ctx;
            var globalDefaults = Chart2.defaults.global;
            var optionTicks = options.ticks;
            var gridLines = options.gridLines;
            var scaleLabel = options.scaleLabel;
            var isRotated = me.labelRotation !== 0;
            var skipRatio;
            var useAutoskipper = optionTicks.autoSkip;
            var isHorizontal = me.isHorizontal();
            var maxTicks;
            if (optionTicks.maxTicksLimit) {
              maxTicks = optionTicks.maxTicksLimit;
            }
            var tickFontColor = helpers.getValueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);
            var tickFont = parseFontOptions(optionTicks);
            var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;
            var scaleLabelFontColor = helpers.getValueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);
            var scaleLabelFont = parseFontOptions(scaleLabel);
            var labelRotationRadians = helpers.toRadians(me.labelRotation);
            var cosRotation = Math.cos(labelRotationRadians);
            var longestRotatedLabel = me.longestLabelWidth * cosRotation;
            context.fillStyle = tickFontColor;
            var itemsToDraw = [];
            if (isHorizontal) {
              skipRatio = false;
              if ((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length > me.width - (me.paddingLeft + me.paddingRight)) {
                skipRatio = 1 + Math.floor((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length / (me.width - (me.paddingLeft + me.paddingRight)));
              }
              if (maxTicks && me.ticks.length > maxTicks) {
                while (!skipRatio || me.ticks.length / (skipRatio || 1) > maxTicks) {
                  if (!skipRatio) {
                    skipRatio = 1;
                  }
                  skipRatio += 1;
                }
              }
              if (!useAutoskipper) {
                skipRatio = false;
              }
            }
            var xTickStart = options.position === "right" ? me.left : me.right - tl;
            var xTickEnd = options.position === "right" ? me.left + tl : me.right;
            var yTickStart = options.position === "bottom" ? me.top : me.bottom - tl;
            var yTickEnd = options.position === "bottom" ? me.top + tl : me.bottom;
            helpers.each(me.ticks, function(label, index) {
              if (label === void 0 || label === null) {
                return;
              }
              var isLastTick = me.ticks.length === index + 1;
              var shouldSkip = skipRatio > 1 && index % skipRatio > 0 || index % skipRatio === 0 && index + skipRatio >= me.ticks.length;
              if (shouldSkip && !isLastTick || (label === void 0 || label === null)) {
                return;
              }
              var lineWidth, lineColor, borderDash, borderDashOffset;
              if (index === (typeof me.zeroLineIndex !== "undefined" ? me.zeroLineIndex : 0)) {
                lineWidth = gridLines.zeroLineWidth;
                lineColor = gridLines.zeroLineColor;
                borderDash = gridLines.zeroLineBorderDash;
                borderDashOffset = gridLines.zeroLineBorderDashOffset;
              } else {
                lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, index);
                lineColor = helpers.getValueAtIndexOrDefault(gridLines.color, index);
                borderDash = helpers.getValueOrDefault(gridLines.borderDash, globalDefaults.borderDash);
                borderDashOffset = helpers.getValueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);
              }
              var tx1, ty1, tx2, ty2, x12, y12, x22, y22, labelX, labelY;
              var textAlign = "middle";
              var textBaseline = "middle";
              if (isHorizontal) {
                if (options.position === "bottom") {
                  textBaseline = !isRotated ? "top" : "middle";
                  textAlign = !isRotated ? "center" : "right";
                  labelY = me.top + tl;
                } else {
                  textBaseline = !isRotated ? "bottom" : "middle";
                  textAlign = !isRotated ? "center" : "left";
                  labelY = me.bottom - tl;
                }
                var xLineValue = me.getPixelForTick(index) + helpers.aliasPixel(lineWidth);
                labelX = me.getPixelForTick(index, gridLines.offsetGridLines) + optionTicks.labelOffset;
                tx1 = tx2 = x12 = x22 = xLineValue;
                ty1 = yTickStart;
                ty2 = yTickEnd;
                y12 = chartArea.top;
                y22 = chartArea.bottom;
              } else {
                var isLeft2 = options.position === "left";
                var tickPadding = optionTicks.padding;
                var labelXOffset;
                if (optionTicks.mirror) {
                  textAlign = isLeft2 ? "left" : "right";
                  labelXOffset = tickPadding;
                } else {
                  textAlign = isLeft2 ? "right" : "left";
                  labelXOffset = tl + tickPadding;
                }
                labelX = isLeft2 ? me.right - labelXOffset : me.left + labelXOffset;
                var yLineValue = me.getPixelForTick(index);
                yLineValue += helpers.aliasPixel(lineWidth);
                labelY = me.getPixelForTick(index, gridLines.offsetGridLines);
                tx1 = xTickStart;
                tx2 = xTickEnd;
                x12 = chartArea.left;
                x22 = chartArea.right;
                ty1 = ty2 = y12 = y22 = yLineValue;
              }
              itemsToDraw.push({
                tx1,
                ty1,
                tx2,
                ty2,
                x1: x12,
                y1: y12,
                x2: x22,
                y2: y22,
                labelX,
                labelY,
                glWidth: lineWidth,
                glColor: lineColor,
                glBorderDash: borderDash,
                glBorderDashOffset: borderDashOffset,
                rotation: -1 * labelRotationRadians,
                label,
                textBaseline,
                textAlign
              });
            });
            helpers.each(itemsToDraw, function(itemToDraw) {
              if (gridLines.display) {
                context.save();
                context.lineWidth = itemToDraw.glWidth;
                context.strokeStyle = itemToDraw.glColor;
                if (context.setLineDash) {
                  context.setLineDash(itemToDraw.glBorderDash);
                  context.lineDashOffset = itemToDraw.glBorderDashOffset;
                }
                context.beginPath();
                if (gridLines.drawTicks) {
                  context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
                  context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
                }
                if (gridLines.drawOnChartArea) {
                  context.moveTo(itemToDraw.x1, itemToDraw.y1);
                  context.lineTo(itemToDraw.x2, itemToDraw.y2);
                }
                context.stroke();
                context.restore();
              }
              if (optionTicks.display) {
                context.save();
                context.translate(itemToDraw.labelX, itemToDraw.labelY);
                context.rotate(itemToDraw.rotation);
                context.font = tickFont.font;
                context.textBaseline = itemToDraw.textBaseline;
                context.textAlign = itemToDraw.textAlign;
                var label = itemToDraw.label;
                if (helpers.isArray(label)) {
                  for (var i2 = 0, y = 0; i2 < label.length; ++i2) {
                    context.fillText("" + label[i2], 0, y);
                    y += tickFont.size * 1.5;
                  }
                } else {
                  context.fillText(label, 0, 0);
                }
                context.restore();
              }
            });
            if (scaleLabel.display) {
              var scaleLabelX;
              var scaleLabelY;
              var rotation = 0;
              if (isHorizontal) {
                scaleLabelX = me.left + (me.right - me.left) / 2;
                scaleLabelY = options.position === "bottom" ? me.bottom - scaleLabelFont.size / 2 : me.top + scaleLabelFont.size / 2;
              } else {
                var isLeft = options.position === "left";
                scaleLabelX = isLeft ? me.left + scaleLabelFont.size / 2 : me.right - scaleLabelFont.size / 2;
                scaleLabelY = me.top + (me.bottom - me.top) / 2;
                rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
              }
              context.save();
              context.translate(scaleLabelX, scaleLabelY);
              context.rotate(rotation);
              context.textAlign = "center";
              context.textBaseline = "middle";
              context.fillStyle = scaleLabelFontColor;
              context.font = scaleLabelFont.font;
              context.fillText(scaleLabel.labelString, 0, 0);
              context.restore();
            }
            if (gridLines.drawBorder) {
              context.lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, 0);
              context.strokeStyle = helpers.getValueAtIndexOrDefault(gridLines.color, 0);
              var x1 = me.left, x2 = me.right, y1 = me.top, y2 = me.bottom;
              var aliasPixel = helpers.aliasPixel(context.lineWidth);
              if (isHorizontal) {
                y1 = y2 = options.position === "top" ? me.bottom : me.top;
                y1 += aliasPixel;
                y2 += aliasPixel;
              } else {
                x1 = x2 = options.position === "left" ? me.right : me.left;
                x1 += aliasPixel;
                x2 += aliasPixel;
              }
              context.beginPath();
              context.moveTo(x1, y1);
              context.lineTo(x2, y2);
              context.stroke();
            }
          }
        });
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.interaction.js
  var require_core_interaction = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.interaction.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        function getRelativePosition(e2, chart) {
          if (e2.native) {
            return {
              x: e2.x,
              y: e2.y
            };
          }
          return helpers.getRelativePosition(e2, chart);
        }
        function parseVisibleItems(chart, handler) {
          var datasets = chart.data.datasets;
          var meta, i2, j, ilen, jlen;
          for (i2 = 0, ilen = datasets.length; i2 < ilen; ++i2) {
            if (!chart.isDatasetVisible(i2)) {
              continue;
            }
            meta = chart.getDatasetMeta(i2);
            for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
              var element2 = meta.data[j];
              if (!element2._view.skip) {
                handler(element2);
              }
            }
          }
        }
        function getIntersectItems(chart, position) {
          var elements = [];
          parseVisibleItems(chart, function(element2) {
            if (element2.inRange(position.x, position.y)) {
              elements.push(element2);
            }
          });
          return elements;
        }
        function getNearestItems(chart, position, intersect, distanceMetric) {
          var minDistance = Number.POSITIVE_INFINITY;
          var nearestItems = [];
          if (!distanceMetric) {
            distanceMetric = helpers.distanceBetweenPoints;
          }
          parseVisibleItems(chart, function(element2) {
            if (intersect && !element2.inRange(position.x, position.y)) {
              return;
            }
            var center = element2.getCenterPoint();
            var distance = distanceMetric(position, center);
            if (distance < minDistance) {
              nearestItems = [element2];
              minDistance = distance;
            } else if (distance === minDistance) {
              nearestItems.push(element2);
            }
          });
          return nearestItems;
        }
        function indexMode(chart, e2, options) {
          var position = getRelativePosition(e2, chart);
          var distanceMetric = function(pt1, pt2) {
            return Math.abs(pt1.x - pt2.x);
          };
          var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
          var elements = [];
          if (!items.length) {
            return [];
          }
          chart.data.datasets.forEach(function(dataset, datasetIndex) {
            if (chart.isDatasetVisible(datasetIndex)) {
              var meta = chart.getDatasetMeta(datasetIndex), element2 = meta.data[items[0]._index];
              if (element2 && !element2._view.skip) {
                elements.push(element2);
              }
            }
          });
          return elements;
        }
        Chart2.Interaction = {
          // Helper function for different modes
          modes: {
            single: function(chart, e2) {
              var position = getRelativePosition(e2, chart);
              var elements = [];
              parseVisibleItems(chart, function(element2) {
                if (element2.inRange(position.x, position.y)) {
                  elements.push(element2);
                  return elements;
                }
              });
              return elements.slice(0, 1);
            },
            /**
             * @function Chart.Interaction.modes.label
             * @deprecated since version 2.4.0
            	 * @todo remove at version 3
             * @private
             */
            label: indexMode,
            /**
             * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
             * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
             * @function Chart.Interaction.modes.index
             * @since v2.4.0
             * @param chart {chart} the chart we are returning items from
             * @param e {Event} the event we are find things at
             * @param options {IInteractionOptions} options to use during interaction
             * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
             */
            index: indexMode,
            /**
             * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
             * If the options.intersect is false, we find the nearest item and return the items in that dataset
             * @function Chart.Interaction.modes.dataset
             * @param chart {chart} the chart we are returning items from
             * @param e {Event} the event we are find things at
             * @param options {IInteractionOptions} options to use during interaction
             * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
             */
            dataset: function(chart, e2, options) {
              var position = getRelativePosition(e2, chart);
              var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false);
              if (items.length > 0) {
                items = chart.getDatasetMeta(items[0]._datasetIndex).data;
              }
              return items;
            },
            /**
             * @function Chart.Interaction.modes.x-axis
             * @deprecated since version 2.4.0. Use index mode and intersect == true
             * @todo remove at version 3
             * @private
             */
            "x-axis": function(chart, e2) {
              return indexMode(chart, e2, true);
            },
            /**
             * Point mode returns all elements that hit test based on the event position
             * of the event
             * @function Chart.Interaction.modes.intersect
             * @param chart {chart} the chart we are returning items from
             * @param e {Event} the event we are find things at
             * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
             */
            point: function(chart, e2) {
              var position = getRelativePosition(e2, chart);
              return getIntersectItems(chart, position);
            },
            /**
             * nearest mode returns the element closest to the point
             * @function Chart.Interaction.modes.intersect
             * @param chart {chart} the chart we are returning items from
             * @param e {Event} the event we are find things at
             * @param options {IInteractionOptions} options to use
             * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
             */
            nearest: function(chart, e2, options) {
              var position = getRelativePosition(e2, chart);
              var nearestItems = getNearestItems(chart, position, options.intersect);
              if (nearestItems.length > 1) {
                nearestItems.sort(function(a, b) {
                  var sizeA = a.getArea();
                  var sizeB = b.getArea();
                  var ret = sizeA - sizeB;
                  if (ret === 0) {
                    ret = a._datasetIndex - b._datasetIndex;
                  }
                  return ret;
                });
              }
              return nearestItems.slice(0, 1);
            },
            /**
             * x mode returns the elements that hit-test at the current x coordinate
             * @function Chart.Interaction.modes.x
             * @param chart {chart} the chart we are returning items from
             * @param e {Event} the event we are find things at
             * @param options {IInteractionOptions} options to use
             * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
             */
            x: function(chart, e2, options) {
              var position = getRelativePosition(e2, chart);
              var items = [];
              var intersectsItem = false;
              parseVisibleItems(chart, function(element2) {
                if (element2.inXRange(position.x)) {
                  items.push(element2);
                }
                if (element2.inRange(position.x, position.y)) {
                  intersectsItem = true;
                }
              });
              if (options.intersect && !intersectsItem) {
                items = [];
              }
              return items;
            },
            /**
             * y mode returns the elements that hit-test at the current y coordinate
             * @function Chart.Interaction.modes.y
             * @param chart {chart} the chart we are returning items from
             * @param e {Event} the event we are find things at
             * @param options {IInteractionOptions} options to use
             * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
             */
            y: function(chart, e2, options) {
              var position = getRelativePosition(e2, chart);
              var items = [];
              var intersectsItem = false;
              parseVisibleItems(chart, function(element2) {
                if (element2.inYRange(position.y)) {
                  items.push(element2);
                }
                if (element2.inRange(position.x, position.y)) {
                  intersectsItem = true;
                }
              });
              if (options.intersect && !intersectsItem) {
                items = [];
              }
              return items;
            }
          }
        };
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.tooltip.js
  var require_core_tooltip = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/core/core.tooltip.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        function mergeOpacity(colorString, opacity) {
          var color = helpers.color(colorString);
          return color.alpha(opacity * color.alpha()).rgbaString();
        }
        Chart2.defaults.global.tooltips = {
          enabled: true,
          custom: null,
          mode: "nearest",
          position: "average",
          intersect: true,
          backgroundColor: "rgba(0,0,0,0.8)",
          titleFontStyle: "bold",
          titleSpacing: 2,
          titleMarginBottom: 6,
          titleFontColor: "#fff",
          titleAlign: "left",
          bodySpacing: 2,
          bodyFontColor: "#fff",
          bodyAlign: "left",
          footerFontStyle: "bold",
          footerSpacing: 2,
          footerMarginTop: 6,
          footerFontColor: "#fff",
          footerAlign: "left",
          yPadding: 6,
          xPadding: 6,
          caretPadding: 2,
          caretSize: 5,
          cornerRadius: 6,
          multiKeyBackground: "#fff",
          displayColors: true,
          borderColor: "rgba(0,0,0,0)",
          borderWidth: 0,
          callbacks: {
            // Args are: (tooltipItems, data)
            beforeTitle: helpers.noop,
            title: function(tooltipItems, data) {
              var title = "";
              var labels = data.labels;
              var labelCount = labels ? labels.length : 0;
              if (tooltipItems.length > 0) {
                var item = tooltipItems[0];
                if (item.xLabel) {
                  title = item.xLabel;
                } else if (labelCount > 0 && item.index < labelCount) {
                  title = labels[item.index];
                }
              }
              return title;
            },
            afterTitle: helpers.noop,
            // Args are: (tooltipItems, data)
            beforeBody: helpers.noop,
            // Args are: (tooltipItem, data)
            beforeLabel: helpers.noop,
            label: function(tooltipItem, data) {
              var label = data.datasets[tooltipItem.datasetIndex].label || "";
              if (label) {
                label += ": ";
              }
              label += tooltipItem.yLabel;
              return label;
            },
            labelColor: function(tooltipItem, chart) {
              var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
              var activeElement = meta.data[tooltipItem.index];
              var view = activeElement._view;
              return {
                borderColor: view.borderColor,
                backgroundColor: view.backgroundColor
              };
            },
            afterLabel: helpers.noop,
            // Args are: (tooltipItems, data)
            afterBody: helpers.noop,
            // Args are: (tooltipItems, data)
            beforeFooter: helpers.noop,
            footer: helpers.noop,
            afterFooter: helpers.noop
          }
        };
        function pushOrConcat(base, toPush) {
          if (toPush) {
            if (helpers.isArray(toPush)) {
              Array.prototype.push.apply(base, toPush);
            } else {
              base.push(toPush);
            }
          }
          return base;
        }
        function createTooltipItem(element2) {
          var xScale = element2._xScale;
          var yScale = element2._yScale || element2._scale;
          var index = element2._index, datasetIndex = element2._datasetIndex;
          return {
            xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : "",
            yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : "",
            index,
            datasetIndex,
            x: element2._model.x,
            y: element2._model.y
          };
        }
        function getBaseModel(tooltipOpts) {
          var globalDefaults = Chart2.defaults.global;
          var getValueOrDefault = helpers.getValueOrDefault;
          return {
            // Positioning
            xPadding: tooltipOpts.xPadding,
            yPadding: tooltipOpts.yPadding,
            xAlign: tooltipOpts.xAlign,
            yAlign: tooltipOpts.yAlign,
            // Body
            bodyFontColor: tooltipOpts.bodyFontColor,
            _bodyFontFamily: getValueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
            _bodyFontStyle: getValueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
            _bodyAlign: tooltipOpts.bodyAlign,
            bodyFontSize: getValueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
            bodySpacing: tooltipOpts.bodySpacing,
            // Title
            titleFontColor: tooltipOpts.titleFontColor,
            _titleFontFamily: getValueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
            _titleFontStyle: getValueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
            titleFontSize: getValueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
            _titleAlign: tooltipOpts.titleAlign,
            titleSpacing: tooltipOpts.titleSpacing,
            titleMarginBottom: tooltipOpts.titleMarginBottom,
            // Footer
            footerFontColor: tooltipOpts.footerFontColor,
            _footerFontFamily: getValueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
            _footerFontStyle: getValueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
            footerFontSize: getValueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
            _footerAlign: tooltipOpts.footerAlign,
            footerSpacing: tooltipOpts.footerSpacing,
            footerMarginTop: tooltipOpts.footerMarginTop,
            // Appearance
            caretSize: tooltipOpts.caretSize,
            cornerRadius: tooltipOpts.cornerRadius,
            backgroundColor: tooltipOpts.backgroundColor,
            opacity: 0,
            legendColorBackground: tooltipOpts.multiKeyBackground,
            displayColors: tooltipOpts.displayColors,
            borderColor: tooltipOpts.borderColor,
            borderWidth: tooltipOpts.borderWidth
          };
        }
        function getTooltipSize(tooltip, model) {
          var ctx = tooltip._chart.ctx;
          var height = model.yPadding * 2;
          var width = 0;
          var body = model.body;
          var combinedBodyLength = body.reduce(function(count, bodyItem) {
            return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
          }, 0);
          combinedBodyLength += model.beforeBody.length + model.afterBody.length;
          var titleLineCount = model.title.length;
          var footerLineCount = model.footer.length;
          var titleFontSize = model.titleFontSize, bodyFontSize = model.bodyFontSize, footerFontSize = model.footerFontSize;
          height += titleLineCount * titleFontSize;
          height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0;
          height += titleLineCount ? model.titleMarginBottom : 0;
          height += combinedBodyLength * bodyFontSize;
          height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0;
          height += footerLineCount ? model.footerMarginTop : 0;
          height += footerLineCount * footerFontSize;
          height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0;
          var widthPadding = 0;
          var maxLineWidth = function(line) {
            width = Math.max(width, ctx.measureText(line).width + widthPadding);
          };
          ctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
          helpers.each(model.title, maxLineWidth);
          ctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
          helpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);
          widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
          helpers.each(body, function(bodyItem) {
            helpers.each(bodyItem.before, maxLineWidth);
            helpers.each(bodyItem.lines, maxLineWidth);
            helpers.each(bodyItem.after, maxLineWidth);
          });
          widthPadding = 0;
          ctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
          helpers.each(model.footer, maxLineWidth);
          width += 2 * model.xPadding;
          return {
            width,
            height
          };
        }
        function determineAlignment(tooltip, size) {
          var model = tooltip._model;
          var chart = tooltip._chart;
          var chartArea = tooltip._chart.chartArea;
          var xAlign = "center";
          var yAlign = "center";
          if (model.y < size.height) {
            yAlign = "top";
          } else if (model.y > chart.height - size.height) {
            yAlign = "bottom";
          }
          var lf, rf;
          var olf, orf;
          var yf;
          var midX = (chartArea.left + chartArea.right) / 2;
          var midY = (chartArea.top + chartArea.bottom) / 2;
          if (yAlign === "center") {
            lf = function(x) {
              return x <= midX;
            };
            rf = function(x) {
              return x > midX;
            };
          } else {
            lf = function(x) {
              return x <= size.width / 2;
            };
            rf = function(x) {
              return x >= chart.width - size.width / 2;
            };
          }
          olf = function(x) {
            return x + size.width > chart.width;
          };
          orf = function(x) {
            return x - size.width < 0;
          };
          yf = function(y) {
            return y <= midY ? "top" : "bottom";
          };
          if (lf(model.x)) {
            xAlign = "left";
            if (olf(model.x)) {
              xAlign = "center";
              yAlign = yf(model.y);
            }
          } else if (rf(model.x)) {
            xAlign = "right";
            if (orf(model.x)) {
              xAlign = "center";
              yAlign = yf(model.y);
            }
          }
          var opts = tooltip._options;
          return {
            xAlign: opts.xAlign ? opts.xAlign : xAlign,
            yAlign: opts.yAlign ? opts.yAlign : yAlign
          };
        }
        function getBackgroundPoint(vm, size, alignment) {
          var x = vm.x;
          var y = vm.y;
          var caretSize = vm.caretSize, caretPadding = vm.caretPadding, cornerRadius = vm.cornerRadius, xAlign = alignment.xAlign, yAlign = alignment.yAlign, paddingAndSize = caretSize + caretPadding, radiusAndPadding = cornerRadius + caretPadding;
          if (xAlign === "right") {
            x -= size.width;
          } else if (xAlign === "center") {
            x -= size.width / 2;
          }
          if (yAlign === "top") {
            y += paddingAndSize;
          } else if (yAlign === "bottom") {
            y -= size.height + paddingAndSize;
          } else {
            y -= size.height / 2;
          }
          if (yAlign === "center") {
            if (xAlign === "left") {
              x += paddingAndSize;
            } else if (xAlign === "right") {
              x -= paddingAndSize;
            }
          } else if (xAlign === "left") {
            x -= radiusAndPadding;
          } else if (xAlign === "right") {
            x += radiusAndPadding;
          }
          return {
            x,
            y
          };
        }
        Chart2.Tooltip = Chart2.Element.extend({
          initialize: function() {
            this._model = getBaseModel(this._options);
          },
          // Get the title
          // Args are: (tooltipItem, data)
          getTitle: function() {
            var me = this;
            var opts = me._options;
            var callbacks = opts.callbacks;
            var beforeTitle = callbacks.beforeTitle.apply(me, arguments), title = callbacks.title.apply(me, arguments), afterTitle = callbacks.afterTitle.apply(me, arguments);
            var lines = [];
            lines = pushOrConcat(lines, beforeTitle);
            lines = pushOrConcat(lines, title);
            lines = pushOrConcat(lines, afterTitle);
            return lines;
          },
          // Args are: (tooltipItem, data)
          getBeforeBody: function() {
            var lines = this._options.callbacks.beforeBody.apply(this, arguments);
            return helpers.isArray(lines) ? lines : lines !== void 0 ? [lines] : [];
          },
          // Args are: (tooltipItem, data)
          getBody: function(tooltipItems, data) {
            var me = this;
            var callbacks = me._options.callbacks;
            var bodyItems = [];
            helpers.each(tooltipItems, function(tooltipItem) {
              var bodyItem = {
                before: [],
                lines: [],
                after: []
              };
              pushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));
              pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
              pushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));
              bodyItems.push(bodyItem);
            });
            return bodyItems;
          },
          // Args are: (tooltipItem, data)
          getAfterBody: function() {
            var lines = this._options.callbacks.afterBody.apply(this, arguments);
            return helpers.isArray(lines) ? lines : lines !== void 0 ? [lines] : [];
          },
          // Get the footer and beforeFooter and afterFooter lines
          // Args are: (tooltipItem, data)
          getFooter: function() {
            var me = this;
            var callbacks = me._options.callbacks;
            var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
            var footer = callbacks.footer.apply(me, arguments);
            var afterFooter = callbacks.afterFooter.apply(me, arguments);
            var lines = [];
            lines = pushOrConcat(lines, beforeFooter);
            lines = pushOrConcat(lines, footer);
            lines = pushOrConcat(lines, afterFooter);
            return lines;
          },
          update: function(changed) {
            var me = this;
            var opts = me._options;
            var existingModel = me._model;
            var model = me._model = getBaseModel(opts);
            var active = me._active;
            var data = me._data;
            var alignment = {
              xAlign: existingModel.xAlign,
              yAlign: existingModel.yAlign
            };
            var backgroundPoint = {
              x: existingModel.x,
              y: existingModel.y
            };
            var tooltipSize = {
              width: existingModel.width,
              height: existingModel.height
            };
            var tooltipPosition = {
              x: existingModel.caretX,
              y: existingModel.caretY
            };
            var i2, len;
            if (active.length) {
              model.opacity = 1;
              var labelColors = [];
              tooltipPosition = Chart2.Tooltip.positioners[opts.position](active, me._eventPosition);
              var tooltipItems = [];
              for (i2 = 0, len = active.length; i2 < len; ++i2) {
                tooltipItems.push(createTooltipItem(active[i2]));
              }
              if (opts.filter) {
                tooltipItems = tooltipItems.filter(function(a) {
                  return opts.filter(a, data);
                });
              }
              if (opts.itemSort) {
                tooltipItems = tooltipItems.sort(function(a, b) {
                  return opts.itemSort(a, b, data);
                });
              }
              helpers.each(tooltipItems, function(tooltipItem) {
                labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
              });
              model.title = me.getTitle(tooltipItems, data);
              model.beforeBody = me.getBeforeBody(tooltipItems, data);
              model.body = me.getBody(tooltipItems, data);
              model.afterBody = me.getAfterBody(tooltipItems, data);
              model.footer = me.getFooter(tooltipItems, data);
              model.x = Math.round(tooltipPosition.x);
              model.y = Math.round(tooltipPosition.y);
              model.caretPadding = opts.caretPadding;
              model.labelColors = labelColors;
              model.dataPoints = tooltipItems;
              tooltipSize = getTooltipSize(this, model);
              alignment = determineAlignment(this, tooltipSize);
              backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment);
            } else {
              model.opacity = 0;
            }
            model.xAlign = alignment.xAlign;
            model.yAlign = alignment.yAlign;
            model.x = backgroundPoint.x;
            model.y = backgroundPoint.y;
            model.width = tooltipSize.width;
            model.height = tooltipSize.height;
            model.caretX = tooltipPosition.x;
            model.caretY = tooltipPosition.y;
            me._model = model;
            if (changed && opts.custom) {
              opts.custom.call(me, model);
            }
            return me;
          },
          drawCaret: function(tooltipPoint, size) {
            var ctx = this._chart.ctx;
            var vm = this._view;
            var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);
            ctx.lineTo(caretPosition.x1, caretPosition.y1);
            ctx.lineTo(caretPosition.x2, caretPosition.y2);
            ctx.lineTo(caretPosition.x3, caretPosition.y3);
          },
          getCaretPosition: function(tooltipPoint, size, vm) {
            var x1, x2, x3;
            var y1, y2, y3;
            var caretSize = vm.caretSize;
            var cornerRadius = vm.cornerRadius;
            var xAlign = vm.xAlign, yAlign = vm.yAlign;
            var ptX = tooltipPoint.x, ptY = tooltipPoint.y;
            var width = size.width, height = size.height;
            if (yAlign === "center") {
              y2 = ptY + height / 2;
              if (xAlign === "left") {
                x1 = ptX;
                x2 = x1 - caretSize;
                x3 = x1;
                y1 = y2 + caretSize;
                y3 = y2 - caretSize;
              } else {
                x1 = ptX + width;
                x2 = x1 + caretSize;
                x3 = x1;
                y1 = y2 - caretSize;
                y3 = y2 + caretSize;
              }
            } else {
              if (xAlign === "left") {
                x2 = ptX + cornerRadius + caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              } else if (xAlign === "right") {
                x2 = ptX + width - cornerRadius - caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              } else {
                x2 = ptX + width / 2;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              }
              if (yAlign === "top") {
                y1 = ptY;
                y2 = y1 - caretSize;
                y3 = y1;
              } else {
                y1 = ptY + height;
                y2 = y1 + caretSize;
                y3 = y1;
                var tmp = x3;
                x3 = x1;
                x1 = tmp;
              }
            }
            return { x1, x2, x3, y1, y2, y3 };
          },
          drawTitle: function(pt, vm, ctx, opacity) {
            var title = vm.title;
            if (title.length) {
              ctx.textAlign = vm._titleAlign;
              ctx.textBaseline = "top";
              var titleFontSize = vm.titleFontSize, titleSpacing = vm.titleSpacing;
              ctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);
              ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
              var i2, len;
              for (i2 = 0, len = title.length; i2 < len; ++i2) {
                ctx.fillText(title[i2], pt.x, pt.y);
                pt.y += titleFontSize + titleSpacing;
                if (i2 + 1 === title.length) {
                  pt.y += vm.titleMarginBottom - titleSpacing;
                }
              }
            }
          },
          drawBody: function(pt, vm, ctx, opacity) {
            var bodyFontSize = vm.bodyFontSize;
            var bodySpacing = vm.bodySpacing;
            var body = vm.body;
            ctx.textAlign = vm._bodyAlign;
            ctx.textBaseline = "top";
            var textColor = mergeOpacity(vm.bodyFontColor, opacity);
            ctx.fillStyle = textColor;
            ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
            var xLinePadding = 0;
            var fillLineOfText = function(line) {
              ctx.fillText(line, pt.x + xLinePadding, pt.y);
              pt.y += bodyFontSize + bodySpacing;
            };
            helpers.each(vm.beforeBody, fillLineOfText);
            var drawColorBoxes = vm.displayColors;
            xLinePadding = drawColorBoxes ? bodyFontSize + 2 : 0;
            helpers.each(body, function(bodyItem, i2) {
              helpers.each(bodyItem.before, fillLineOfText);
              helpers.each(bodyItem.lines, function(line) {
                if (drawColorBoxes) {
                  ctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);
                  ctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);
                  ctx.strokeStyle = mergeOpacity(vm.labelColors[i2].borderColor, opacity);
                  ctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);
                  ctx.fillStyle = mergeOpacity(vm.labelColors[i2].backgroundColor, opacity);
                  ctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
                  ctx.fillStyle = textColor;
                }
                fillLineOfText(line);
              });
              helpers.each(bodyItem.after, fillLineOfText);
            });
            xLinePadding = 0;
            helpers.each(vm.afterBody, fillLineOfText);
            pt.y -= bodySpacing;
          },
          drawFooter: function(pt, vm, ctx, opacity) {
            var footer = vm.footer;
            if (footer.length) {
              pt.y += vm.footerMarginTop;
              ctx.textAlign = vm._footerAlign;
              ctx.textBaseline = "top";
              ctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);
              ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
              helpers.each(footer, function(line) {
                ctx.fillText(line, pt.x, pt.y);
                pt.y += vm.footerFontSize + vm.footerSpacing;
              });
            }
          },
          drawBackground: function(pt, vm, ctx, tooltipSize, opacity) {
            ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);
            ctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);
            ctx.lineWidth = vm.borderWidth;
            var xAlign = vm.xAlign;
            var yAlign = vm.yAlign;
            var x = pt.x;
            var y = pt.y;
            var width = tooltipSize.width;
            var height = tooltipSize.height;
            var radius = vm.cornerRadius;
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            if (yAlign === "top") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            if (yAlign === "center" && xAlign === "right") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            if (yAlign === "bottom") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            if (yAlign === "center" && xAlign === "left") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
            if (vm.borderWidth > 0) {
              ctx.stroke();
            }
          },
          draw: function() {
            var ctx = this._chart.ctx;
            var vm = this._view;
            if (vm.opacity === 0) {
              return;
            }
            var tooltipSize = {
              width: vm.width,
              height: vm.height
            };
            var pt = {
              x: vm.x,
              y: vm.y
            };
            var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;
            var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;
            if (this._options.enabled && hasTooltipContent) {
              this.drawBackground(pt, vm, ctx, tooltipSize, opacity);
              pt.x += vm.xPadding;
              pt.y += vm.yPadding;
              this.drawTitle(pt, vm, ctx, opacity);
              this.drawBody(pt, vm, ctx, opacity);
              this.drawFooter(pt, vm, ctx, opacity);
            }
          },
          /**
           * Handle an event
           * @private
           * @param {IEvent} event - The event to handle
           * @returns {Boolean} true if the tooltip changed
           */
          handleEvent: function(e2) {
            var me = this;
            var options = me._options;
            var changed = false;
            me._lastActive = me._lastActive || [];
            if (e2.type === "mouseout") {
              me._active = [];
            } else {
              me._active = me._chart.getElementsAtEventForMode(e2, options.mode, options);
            }
            changed = !helpers.arrayEquals(me._active, me._lastActive);
            if (!changed) {
              return false;
            }
            me._lastActive = me._active;
            if (options.enabled || options.custom) {
              me._eventPosition = {
                x: e2.x,
                y: e2.y
              };
              var model = me._model;
              me.update(true);
              me.pivot();
              changed |= model.x !== me._model.x || model.y !== me._model.y;
            }
            return changed;
          }
        });
        Chart2.Tooltip.positioners = {
          /**
           * Average mode places the tooltip at the average position of the elements shown
           * @function Chart.Tooltip.positioners.average
           * @param elements {ChartElement[]} the elements being displayed in the tooltip
           * @returns {Point} tooltip position
           */
          average: function(elements) {
            if (!elements.length) {
              return false;
            }
            var i2, len;
            var x = 0;
            var y = 0;
            var count = 0;
            for (i2 = 0, len = elements.length; i2 < len; ++i2) {
              var el = elements[i2];
              if (el && el.hasValue()) {
                var pos = el.tooltipPosition();
                x += pos.x;
                y += pos.y;
                ++count;
              }
            }
            return {
              x: Math.round(x / count),
              y: Math.round(y / count)
            };
          },
          /**
           * Gets the tooltip position nearest of the item nearest to the event position
           * @function Chart.Tooltip.positioners.nearest
           * @param elements {Chart.Element[]} the tooltip elements
           * @param eventPosition {Point} the position of the event in canvas coordinates
           * @returns {Point} the tooltip position
           */
          nearest: function(elements, eventPosition) {
            var x = eventPosition.x;
            var y = eventPosition.y;
            var nearestElement;
            var minDistance = Number.POSITIVE_INFINITY;
            var i2, len;
            for (i2 = 0, len = elements.length; i2 < len; ++i2) {
              var el = elements[i2];
              if (el && el.hasValue()) {
                var center = el.getCenterPoint();
                var d = helpers.distanceBetweenPoints(eventPosition, center);
                if (d < minDistance) {
                  minDistance = d;
                  nearestElement = el;
                }
              }
            }
            if (nearestElement) {
              var tp = nearestElement.tooltipPosition();
              x = tp.x;
              y = tp.y;
            }
            return {
              x,
              y
            };
          }
        };
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/elements/element.arc.js
  var require_element_arc = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/elements/element.arc.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers, globalOpts = Chart2.defaults.global;
        globalOpts.elements.arc = {
          backgroundColor: globalOpts.defaultColor,
          borderColor: "#fff",
          borderWidth: 2
        };
        Chart2.elements.Arc = Chart2.Element.extend({
          inLabelRange: function(mouseX) {
            var vm = this._view;
            if (vm) {
              return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
            }
            return false;
          },
          inRange: function(chartX, chartY) {
            var vm = this._view;
            if (vm) {
              var pointRelativePosition = helpers.getAngleFromPoint(vm, {
                x: chartX,
                y: chartY
              }), angle = pointRelativePosition.angle, distance = pointRelativePosition.distance;
              var startAngle = vm.startAngle;
              var endAngle = vm.endAngle;
              while (endAngle < startAngle) {
                endAngle += 2 * Math.PI;
              }
              while (angle > endAngle) {
                angle -= 2 * Math.PI;
              }
              while (angle < startAngle) {
                angle += 2 * Math.PI;
              }
              var betweenAngles = angle >= startAngle && angle <= endAngle, withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;
              return betweenAngles && withinRadius;
            }
            return false;
          },
          getCenterPoint: function() {
            var vm = this._view;
            var halfAngle = (vm.startAngle + vm.endAngle) / 2;
            var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
            return {
              x: vm.x + Math.cos(halfAngle) * halfRadius,
              y: vm.y + Math.sin(halfAngle) * halfRadius
            };
          },
          getArea: function() {
            var vm = this._view;
            return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
          },
          tooltipPosition: function() {
            var vm = this._view;
            var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2, rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
            return {
              x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
              y: vm.y + Math.sin(centreAngle) * rangeFromCentre
            };
          },
          draw: function() {
            var ctx = this._chart.ctx, vm = this._view, sA = vm.startAngle, eA = vm.endAngle;
            ctx.beginPath();
            ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
            ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
            ctx.closePath();
            ctx.strokeStyle = vm.borderColor;
            ctx.lineWidth = vm.borderWidth;
            ctx.fillStyle = vm.backgroundColor;
            ctx.fill();
            ctx.lineJoin = "bevel";
            if (vm.borderWidth) {
              ctx.stroke();
            }
          }
        });
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/elements/element.line.js
  var require_element_line = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/elements/element.line.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        var globalDefaults = Chart2.defaults.global;
        Chart2.defaults.global.elements.line = {
          tension: 0.4,
          backgroundColor: globalDefaults.defaultColor,
          borderWidth: 3,
          borderColor: globalDefaults.defaultColor,
          borderCapStyle: "butt",
          borderDash: [],
          borderDashOffset: 0,
          borderJoinStyle: "miter",
          capBezierPoints: true,
          fill: true
          // do we fill in the area between the line and its base axis
        };
        Chart2.elements.Line = Chart2.Element.extend({
          draw: function() {
            var me = this;
            var vm = me._view;
            var ctx = me._chart.ctx;
            var spanGaps = vm.spanGaps;
            var points = me._children.slice();
            var globalOptionLineElements = globalDefaults.elements.line;
            var lastDrawnIndex = -1;
            var index, current, previous, currentVM;
            if (me._loop && points.length) {
              points.push(points[0]);
            }
            ctx.save();
            ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;
            if (ctx.setLineDash) {
              ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
            }
            ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;
            ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
            ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;
            ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;
            ctx.beginPath();
            lastDrawnIndex = -1;
            for (index = 0; index < points.length; ++index) {
              current = points[index];
              previous = helpers.previousItem(points, index);
              currentVM = current._view;
              if (index === 0) {
                if (!currentVM.skip) {
                  ctx.moveTo(currentVM.x, currentVM.y);
                  lastDrawnIndex = index;
                }
              } else {
                previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];
                if (!currentVM.skip) {
                  if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {
                    ctx.moveTo(currentVM.x, currentVM.y);
                  } else {
                    helpers.canvas.lineTo(ctx, previous._view, current._view);
                  }
                  lastDrawnIndex = index;
                }
              }
            }
            ctx.stroke();
            ctx.restore();
          }
        });
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/elements/element.point.js
  var require_element_point = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/elements/element.point.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers, globalOpts = Chart2.defaults.global, defaultColor = globalOpts.defaultColor;
        globalOpts.elements.point = {
          radius: 3,
          pointStyle: "circle",
          backgroundColor: defaultColor,
          borderWidth: 1,
          borderColor: defaultColor,
          // Hover
          hitRadius: 1,
          hoverRadius: 4,
          hoverBorderWidth: 1
        };
        function xRange(mouseX) {
          var vm = this._view;
          return vm ? Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hitRadius, 2) : false;
        }
        function yRange(mouseY) {
          var vm = this._view;
          return vm ? Math.pow(mouseY - vm.y, 2) < Math.pow(vm.radius + vm.hitRadius, 2) : false;
        }
        Chart2.elements.Point = Chart2.Element.extend({
          inRange: function(mouseX, mouseY) {
            var vm = this._view;
            return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
          },
          inLabelRange: xRange,
          inXRange: xRange,
          inYRange: yRange,
          getCenterPoint: function() {
            var vm = this._view;
            return {
              x: vm.x,
              y: vm.y
            };
          },
          getArea: function() {
            return Math.PI * Math.pow(this._view.radius, 2);
          },
          tooltipPosition: function() {
            var vm = this._view;
            return {
              x: vm.x,
              y: vm.y,
              padding: vm.radius + vm.borderWidth
            };
          },
          draw: function(chartArea) {
            var vm = this._view;
            var model = this._model;
            var ctx = this._chart.ctx;
            var pointStyle = vm.pointStyle;
            var radius = vm.radius;
            var x = vm.x;
            var y = vm.y;
            var color = Chart2.helpers.color;
            var errMargin = 1.01;
            var ratio = 0;
            if (vm.skip) {
              return;
            }
            ctx.strokeStyle = vm.borderColor || defaultColor;
            ctx.lineWidth = helpers.getValueOrDefault(vm.borderWidth, globalOpts.elements.point.borderWidth);
            ctx.fillStyle = vm.backgroundColor || defaultColor;
            if (chartArea !== void 0 && (model.x < chartArea.left || chartArea.right * errMargin < model.x || model.y < chartArea.top || chartArea.bottom * errMargin < model.y)) {
              if (model.x < chartArea.left) {
                ratio = (x - model.x) / (chartArea.left - model.x);
              } else if (chartArea.right * errMargin < model.x) {
                ratio = (model.x - x) / (model.x - chartArea.right);
              } else if (model.y < chartArea.top) {
                ratio = (y - model.y) / (chartArea.top - model.y);
              } else if (chartArea.bottom * errMargin < model.y) {
                ratio = (model.y - y) / (model.y - chartArea.bottom);
              }
              ratio = Math.round(ratio * 100) / 100;
              ctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();
              ctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();
            }
            Chart2.canvasHelpers.drawPoint(ctx, pointStyle, radius, x, y);
          }
        });
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/elements/element.rectangle.js
  var require_element_rectangle = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/elements/element.rectangle.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var globalOpts = Chart2.defaults.global;
        globalOpts.elements.rectangle = {
          backgroundColor: globalOpts.defaultColor,
          borderWidth: 0,
          borderColor: globalOpts.defaultColor,
          borderSkipped: "bottom"
        };
        function isVertical(bar) {
          return bar._view.width !== void 0;
        }
        function getBarBounds(bar) {
          var vm = bar._view;
          var x1, x2, y1, y2;
          if (isVertical(bar)) {
            var halfWidth = vm.width / 2;
            x1 = vm.x - halfWidth;
            x2 = vm.x + halfWidth;
            y1 = Math.min(vm.y, vm.base);
            y2 = Math.max(vm.y, vm.base);
          } else {
            var halfHeight = vm.height / 2;
            x1 = Math.min(vm.x, vm.base);
            x2 = Math.max(vm.x, vm.base);
            y1 = vm.y - halfHeight;
            y2 = vm.y + halfHeight;
          }
          return {
            left: x1,
            top: y1,
            right: x2,
            bottom: y2
          };
        }
        Chart2.elements.Rectangle = Chart2.Element.extend({
          draw: function() {
            var ctx = this._chart.ctx;
            var vm = this._view;
            var left, right, top, bottom, signX, signY, borderSkipped;
            var borderWidth = vm.borderWidth;
            if (!vm.horizontal) {
              left = vm.x - vm.width / 2;
              right = vm.x + vm.width / 2;
              top = vm.y;
              bottom = vm.base;
              signX = 1;
              signY = bottom > top ? 1 : -1;
              borderSkipped = vm.borderSkipped || "bottom";
            } else {
              left = vm.base;
              right = vm.x;
              top = vm.y - vm.height / 2;
              bottom = vm.y + vm.height / 2;
              signX = right > left ? 1 : -1;
              signY = 1;
              borderSkipped = vm.borderSkipped || "left";
            }
            if (borderWidth) {
              var barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));
              borderWidth = borderWidth > barSize ? barSize : borderWidth;
              var halfStroke = borderWidth / 2;
              var borderLeft = left + (borderSkipped !== "left" ? halfStroke * signX : 0);
              var borderRight = right + (borderSkipped !== "right" ? -halfStroke * signX : 0);
              var borderTop = top + (borderSkipped !== "top" ? halfStroke * signY : 0);
              var borderBottom = bottom + (borderSkipped !== "bottom" ? -halfStroke * signY : 0);
              if (borderLeft !== borderRight) {
                top = borderTop;
                bottom = borderBottom;
              }
              if (borderTop !== borderBottom) {
                left = borderLeft;
                right = borderRight;
              }
            }
            ctx.beginPath();
            ctx.fillStyle = vm.backgroundColor;
            ctx.strokeStyle = vm.borderColor;
            ctx.lineWidth = borderWidth;
            var corners = [
              [left, bottom],
              [left, top],
              [right, top],
              [right, bottom]
            ];
            var borders = ["bottom", "left", "top", "right"];
            var startCorner = borders.indexOf(borderSkipped, 0);
            if (startCorner === -1) {
              startCorner = 0;
            }
            function cornerAt(index) {
              return corners[(startCorner + index) % 4];
            }
            var corner = cornerAt(0);
            ctx.moveTo(corner[0], corner[1]);
            for (var i2 = 1; i2 < 4; i2++) {
              corner = cornerAt(i2);
              ctx.lineTo(corner[0], corner[1]);
            }
            ctx.fill();
            if (borderWidth) {
              ctx.stroke();
            }
          },
          height: function() {
            var vm = this._view;
            return vm.base - vm.y;
          },
          inRange: function(mouseX, mouseY) {
            var inRange = false;
            if (this._view) {
              var bounds = getBarBounds(this);
              inRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;
            }
            return inRange;
          },
          inLabelRange: function(mouseX, mouseY) {
            var me = this;
            if (!me._view) {
              return false;
            }
            var inRange = false;
            var bounds = getBarBounds(me);
            if (isVertical(me)) {
              inRange = mouseX >= bounds.left && mouseX <= bounds.right;
            } else {
              inRange = mouseY >= bounds.top && mouseY <= bounds.bottom;
            }
            return inRange;
          },
          inXRange: function(mouseX) {
            var bounds = getBarBounds(this);
            return mouseX >= bounds.left && mouseX <= bounds.right;
          },
          inYRange: function(mouseY) {
            var bounds = getBarBounds(this);
            return mouseY >= bounds.top && mouseY <= bounds.bottom;
          },
          getCenterPoint: function() {
            var vm = this._view;
            var x, y;
            if (isVertical(this)) {
              x = vm.x;
              y = (vm.y + vm.base) / 2;
            } else {
              x = (vm.x + vm.base) / 2;
              y = vm.y;
            }
            return { x, y };
          },
          getArea: function() {
            var vm = this._view;
            return vm.width * Math.abs(vm.y - vm.base);
          },
          tooltipPosition: function() {
            var vm = this._view;
            return {
              x: vm.x,
              y: vm.y
            };
          }
        });
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/scales/scale.linearbase.js
  var require_scale_linearbase = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/scales/scale.linearbase.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers, noop2 = helpers.noop;
        Chart2.LinearScaleBase = Chart2.Scale.extend({
          handleTickRangeOptions: function() {
            var me = this;
            var opts = me.options;
            var tickOpts = opts.ticks;
            if (tickOpts.beginAtZero) {
              var minSign = helpers.sign(me.min);
              var maxSign = helpers.sign(me.max);
              if (minSign < 0 && maxSign < 0) {
                me.max = 0;
              } else if (minSign > 0 && maxSign > 0) {
                me.min = 0;
              }
            }
            if (tickOpts.min !== void 0) {
              me.min = tickOpts.min;
            } else if (tickOpts.suggestedMin !== void 0) {
              if (me.min === null) {
                me.min = tickOpts.suggestedMin;
              } else {
                me.min = Math.min(me.min, tickOpts.suggestedMin);
              }
            }
            if (tickOpts.max !== void 0) {
              me.max = tickOpts.max;
            } else if (tickOpts.suggestedMax !== void 0) {
              if (me.max === null) {
                me.max = tickOpts.suggestedMax;
              } else {
                me.max = Math.max(me.max, tickOpts.suggestedMax);
              }
            }
            if (me.min === me.max) {
              me.max++;
              if (!tickOpts.beginAtZero) {
                me.min--;
              }
            }
          },
          getTickLimit: noop2,
          handleDirectionalChanges: noop2,
          buildTicks: function() {
            var me = this;
            var opts = me.options;
            var tickOpts = opts.ticks;
            var maxTicks = me.getTickLimit();
            maxTicks = Math.max(2, maxTicks);
            var numericGeneratorOptions = {
              maxTicks,
              min: tickOpts.min,
              max: tickOpts.max,
              stepSize: helpers.getValueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
            };
            var ticks = me.ticks = Chart2.Ticks.generators.linear(numericGeneratorOptions, me);
            me.handleDirectionalChanges();
            me.max = helpers.max(ticks);
            me.min = helpers.min(ticks);
            if (tickOpts.reverse) {
              ticks.reverse();
              me.start = me.max;
              me.end = me.min;
            } else {
              me.start = me.min;
              me.end = me.max;
            }
          },
          convertTicksToLabels: function() {
            var me = this;
            me.ticksAsNumbers = me.ticks.slice();
            me.zeroLineIndex = me.ticks.indexOf(0);
            Chart2.Scale.prototype.convertTicksToLabels.call(me);
          }
        });
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/scales/scale.category.js
  var require_scale_category = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/scales/scale.category.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        var defaultConfig = {
          position: "bottom"
        };
        var DatasetScale = Chart2.Scale.extend({
          /**
          * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
          * else fall back to data.labels
          * @private
          */
          getLabels: function() {
            var data = this.chart.data;
            return (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
          },
          determineDataLimits: function() {
            var me = this;
            var labels = me.getLabels();
            me.minIndex = 0;
            me.maxIndex = labels.length - 1;
            var findIndex;
            if (me.options.ticks.min !== void 0) {
              findIndex = helpers.indexOf(labels, me.options.ticks.min);
              me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
            }
            if (me.options.ticks.max !== void 0) {
              findIndex = helpers.indexOf(labels, me.options.ticks.max);
              me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
            }
            me.min = labels[me.minIndex];
            me.max = labels[me.maxIndex];
          },
          buildTicks: function() {
            var me = this;
            var labels = me.getLabels();
            me.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
          },
          getLabelForIndex: function(index, datasetIndex) {
            var me = this;
            var data = me.chart.data;
            var isHorizontal = me.isHorizontal();
            if (data.yLabels && !isHorizontal) {
              return me.getRightValue(data.datasets[datasetIndex].data[index]);
            }
            return me.ticks[index - me.minIndex];
          },
          // Used to get data value locations.  Value can either be an index or a numerical value
          getPixelForValue: function(value, index, datasetIndex, includeOffset) {
            var me = this;
            var offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (me.options.gridLines.offsetGridLines ? 0 : 1), 1);
            var valueCategory;
            if (value !== void 0 && value !== null) {
              valueCategory = me.isHorizontal() ? value.x : value.y;
            }
            if (valueCategory !== void 0 || value !== void 0 && isNaN(index)) {
              var labels = me.getLabels();
              value = valueCategory || value;
              var idx = labels.indexOf(value);
              index = idx !== -1 ? idx : index;
            }
            if (me.isHorizontal()) {
              var valueWidth = me.width / offsetAmt;
              var widthOffset = valueWidth * (index - me.minIndex);
              if (me.options.gridLines.offsetGridLines && includeOffset || me.maxIndex === me.minIndex && includeOffset) {
                widthOffset += valueWidth / 2;
              }
              return me.left + Math.round(widthOffset);
            }
            var valueHeight = me.height / offsetAmt;
            var heightOffset = valueHeight * (index - me.minIndex);
            if (me.options.gridLines.offsetGridLines && includeOffset) {
              heightOffset += valueHeight / 2;
            }
            return me.top + Math.round(heightOffset);
          },
          getPixelForTick: function(index, includeOffset) {
            return this.getPixelForValue(this.ticks[index], index + this.minIndex, null, includeOffset);
          },
          getValueForPixel: function(pixel) {
            var me = this;
            var value;
            var offsetAmt = Math.max(me.ticks.length - (me.options.gridLines.offsetGridLines ? 0 : 1), 1);
            var horz = me.isHorizontal();
            var valueDimension = (horz ? me.width : me.height) / offsetAmt;
            pixel -= horz ? me.left : me.top;
            if (me.options.gridLines.offsetGridLines) {
              pixel -= valueDimension / 2;
            }
            if (pixel <= 0) {
              value = 0;
            } else {
              value = Math.round(pixel / valueDimension);
            }
            return value;
          },
          getBasePixel: function() {
            return this.bottom;
          }
        });
        Chart2.scaleService.registerScaleType("category", DatasetScale, defaultConfig);
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/scales/scale.linear.js
  var require_scale_linear = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/scales/scale.linear.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        var defaultConfig = {
          position: "left",
          ticks: {
            callback: Chart2.Ticks.formatters.linear
          }
        };
        var LinearScale = Chart2.LinearScaleBase.extend({
          determineDataLimits: function() {
            var me = this;
            var opts = me.options;
            var chart = me.chart;
            var data = chart.data;
            var datasets = data.datasets;
            var isHorizontal = me.isHorizontal();
            var DEFAULT_MIN = 0;
            var DEFAULT_MAX = 1;
            function IDMatches(meta) {
              return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
            }
            me.min = null;
            me.max = null;
            var hasStacks = opts.stacked;
            if (hasStacks === void 0) {
              helpers.each(datasets, function(dataset, datasetIndex) {
                if (hasStacks) {
                  return;
                }
                var meta = chart.getDatasetMeta(datasetIndex);
                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== void 0) {
                  hasStacks = true;
                }
              });
            }
            if (opts.stacked || hasStacks) {
              var valuesPerStack = {};
              helpers.each(datasets, function(dataset, datasetIndex) {
                var meta = chart.getDatasetMeta(datasetIndex);
                var key = [
                  meta.type,
                  // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
                  opts.stacked === void 0 && meta.stack === void 0 ? datasetIndex : "",
                  meta.stack
                ].join(".");
                if (valuesPerStack[key] === void 0) {
                  valuesPerStack[key] = {
                    positiveValues: [],
                    negativeValues: []
                  };
                }
                var positiveValues = valuesPerStack[key].positiveValues;
                var negativeValues = valuesPerStack[key].negativeValues;
                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                  helpers.each(dataset.data, function(rawValue, index) {
                    var value = +me.getRightValue(rawValue);
                    if (isNaN(value) || meta.data[index].hidden) {
                      return;
                    }
                    positiveValues[index] = positiveValues[index] || 0;
                    negativeValues[index] = negativeValues[index] || 0;
                    if (opts.relativePoints) {
                      positiveValues[index] = 100;
                    } else if (value < 0) {
                      negativeValues[index] += value;
                    } else {
                      positiveValues[index] += value;
                    }
                  });
                }
              });
              helpers.each(valuesPerStack, function(valuesForType) {
                var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
                var minVal = helpers.min(values);
                var maxVal = helpers.max(values);
                me.min = me.min === null ? minVal : Math.min(me.min, minVal);
                me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
              });
            } else {
              helpers.each(datasets, function(dataset, datasetIndex) {
                var meta = chart.getDatasetMeta(datasetIndex);
                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                  helpers.each(dataset.data, function(rawValue, index) {
                    var value = +me.getRightValue(rawValue);
                    if (isNaN(value) || meta.data[index].hidden) {
                      return;
                    }
                    if (me.min === null) {
                      me.min = value;
                    } else if (value < me.min) {
                      me.min = value;
                    }
                    if (me.max === null) {
                      me.max = value;
                    } else if (value > me.max) {
                      me.max = value;
                    }
                  });
                }
              });
            }
            me.min = isFinite(me.min) ? me.min : DEFAULT_MIN;
            me.max = isFinite(me.max) ? me.max : DEFAULT_MAX;
            this.handleTickRangeOptions();
          },
          getTickLimit: function() {
            var maxTicks;
            var me = this;
            var tickOpts = me.options.ticks;
            if (me.isHorizontal()) {
              maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));
            } else {
              var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, Chart2.defaults.global.defaultFontSize);
              maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));
            }
            return maxTicks;
          },
          // Called after the ticks are built. We need
          handleDirectionalChanges: function() {
            if (!this.isHorizontal()) {
              this.ticks.reverse();
            }
          },
          getLabelForIndex: function(index, datasetIndex) {
            return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
          },
          // Utils
          getPixelForValue: function(value) {
            var me = this;
            var start = me.start;
            var rightValue = +me.getRightValue(value);
            var pixel;
            var range = me.end - start;
            if (me.isHorizontal()) {
              pixel = me.left + me.width / range * (rightValue - start);
              return Math.round(pixel);
            }
            pixel = me.bottom - me.height / range * (rightValue - start);
            return Math.round(pixel);
          },
          getValueForPixel: function(pixel) {
            var me = this;
            var isHorizontal = me.isHorizontal();
            var innerDimension = isHorizontal ? me.width : me.height;
            var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
            return me.start + (me.end - me.start) * offset;
          },
          getPixelForTick: function(index) {
            return this.getPixelForValue(this.ticksAsNumbers[index]);
          }
        });
        Chart2.scaleService.registerScaleType("linear", LinearScale, defaultConfig);
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/scales/scale.logarithmic.js
  var require_scale_logarithmic = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/scales/scale.logarithmic.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        var defaultConfig = {
          position: "left",
          // label settings
          ticks: {
            callback: Chart2.Ticks.formatters.logarithmic
          }
        };
        var LogarithmicScale = Chart2.Scale.extend({
          determineDataLimits: function() {
            var me = this;
            var opts = me.options;
            var tickOpts = opts.ticks;
            var chart = me.chart;
            var data = chart.data;
            var datasets = data.datasets;
            var getValueOrDefault = helpers.getValueOrDefault;
            var isHorizontal = me.isHorizontal();
            function IDMatches(meta) {
              return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
            }
            me.min = null;
            me.max = null;
            me.minNotZero = null;
            var hasStacks = opts.stacked;
            if (hasStacks === void 0) {
              helpers.each(datasets, function(dataset, datasetIndex) {
                if (hasStacks) {
                  return;
                }
                var meta = chart.getDatasetMeta(datasetIndex);
                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== void 0) {
                  hasStacks = true;
                }
              });
            }
            if (opts.stacked || hasStacks) {
              var valuesPerStack = {};
              helpers.each(datasets, function(dataset, datasetIndex) {
                var meta = chart.getDatasetMeta(datasetIndex);
                var key = [
                  meta.type,
                  // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
                  opts.stacked === void 0 && meta.stack === void 0 ? datasetIndex : "",
                  meta.stack
                ].join(".");
                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                  if (valuesPerStack[key] === void 0) {
                    valuesPerStack[key] = [];
                  }
                  helpers.each(dataset.data, function(rawValue, index) {
                    var values = valuesPerStack[key];
                    var value = +me.getRightValue(rawValue);
                    if (isNaN(value) || meta.data[index].hidden) {
                      return;
                    }
                    values[index] = values[index] || 0;
                    if (opts.relativePoints) {
                      values[index] = 100;
                    } else {
                      values[index] += value;
                    }
                  });
                }
              });
              helpers.each(valuesPerStack, function(valuesForType) {
                var minVal = helpers.min(valuesForType);
                var maxVal = helpers.max(valuesForType);
                me.min = me.min === null ? minVal : Math.min(me.min, minVal);
                me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
              });
            } else {
              helpers.each(datasets, function(dataset, datasetIndex) {
                var meta = chart.getDatasetMeta(datasetIndex);
                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                  helpers.each(dataset.data, function(rawValue, index) {
                    var value = +me.getRightValue(rawValue);
                    if (isNaN(value) || meta.data[index].hidden) {
                      return;
                    }
                    if (me.min === null) {
                      me.min = value;
                    } else if (value < me.min) {
                      me.min = value;
                    }
                    if (me.max === null) {
                      me.max = value;
                    } else if (value > me.max) {
                      me.max = value;
                    }
                    if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
                      me.minNotZero = value;
                    }
                  });
                }
              });
            }
            me.min = getValueOrDefault(tickOpts.min, me.min);
            me.max = getValueOrDefault(tickOpts.max, me.max);
            if (me.min === me.max) {
              if (me.min !== 0 && me.min !== null) {
                me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);
                me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);
              } else {
                me.min = 1;
                me.max = 10;
              }
            }
          },
          buildTicks: function() {
            var me = this;
            var opts = me.options;
            var tickOpts = opts.ticks;
            var generationOptions = {
              min: tickOpts.min,
              max: tickOpts.max
            };
            var ticks = me.ticks = Chart2.Ticks.generators.logarithmic(generationOptions, me);
            if (!me.isHorizontal()) {
              ticks.reverse();
            }
            me.max = helpers.max(ticks);
            me.min = helpers.min(ticks);
            if (tickOpts.reverse) {
              ticks.reverse();
              me.start = me.max;
              me.end = me.min;
            } else {
              me.start = me.min;
              me.end = me.max;
            }
          },
          convertTicksToLabels: function() {
            this.tickValues = this.ticks.slice();
            Chart2.Scale.prototype.convertTicksToLabels.call(this);
          },
          // Get the correct tooltip label
          getLabelForIndex: function(index, datasetIndex) {
            return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
          },
          getPixelForTick: function(index) {
            return this.getPixelForValue(this.tickValues[index]);
          },
          getPixelForValue: function(value) {
            var me = this;
            var innerDimension;
            var pixel;
            var start = me.start;
            var newVal = +me.getRightValue(value);
            var range;
            var opts = me.options;
            var tickOpts = opts.ticks;
            if (me.isHorizontal()) {
              range = helpers.log10(me.end) - helpers.log10(start);
              if (newVal === 0) {
                pixel = me.left;
              } else {
                innerDimension = me.width;
                pixel = me.left + innerDimension / range * (helpers.log10(newVal) - helpers.log10(start));
              }
            } else {
              innerDimension = me.height;
              if (start === 0 && !tickOpts.reverse) {
                range = helpers.log10(me.end) - helpers.log10(me.minNotZero);
                if (newVal === start) {
                  pixel = me.bottom;
                } else if (newVal === me.minNotZero) {
                  pixel = me.bottom - innerDimension * 0.02;
                } else {
                  pixel = me.bottom - innerDimension * 0.02 - innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero));
                }
              } else if (me.end === 0 && tickOpts.reverse) {
                range = helpers.log10(me.start) - helpers.log10(me.minNotZero);
                if (newVal === me.end) {
                  pixel = me.top;
                } else if (newVal === me.minNotZero) {
                  pixel = me.top + innerDimension * 0.02;
                } else {
                  pixel = me.top + innerDimension * 0.02 + innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero));
                }
              } else if (newVal === 0) {
                pixel = tickOpts.reverse ? me.top : me.bottom;
              } else {
                range = helpers.log10(me.end) - helpers.log10(start);
                innerDimension = me.height;
                pixel = me.bottom - innerDimension / range * (helpers.log10(newVal) - helpers.log10(start));
              }
            }
            return pixel;
          },
          getValueForPixel: function(pixel) {
            var me = this;
            var range = helpers.log10(me.end) - helpers.log10(me.start);
            var value, innerDimension;
            if (me.isHorizontal()) {
              innerDimension = me.width;
              value = me.start * Math.pow(10, (pixel - me.left) * range / innerDimension);
            } else {
              innerDimension = me.height;
              value = Math.pow(10, (me.bottom - pixel) * range / innerDimension) / me.start;
            }
            return value;
          }
        });
        Chart2.scaleService.registerScaleType("logarithmic", LogarithmicScale, defaultConfig);
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/scales/scale.radialLinear.js
  var require_scale_radialLinear = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/scales/scale.radialLinear.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        var globalDefaults = Chart2.defaults.global;
        var defaultConfig = {
          display: true,
          // Boolean - Whether to animate scaling the chart from the centre
          animate: true,
          position: "chartArea",
          angleLines: {
            display: true,
            color: "rgba(0, 0, 0, 0.1)",
            lineWidth: 1
          },
          gridLines: {
            circular: false
          },
          // label settings
          ticks: {
            // Boolean - Show a backdrop to the scale label
            showLabelBackdrop: true,
            // String - The colour of the label backdrop
            backdropColor: "rgba(255,255,255,0.75)",
            // Number - The backdrop padding above & below the label in pixels
            backdropPaddingY: 2,
            // Number - The backdrop padding to the side of the label in pixels
            backdropPaddingX: 2,
            callback: Chart2.Ticks.formatters.linear
          },
          pointLabels: {
            // Boolean - if true, show point labels
            display: true,
            // Number - Point label font size in pixels
            fontSize: 10,
            // Function - Used to convert point labels
            callback: function(label) {
              return label;
            }
          }
        };
        function getValueCount(scale) {
          var opts = scale.options;
          return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
        }
        function getPointLabelFontOptions(scale) {
          var pointLabelOptions = scale.options.pointLabels;
          var fontSize = helpers.getValueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);
          var fontStyle = helpers.getValueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);
          var fontFamily = helpers.getValueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);
          var font = helpers.fontString(fontSize, fontStyle, fontFamily);
          return {
            size: fontSize,
            style: fontStyle,
            family: fontFamily,
            font
          };
        }
        function measureLabelSize(ctx, fontSize, label) {
          if (helpers.isArray(label)) {
            return {
              w: helpers.longestText(ctx, ctx.font, label),
              h: label.length * fontSize + (label.length - 1) * 1.5 * fontSize
            };
          }
          return {
            w: ctx.measureText(label).width,
            h: fontSize
          };
        }
        function determineLimits(angle, pos, size, min, max) {
          if (angle === min || angle === max) {
            return {
              start: pos - size / 2,
              end: pos + size / 2
            };
          } else if (angle < min || angle > max) {
            return {
              start: pos - size - 5,
              end: pos
            };
          }
          return {
            start: pos,
            end: pos + size + 5
          };
        }
        function fitWithPointLabels(scale) {
          var plFont = getPointLabelFontOptions(scale);
          var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
          var furthestLimits = {
            r: scale.width,
            l: 0,
            t: scale.height,
            b: 0
          };
          var furthestAngles = {};
          var i2;
          var textSize;
          var pointPosition;
          scale.ctx.font = plFont.font;
          scale._pointLabelSizes = [];
          var valueCount = getValueCount(scale);
          for (i2 = 0; i2 < valueCount; i2++) {
            pointPosition = scale.getPointPosition(i2, largestPossibleRadius);
            textSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i2] || "");
            scale._pointLabelSizes[i2] = textSize;
            var angleRadians = scale.getIndexAngle(i2);
            var angle = helpers.toDegrees(angleRadians) % 360;
            var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
            var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
            if (hLimits.start < furthestLimits.l) {
              furthestLimits.l = hLimits.start;
              furthestAngles.l = angleRadians;
            }
            if (hLimits.end > furthestLimits.r) {
              furthestLimits.r = hLimits.end;
              furthestAngles.r = angleRadians;
            }
            if (vLimits.start < furthestLimits.t) {
              furthestLimits.t = vLimits.start;
              furthestAngles.t = angleRadians;
            }
            if (vLimits.end > furthestLimits.b) {
              furthestLimits.b = vLimits.end;
              furthestAngles.b = angleRadians;
            }
          }
          scale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);
        }
        function fit(scale) {
          var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
          scale.drawingArea = Math.round(largestPossibleRadius);
          scale.setCenterPoint(0, 0, 0, 0);
        }
        function getTextAlignForAngle(angle) {
          if (angle === 0 || angle === 180) {
            return "center";
          } else if (angle < 180) {
            return "left";
          }
          return "right";
        }
        function fillText(ctx, text2, position, fontSize) {
          if (helpers.isArray(text2)) {
            var y = position.y;
            var spacing = 1.5 * fontSize;
            for (var i2 = 0; i2 < text2.length; ++i2) {
              ctx.fillText(text2[i2], position.x, y);
              y += spacing;
            }
          } else {
            ctx.fillText(text2, position.x, position.y);
          }
        }
        function adjustPointPositionForLabelHeight(angle, textSize, position) {
          if (angle === 90 || angle === 270) {
            position.y -= textSize.h / 2;
          } else if (angle > 270 || angle < 90) {
            position.y -= textSize.h;
          }
        }
        function drawPointLabels(scale) {
          var ctx = scale.ctx;
          var getValueOrDefault = helpers.getValueOrDefault;
          var opts = scale.options;
          var angleLineOpts = opts.angleLines;
          var pointLabelOpts = opts.pointLabels;
          ctx.lineWidth = angleLineOpts.lineWidth;
          ctx.strokeStyle = angleLineOpts.color;
          var outerDistance = scale.getDistanceFromCenterForValue(opts.reverse ? scale.min : scale.max);
          var plFont = getPointLabelFontOptions(scale);
          ctx.textBaseline = "top";
          for (var i2 = getValueCount(scale) - 1; i2 >= 0; i2--) {
            if (angleLineOpts.display) {
              var outerPosition = scale.getPointPosition(i2, outerDistance);
              ctx.beginPath();
              ctx.moveTo(scale.xCenter, scale.yCenter);
              ctx.lineTo(outerPosition.x, outerPosition.y);
              ctx.stroke();
              ctx.closePath();
            }
            if (pointLabelOpts.display) {
              var pointLabelPosition = scale.getPointPosition(i2, outerDistance + 5);
              var pointLabelFontColor = getValueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);
              ctx.font = plFont.font;
              ctx.fillStyle = pointLabelFontColor;
              var angleRadians = scale.getIndexAngle(i2);
              var angle = helpers.toDegrees(angleRadians);
              ctx.textAlign = getTextAlignForAngle(angle);
              adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i2], pointLabelPosition);
              fillText(ctx, scale.pointLabels[i2] || "", pointLabelPosition, plFont.size);
            }
          }
        }
        function drawRadiusLine(scale, gridLineOpts, radius, index) {
          var ctx = scale.ctx;
          ctx.strokeStyle = helpers.getValueAtIndexOrDefault(gridLineOpts.color, index - 1);
          ctx.lineWidth = helpers.getValueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);
          if (scale.options.gridLines.circular) {
            ctx.beginPath();
            ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
            ctx.closePath();
            ctx.stroke();
          } else {
            var valueCount = getValueCount(scale);
            if (valueCount === 0) {
              return;
            }
            ctx.beginPath();
            var pointPosition = scale.getPointPosition(0, radius);
            ctx.moveTo(pointPosition.x, pointPosition.y);
            for (var i2 = 1; i2 < valueCount; i2++) {
              pointPosition = scale.getPointPosition(i2, radius);
              ctx.lineTo(pointPosition.x, pointPosition.y);
            }
            ctx.closePath();
            ctx.stroke();
          }
        }
        function numberOrZero(param) {
          return helpers.isNumber(param) ? param : 0;
        }
        var LinearRadialScale = Chart2.LinearScaleBase.extend({
          setDimensions: function() {
            var me = this;
            var opts = me.options;
            var tickOpts = opts.ticks;
            me.width = me.maxWidth;
            me.height = me.maxHeight;
            me.xCenter = Math.round(me.width / 2);
            me.yCenter = Math.round(me.height / 2);
            var minSize = helpers.min([me.height, me.width]);
            var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
            me.drawingArea = opts.display ? minSize / 2 - (tickFontSize / 2 + tickOpts.backdropPaddingY) : minSize / 2;
          },
          determineDataLimits: function() {
            var me = this;
            var chart = me.chart;
            var min = Number.POSITIVE_INFINITY;
            var max = Number.NEGATIVE_INFINITY;
            helpers.each(chart.data.datasets, function(dataset, datasetIndex) {
              if (chart.isDatasetVisible(datasetIndex)) {
                var meta = chart.getDatasetMeta(datasetIndex);
                helpers.each(dataset.data, function(rawValue, index) {
                  var value = +me.getRightValue(rawValue);
                  if (isNaN(value) || meta.data[index].hidden) {
                    return;
                  }
                  min = Math.min(value, min);
                  max = Math.max(value, max);
                });
              }
            });
            me.min = min === Number.POSITIVE_INFINITY ? 0 : min;
            me.max = max === Number.NEGATIVE_INFINITY ? 0 : max;
            me.handleTickRangeOptions();
          },
          getTickLimit: function() {
            var tickOpts = this.options.ticks;
            var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
            return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));
          },
          convertTicksToLabels: function() {
            var me = this;
            Chart2.LinearScaleBase.prototype.convertTicksToLabels.call(me);
            me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
          },
          getLabelForIndex: function(index, datasetIndex) {
            return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
          },
          fit: function() {
            if (this.options.pointLabels.display) {
              fitWithPointLabels(this);
            } else {
              fit(this);
            }
          },
          /**
           * Set radius reductions and determine new radius and center point
           * @private
           */
          setReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {
            var me = this;
            var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
            var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
            var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
            var radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);
            radiusReductionLeft = numberOrZero(radiusReductionLeft);
            radiusReductionRight = numberOrZero(radiusReductionRight);
            radiusReductionTop = numberOrZero(radiusReductionTop);
            radiusReductionBottom = numberOrZero(radiusReductionBottom);
            me.drawingArea = Math.min(
              Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),
              Math.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2)
            );
            me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
          },
          setCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {
            var me = this;
            var maxRight = me.width - rightMovement - me.drawingArea, maxLeft = leftMovement + me.drawingArea, maxTop = topMovement + me.drawingArea, maxBottom = me.height - bottomMovement - me.drawingArea;
            me.xCenter = Math.round((maxLeft + maxRight) / 2 + me.left);
            me.yCenter = Math.round((maxTop + maxBottom) / 2 + me.top);
          },
          getIndexAngle: function(index) {
            var angleMultiplier = Math.PI * 2 / getValueCount(this);
            var startAngle = this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0;
            var startAngleRadians = startAngle * Math.PI * 2 / 360;
            return index * angleMultiplier + startAngleRadians;
          },
          getDistanceFromCenterForValue: function(value) {
            var me = this;
            if (value === null) {
              return 0;
            }
            var scalingFactor = me.drawingArea / (me.max - me.min);
            if (me.options.reverse) {
              return (me.max - value) * scalingFactor;
            }
            return (value - me.min) * scalingFactor;
          },
          getPointPosition: function(index, distanceFromCenter) {
            var me = this;
            var thisAngle = me.getIndexAngle(index) - Math.PI / 2;
            return {
              x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,
              y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter
            };
          },
          getPointPositionForValue: function(index, value) {
            return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
          },
          getBasePosition: function() {
            var me = this;
            var min = me.min;
            var max = me.max;
            return me.getPointPositionForValue(
              0,
              me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0
            );
          },
          draw: function() {
            var me = this;
            var opts = me.options;
            var gridLineOpts = opts.gridLines;
            var tickOpts = opts.ticks;
            var getValueOrDefault = helpers.getValueOrDefault;
            if (opts.display) {
              var ctx = me.ctx;
              var tickFontSize = getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
              var tickFontStyle = getValueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);
              var tickFontFamily = getValueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);
              var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
              helpers.each(me.ticks, function(label, index) {
                if (index > 0 || opts.reverse) {
                  var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);
                  var yHeight = me.yCenter - yCenterOffset;
                  if (gridLineOpts.display && index !== 0) {
                    drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
                  }
                  if (tickOpts.display) {
                    var tickFontColor = getValueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);
                    ctx.font = tickLabelFont;
                    if (tickOpts.showLabelBackdrop) {
                      var labelWidth = ctx.measureText(label).width;
                      ctx.fillStyle = tickOpts.backdropColor;
                      ctx.fillRect(
                        me.xCenter - labelWidth / 2 - tickOpts.backdropPaddingX,
                        yHeight - tickFontSize / 2 - tickOpts.backdropPaddingY,
                        labelWidth + tickOpts.backdropPaddingX * 2,
                        tickFontSize + tickOpts.backdropPaddingY * 2
                      );
                    }
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillStyle = tickFontColor;
                    ctx.fillText(label, me.xCenter, yHeight);
                  }
                }
              });
              if (opts.angleLines.display || opts.pointLabels.display) {
                drawPointLabels(me);
              }
            }
          }
        });
        Chart2.scaleService.registerScaleType("radialLinear", LinearRadialScale, defaultConfig);
      };
    }
  });

  // node_modules/.pnpm/moment@2.30.1/node_modules/moment/moment.js
  var require_moment = __commonJS({
    "node_modules/.pnpm/moment@2.30.1/node_modules/moment/moment.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.moment = factory();
      })(exports, function() {
        "use strict";
        var hookCallback;
        function hooks() {
          return hookCallback.apply(null, arguments);
        }
        function setHookCallback(callback) {
          hookCallback = callback;
        }
        function isArray(input) {
          return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
        }
        function isObject(input) {
          return input != null && Object.prototype.toString.call(input) === "[object Object]";
        }
        function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
        }
        function isObjectEmpty(obj) {
          if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
          } else {
            var k;
            for (k in obj) {
              if (hasOwnProp(obj, k)) {
                return false;
              }
            }
            return true;
          }
        }
        function isUndefined(input) {
          return input === void 0;
        }
        function isNumber(input) {
          return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
        }
        function isDate(input) {
          return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
        }
        function map(arr, fn) {
          var res = [], i2, arrLen = arr.length;
          for (i2 = 0; i2 < arrLen; ++i2) {
            res.push(fn(arr[i2], i2));
          }
          return res;
        }
        function extend(a, b) {
          for (var i2 in b) {
            if (hasOwnProp(b, i2)) {
              a[i2] = b[i2];
            }
          }
          if (hasOwnProp(b, "toString")) {
            a.toString = b.toString;
          }
          if (hasOwnProp(b, "valueOf")) {
            a.valueOf = b.valueOf;
          }
          return a;
        }
        function createUTC(input, format2, locale2, strict) {
          return createLocalOrUTC(input, format2, locale2, strict, true).utc();
        }
        function defaultParsingFlags() {
          return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false
          };
        }
        function getParsingFlags(m) {
          if (m._pf == null) {
            m._pf = defaultParsingFlags();
          }
          return m._pf;
        }
        var some;
        if (Array.prototype.some) {
          some = Array.prototype.some;
        } else {
          some = function(fun) {
            var t2 = Object(this), len = t2.length >>> 0, i2;
            for (i2 = 0; i2 < len; i2++) {
              if (i2 in t2 && fun.call(this, t2[i2], i2, t2)) {
                return true;
              }
            }
            return false;
          };
        }
        function isValid(m) {
          var flags = null, parsedParts = false, isNowValid = m._d && !isNaN(m._d.getTime());
          if (isNowValid) {
            flags = getParsingFlags(m);
            parsedParts = some.call(flags.parsedDateParts, function(i2) {
              return i2 != null;
            });
            isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
            if (m._strict) {
              isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
            }
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
          return m._isValid;
        }
        function createInvalid(flags) {
          var m = createUTC(NaN);
          if (flags != null) {
            extend(getParsingFlags(m), flags);
          } else {
            getParsingFlags(m).userInvalidated = true;
          }
          return m;
        }
        var momentProperties = hooks.momentProperties = [], updateInProgress = false;
        function copyConfig(to2, from2) {
          var i2, prop, val, momentPropertiesLen = momentProperties.length;
          if (!isUndefined(from2._isAMomentObject)) {
            to2._isAMomentObject = from2._isAMomentObject;
          }
          if (!isUndefined(from2._i)) {
            to2._i = from2._i;
          }
          if (!isUndefined(from2._f)) {
            to2._f = from2._f;
          }
          if (!isUndefined(from2._l)) {
            to2._l = from2._l;
          }
          if (!isUndefined(from2._strict)) {
            to2._strict = from2._strict;
          }
          if (!isUndefined(from2._tzm)) {
            to2._tzm = from2._tzm;
          }
          if (!isUndefined(from2._isUTC)) {
            to2._isUTC = from2._isUTC;
          }
          if (!isUndefined(from2._offset)) {
            to2._offset = from2._offset;
          }
          if (!isUndefined(from2._pf)) {
            to2._pf = getParsingFlags(from2);
          }
          if (!isUndefined(from2._locale)) {
            to2._locale = from2._locale;
          }
          if (momentPropertiesLen > 0) {
            for (i2 = 0; i2 < momentPropertiesLen; i2++) {
              prop = momentProperties[i2];
              val = from2[prop];
              if (!isUndefined(val)) {
                to2[prop] = val;
              }
            }
          }
          return to2;
        }
        function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);
          if (!this.isValid()) {
            this._d = new Date(NaN);
          }
          if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
          }
        }
        function isMoment(obj) {
          return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
        }
        function warn(msg) {
          if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
            console.warn("Deprecation warning: " + msg);
          }
        }
        function deprecate(msg, fn) {
          var firstTime = true;
          return extend(function() {
            if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
              var args = [], arg, i2, key, argLen = arguments.length;
              for (i2 = 0; i2 < argLen; i2++) {
                arg = "";
                if (typeof arguments[i2] === "object") {
                  arg += "\n[" + i2 + "] ";
                  for (key in arguments[0]) {
                    if (hasOwnProp(arguments[0], key)) {
                      arg += key + ": " + arguments[0][key] + ", ";
                    }
                  }
                  arg = arg.slice(0, -2);
                } else {
                  arg = arguments[i2];
                }
                args.push(arg);
              }
              warn(
                msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
              );
              firstTime = false;
            }
            return fn.apply(this, arguments);
          }, fn);
        }
        var deprecations = {};
        function deprecateSimple(name, msg) {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
          }
        }
        hooks.suppressDeprecationWarnings = false;
        hooks.deprecationHandler = null;
        function isFunction(input) {
          return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
        }
        function set(config) {
          var prop, i2;
          for (i2 in config) {
            if (hasOwnProp(config, i2)) {
              prop = config[i2];
              if (isFunction(prop)) {
                this[i2] = prop;
              } else {
                this["_" + i2] = prop;
              }
            }
          }
          this._config = config;
          this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
          );
        }
        function mergeConfigs(parentConfig, childConfig) {
          var res = extend({}, parentConfig), prop;
          for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
              if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
              } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
              } else {
                delete res[prop];
              }
            }
          }
          for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
              res[prop] = extend({}, res[prop]);
            }
          }
          return res;
        }
        function Locale(config) {
          if (config != null) {
            this.set(config);
          }
        }
        var keys;
        if (Object.keys) {
          keys = Object.keys;
        } else {
          keys = function(obj) {
            var i2, res = [];
            for (i2 in obj) {
              if (hasOwnProp(obj, i2)) {
                res.push(i2);
              }
            }
            return res;
          };
        }
        var defaultCalendar = {
          sameDay: "[Today at] LT",
          nextDay: "[Tomorrow at] LT",
          nextWeek: "dddd [at] LT",
          lastDay: "[Yesterday at] LT",
          lastWeek: "[Last] dddd [at] LT",
          sameElse: "L"
        };
        function calendar(key, mom, now3) {
          var output = this._calendar[key] || this._calendar["sameElse"];
          return isFunction(output) ? output.call(mom, now3) : output;
        }
        function zeroFill(number, targetLength, forceSign) {
          var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
          return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
        }
        var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
        function addFormatToken(token2, padded, ordinal2, callback) {
          var func = callback;
          if (typeof callback === "string") {
            func = function() {
              return this[callback]();
            };
          }
          if (token2) {
            formatTokenFunctions[token2] = func;
          }
          if (padded) {
            formatTokenFunctions[padded[0]] = function() {
              return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
          }
          if (ordinal2) {
            formatTokenFunctions[ordinal2] = function() {
              return this.localeData().ordinal(
                func.apply(this, arguments),
                token2
              );
            };
          }
        }
        function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
          }
          return input.replace(/\\/g, "");
        }
        function makeFormatFunction(format2) {
          var array = format2.match(formattingTokens), i2, length;
          for (i2 = 0, length = array.length; i2 < length; i2++) {
            if (formatTokenFunctions[array[i2]]) {
              array[i2] = formatTokenFunctions[array[i2]];
            } else {
              array[i2] = removeFormattingTokens(array[i2]);
            }
          }
          return function(mom) {
            var output = "", i3;
            for (i3 = 0; i3 < length; i3++) {
              output += isFunction(array[i3]) ? array[i3].call(mom, format2) : array[i3];
            }
            return output;
          };
        }
        function formatMoment(m, format2) {
          if (!m.isValid()) {
            return m.localeData().invalidDate();
          }
          format2 = expandFormat(format2, m.localeData());
          formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
          return formatFunctions[format2](m);
        }
        function expandFormat(format2, locale2) {
          var i2 = 5;
          function replaceLongDateFormatTokens(input) {
            return locale2.longDateFormat(input) || input;
          }
          localFormattingTokens.lastIndex = 0;
          while (i2 >= 0 && localFormattingTokens.test(format2)) {
            format2 = format2.replace(
              localFormattingTokens,
              replaceLongDateFormatTokens
            );
            localFormattingTokens.lastIndex = 0;
            i2 -= 1;
          }
          return format2;
        }
        var defaultLongDateFormat = {
          LTS: "h:mm:ss A",
          LT: "h:mm A",
          L: "MM/DD/YYYY",
          LL: "MMMM D, YYYY",
          LLL: "MMMM D, YYYY h:mm A",
          LLLL: "dddd, MMMM D, YYYY h:mm A"
        };
        function longDateFormat(key) {
          var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
          if (format2 || !formatUpper) {
            return format2;
          }
          this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
            if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
              return tok.slice(1);
            }
            return tok;
          }).join("");
          return this._longDateFormat[key];
        }
        var defaultInvalidDate = "Invalid date";
        function invalidDate() {
          return this._invalidDate;
        }
        var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
        function ordinal(number) {
          return this._ordinal.replace("%d", number);
        }
        var defaultRelativeTime = {
          future: "in %s",
          past: "%s ago",
          s: "a few seconds",
          ss: "%d seconds",
          m: "a minute",
          mm: "%d minutes",
          h: "an hour",
          hh: "%d hours",
          d: "a day",
          dd: "%d days",
          w: "a week",
          ww: "%d weeks",
          M: "a month",
          MM: "%d months",
          y: "a year",
          yy: "%d years"
        };
        function relativeTime(number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        }
        function pastFuture(diff2, output) {
          var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
          return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
        }
        var aliases = {
          D: "date",
          dates: "date",
          date: "date",
          d: "day",
          days: "day",
          day: "day",
          e: "weekday",
          weekdays: "weekday",
          weekday: "weekday",
          E: "isoWeekday",
          isoweekdays: "isoWeekday",
          isoweekday: "isoWeekday",
          DDD: "dayOfYear",
          dayofyears: "dayOfYear",
          dayofyear: "dayOfYear",
          h: "hour",
          hours: "hour",
          hour: "hour",
          ms: "millisecond",
          milliseconds: "millisecond",
          millisecond: "millisecond",
          m: "minute",
          minutes: "minute",
          minute: "minute",
          M: "month",
          months: "month",
          month: "month",
          Q: "quarter",
          quarters: "quarter",
          quarter: "quarter",
          s: "second",
          seconds: "second",
          second: "second",
          gg: "weekYear",
          weekyears: "weekYear",
          weekyear: "weekYear",
          GG: "isoWeekYear",
          isoweekyears: "isoWeekYear",
          isoweekyear: "isoWeekYear",
          w: "week",
          weeks: "week",
          week: "week",
          W: "isoWeek",
          isoweeks: "isoWeek",
          isoweek: "isoWeek",
          y: "year",
          years: "year",
          year: "year"
        };
        function normalizeUnits(units) {
          return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
        }
        function normalizeObjectUnits(inputObject) {
          var normalizedInput = {}, normalizedProp, prop;
          for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
              normalizedProp = normalizeUnits(prop);
              if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
              }
            }
          }
          return normalizedInput;
        }
        var priorities = {
          date: 9,
          day: 11,
          weekday: 11,
          isoWeekday: 11,
          dayOfYear: 4,
          hour: 13,
          millisecond: 16,
          minute: 14,
          month: 8,
          quarter: 7,
          second: 15,
          weekYear: 1,
          isoWeekYear: 1,
          week: 5,
          isoWeek: 5,
          year: 1
        };
        function getPrioritizedUnits(unitsObj) {
          var units = [], u;
          for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
              units.push({ unit: u, priority: priorities[u] });
            }
          }
          units.sort(function(a, b) {
            return a.priority - b.priority;
          });
          return units;
        }
        var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, match1to2NoLeadingZero = /^[1-9]\d?/, match1to2HasZero = /^([1-9]\d|\d)/, regexes;
        regexes = {};
        function addRegexToken(token2, regex, strictRegex) {
          regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
            return isStrict && strictRegex ? strictRegex : regex;
          };
        }
        function getParseRegexForToken(token2, config) {
          if (!hasOwnProp(regexes, token2)) {
            return new RegExp(unescapeFormat(token2));
          }
          return regexes[token2](config._strict, config._locale);
        }
        function unescapeFormat(s2) {
          return regexEscape(
            s2.replace("\\", "").replace(
              /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
              function(matched, p1, p2, p3, p4) {
                return p1 || p2 || p3 || p4;
              }
            )
          );
        }
        function regexEscape(s2) {
          return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\0.9489947867251121-JS-0.812273656921717");
        }
        function absFloor(number) {
          if (number < 0) {
            return Math.ceil(number) || 0;
          } else {
            return Math.floor(number);
          }
        }
        function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion, value = 0;
          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
          }
          return value;
        }
        var tokens = {};
        function addParseToken(token2, callback) {
          var i2, func = callback, tokenLen;
          if (typeof token2 === "string") {
            token2 = [token2];
          }
          if (isNumber(callback)) {
            func = function(input, array) {
              array[callback] = toInt(input);
            };
          }
          tokenLen = token2.length;
          for (i2 = 0; i2 < tokenLen; i2++) {
            tokens[token2[i2]] = func;
          }
        }
        function addWeekParseToken(token2, callback) {
          addParseToken(token2, function(input, array, config, token3) {
            config._w = config._w || {};
            callback(input, config._w, config, token3);
          });
        }
        function addTimeToArrayFromToken(token2, input, config) {
          if (input != null && hasOwnProp(tokens, token2)) {
            tokens[token2](input, config._a, config, token2);
          }
        }
        function isLeapYear(year) {
          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        }
        var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
        addFormatToken("Y", 0, 0, function() {
          var y = this.year();
          return y <= 9999 ? zeroFill(y, 4) : "+" + y;
        });
        addFormatToken(0, ["YY", 2], 0, function() {
          return this.year() % 100;
        });
        addFormatToken(0, ["YYYY", 4], 0, "year");
        addFormatToken(0, ["YYYYY", 5], 0, "year");
        addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
        addRegexToken("Y", matchSigned);
        addRegexToken("YY", match1to2, match2);
        addRegexToken("YYYY", match1to4, match4);
        addRegexToken("YYYYY", match1to6, match6);
        addRegexToken("YYYYYY", match1to6, match6);
        addParseToken(["YYYYY", "YYYYYY"], YEAR);
        addParseToken("YYYY", function(input, array) {
          array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
        });
        addParseToken("YY", function(input, array) {
          array[YEAR] = hooks.parseTwoDigitYear(input);
        });
        addParseToken("Y", function(input, array) {
          array[YEAR] = parseInt(input, 10);
        });
        function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
        }
        hooks.parseTwoDigitYear = function(input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
        };
        var getSetYear = makeGetSet("FullYear", true);
        function getIsLeapYear() {
          return isLeapYear(this.year());
        }
        function makeGetSet(unit, keepTime) {
          return function(value) {
            if (value != null) {
              set$1(this, unit, value);
              hooks.updateOffset(this, keepTime);
              return this;
            } else {
              return get(this, unit);
            }
          };
        }
        function get(mom, unit) {
          if (!mom.isValid()) {
            return NaN;
          }
          var d = mom._d, isUTC = mom._isUTC;
          switch (unit) {
            case "Milliseconds":
              return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
            case "Seconds":
              return isUTC ? d.getUTCSeconds() : d.getSeconds();
            case "Minutes":
              return isUTC ? d.getUTCMinutes() : d.getMinutes();
            case "Hours":
              return isUTC ? d.getUTCHours() : d.getHours();
            case "Date":
              return isUTC ? d.getUTCDate() : d.getDate();
            case "Day":
              return isUTC ? d.getUTCDay() : d.getDay();
            case "Month":
              return isUTC ? d.getUTCMonth() : d.getMonth();
            case "FullYear":
              return isUTC ? d.getUTCFullYear() : d.getFullYear();
            default:
              return NaN;
          }
        }
        function set$1(mom, unit, value) {
          var d, isUTC, year, month, date;
          if (!mom.isValid() || isNaN(value)) {
            return;
          }
          d = mom._d;
          isUTC = mom._isUTC;
          switch (unit) {
            case "Milliseconds":
              return void (isUTC ? d.setUTCMilliseconds(value) : d.setMilliseconds(value));
            case "Seconds":
              return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
            case "Minutes":
              return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
            case "Hours":
              return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
            case "Date":
              return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
            case "FullYear":
              break;
            default:
              return;
          }
          year = value;
          month = mom.month();
          date = mom.date();
          date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
          void (isUTC ? d.setUTCFullYear(year, month, date) : d.setFullYear(year, month, date));
        }
        function stringGet(units) {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units]();
          }
          return this;
        }
        function stringSet(units, value) {
          if (typeof units === "object") {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units), i2, prioritizedLen = prioritized.length;
            for (i2 = 0; i2 < prioritizedLen; i2++) {
              this[prioritized[i2].unit](units[prioritized[i2].unit]);
            }
          } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
              return this[units](value);
            }
          }
          return this;
        }
        function mod(n2, x) {
          return (n2 % x + x) % x;
        }
        var indexOf;
        if (Array.prototype.indexOf) {
          indexOf = Array.prototype.indexOf;
        } else {
          indexOf = function(o) {
            var i2;
            for (i2 = 0; i2 < this.length; ++i2) {
              if (this[i2] === o) {
                return i2;
              }
            }
            return -1;
          };
        }
        function daysInMonth(year, month) {
          if (isNaN(year) || isNaN(month)) {
            return NaN;
          }
          var modMonth = mod(month, 12);
          year += (month - modMonth) / 12;
          return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
        }
        addFormatToken("M", ["MM", 2], "Mo", function() {
          return this.month() + 1;
        });
        addFormatToken("MMM", 0, 0, function(format2) {
          return this.localeData().monthsShort(this, format2);
        });
        addFormatToken("MMMM", 0, 0, function(format2) {
          return this.localeData().months(this, format2);
        });
        addRegexToken("M", match1to2, match1to2NoLeadingZero);
        addRegexToken("MM", match1to2, match2);
        addRegexToken("MMM", function(isStrict, locale2) {
          return locale2.monthsShortRegex(isStrict);
        });
        addRegexToken("MMMM", function(isStrict, locale2) {
          return locale2.monthsRegex(isStrict);
        });
        addParseToken(["M", "MM"], function(input, array) {
          array[MONTH] = toInt(input) - 1;
        });
        addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
          var month = config._locale.monthsParse(input, token2, config._strict);
          if (month != null) {
            array[MONTH] = month;
          } else {
            getParsingFlags(config).invalidMonth = input;
          }
        });
        var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
          "_"
        ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
        function localeMonths(m, format2) {
          if (!m) {
            return isArray(this._months) ? this._months : this._months["standalone"];
          }
          return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
        }
        function localeMonthsShort(m, format2) {
          if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
          }
          return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
        }
        function handleStrictParse(monthName, format2, strict) {
          var i2, ii, mom, llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i2 = 0; i2 < 12; ++i2) {
              mom = createUTC([2e3, i2]);
              this._shortMonthsParse[i2] = this.monthsShort(
                mom,
                ""
              ).toLocaleLowerCase();
              this._longMonthsParse[i2] = this.months(mom, "").toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format2 === "MMM") {
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format2 === "MMM") {
              ii = indexOf.call(this._shortMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeMonthsParse(monthName, format2, strict) {
          var i2, mom, regex;
          if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format2, strict);
          }
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
          }
          for (i2 = 0; i2 < 12; i2++) {
            mom = createUTC([2e3, i2]);
            if (strict && !this._longMonthsParse[i2]) {
              this._longMonthsParse[i2] = new RegExp(
                "^" + this.months(mom, "").replace(".", "") + "$",
                "i"
              );
              this._shortMonthsParse[i2] = new RegExp(
                "^" + this.monthsShort(mom, "").replace(".", "") + "$",
                "i"
              );
            }
            if (!strict && !this._monthsParse[i2]) {
              regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
              this._monthsParse[i2] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format2 === "MMMM" && this._longMonthsParse[i2].test(monthName)) {
              return i2;
            } else if (strict && format2 === "MMM" && this._shortMonthsParse[i2].test(monthName)) {
              return i2;
            } else if (!strict && this._monthsParse[i2].test(monthName)) {
              return i2;
            }
          }
        }
        function setMonth(mom, value) {
          if (!mom.isValid()) {
            return mom;
          }
          if (typeof value === "string") {
            if (/^\d+$/.test(value)) {
              value = toInt(value);
            } else {
              value = mom.localeData().monthsParse(value);
              if (!isNumber(value)) {
                return mom;
              }
            }
          }
          var month = value, date = mom.date();
          date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
          void (mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date));
          return mom;
        }
        function getSetMonth(value) {
          if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
          } else {
            return get(this, "Month");
          }
        }
        function getDaysInMonth() {
          return daysInMonth(this.year(), this.month());
        }
        function monthsShortRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsShortStrictRegex;
            } else {
              return this._monthsShortRegex;
            }
          } else {
            if (!hasOwnProp(this, "_monthsShortRegex")) {
              this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
          }
        }
        function monthsRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsStrictRegex;
            } else {
              return this._monthsRegex;
            }
          } else {
            if (!hasOwnProp(this, "_monthsRegex")) {
              this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
          }
        }
        function computeMonthsParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, shortP, longP;
          for (i2 = 0; i2 < 12; i2++) {
            mom = createUTC([2e3, i2]);
            shortP = regexEscape(this.monthsShort(mom, ""));
            longP = regexEscape(this.months(mom, ""));
            shortPieces.push(shortP);
            longPieces.push(longP);
            mixedPieces.push(longP);
            mixedPieces.push(shortP);
          }
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp(
            "^(" + longPieces.join("|") + ")",
            "i"
          );
          this._monthsShortStrictRegex = new RegExp(
            "^(" + shortPieces.join("|") + ")",
            "i"
          );
        }
        function createDate(y, m, d, h, M, s2, ms) {
          var date;
          if (y < 100 && y >= 0) {
            date = new Date(y + 400, m, d, h, M, s2, ms);
            if (isFinite(date.getFullYear())) {
              date.setFullYear(y);
            }
          } else {
            date = new Date(y, m, d, h, M, s2, ms);
          }
          return date;
        }
        function createUTCDate(y) {
          var date, args;
          if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
              date.setUTCFullYear(y);
            }
          } else {
            date = new Date(Date.UTC.apply(null, arguments));
          }
          return date;
        }
        function firstWeekOffset(year, dow, doy) {
          var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
          return -fwdlw + fwd - 1;
        }
        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
          if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
          } else {
            resYear = year;
            resDayOfYear = dayOfYear;
          }
          return {
            year: resYear,
            dayOfYear: resDayOfYear
          };
        }
        function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
          if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
          } else {
            resYear = mom.year();
            resWeek = week;
          }
          return {
            week: resWeek,
            year: resYear
          };
        }
        function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        }
        addFormatToken("w", ["ww", 2], "wo", "week");
        addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
        addRegexToken("w", match1to2, match1to2NoLeadingZero);
        addRegexToken("ww", match1to2, match2);
        addRegexToken("W", match1to2, match1to2NoLeadingZero);
        addRegexToken("WW", match1to2, match2);
        addWeekParseToken(
          ["w", "ww", "W", "WW"],
          function(input, week, config, token2) {
            week[token2.substr(0, 1)] = toInt(input);
          }
        );
        function localeWeek(mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }
        var defaultLocaleWeek = {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 6th is the first week of the year.
        };
        function localeFirstDayOfWeek() {
          return this._week.dow;
        }
        function localeFirstDayOfYear() {
          return this._week.doy;
        }
        function getSetWeek(input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, "d");
        }
        function getSetISOWeek(input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, "d");
        }
        addFormatToken("d", 0, "do", "day");
        addFormatToken("dd", 0, 0, function(format2) {
          return this.localeData().weekdaysMin(this, format2);
        });
        addFormatToken("ddd", 0, 0, function(format2) {
          return this.localeData().weekdaysShort(this, format2);
        });
        addFormatToken("dddd", 0, 0, function(format2) {
          return this.localeData().weekdays(this, format2);
        });
        addFormatToken("e", 0, 0, "weekday");
        addFormatToken("E", 0, 0, "isoWeekday");
        addRegexToken("d", match1to2);
        addRegexToken("e", match1to2);
        addRegexToken("E", match1to2);
        addRegexToken("dd", function(isStrict, locale2) {
          return locale2.weekdaysMinRegex(isStrict);
        });
        addRegexToken("ddd", function(isStrict, locale2) {
          return locale2.weekdaysShortRegex(isStrict);
        });
        addRegexToken("dddd", function(isStrict, locale2) {
          return locale2.weekdaysRegex(isStrict);
        });
        addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
          var weekday = config._locale.weekdaysParse(input, token2, config._strict);
          if (weekday != null) {
            week.d = weekday;
          } else {
            getParsingFlags(config).invalidWeekday = input;
          }
        });
        addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
          week[token2] = toInt(input);
        });
        function parseWeekday(input, locale2) {
          if (typeof input !== "string") {
            return input;
          }
          if (!isNaN(input)) {
            return parseInt(input, 10);
          }
          input = locale2.weekdaysParse(input);
          if (typeof input === "number") {
            return input;
          }
          return null;
        }
        function parseIsoWeekday(input, locale2) {
          if (typeof input === "string") {
            return locale2.weekdaysParse(input) % 7 || 7;
          }
          return isNaN(input) ? null : input;
        }
        function shiftWeekdays(ws, n2) {
          return ws.slice(n2, 7).concat(ws.slice(0, n2));
        }
        var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
        function localeWeekdays(m, format2) {
          var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
          return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
        }
        function localeWeekdaysShort(m) {
          return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
        }
        function localeWeekdaysMin(m) {
          return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
        }
        function handleStrictParse$1(weekdayName, format2, strict) {
          var i2, ii, mom, llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];
            for (i2 = 0; i2 < 7; ++i2) {
              mom = createUTC([2e3, 1]).day(i2);
              this._minWeekdaysParse[i2] = this.weekdaysMin(
                mom,
                ""
              ).toLocaleLowerCase();
              this._shortWeekdaysParse[i2] = this.weekdaysShort(
                mom,
                ""
              ).toLocaleLowerCase();
              this._weekdaysParse[i2] = this.weekdays(mom, "").toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format2 === "dddd") {
              ii = indexOf.call(this._weekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format2 === "ddd") {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format2 === "dddd") {
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format2 === "ddd") {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeWeekdaysParse(weekdayName, format2, strict) {
          var i2, mom, regex;
          if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format2, strict);
          }
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
          }
          for (i2 = 0; i2 < 7; i2++) {
            mom = createUTC([2e3, 1]).day(i2);
            if (strict && !this._fullWeekdaysParse[i2]) {
              this._fullWeekdaysParse[i2] = new RegExp(
                "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
                "i"
              );
              this._shortWeekdaysParse[i2] = new RegExp(
                "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
                "i"
              );
              this._minWeekdaysParse[i2] = new RegExp(
                "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
                "i"
              );
            }
            if (!this._weekdaysParse[i2]) {
              regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
              this._weekdaysParse[i2] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format2 === "dddd" && this._fullWeekdaysParse[i2].test(weekdayName)) {
              return i2;
            } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i2].test(weekdayName)) {
              return i2;
            } else if (strict && format2 === "dd" && this._minWeekdaysParse[i2].test(weekdayName)) {
              return i2;
            } else if (!strict && this._weekdaysParse[i2].test(weekdayName)) {
              return i2;
            }
          }
        }
        function getSetDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var day = get(this, "Day");
          if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, "d");
          } else {
            return day;
          }
        }
        function getSetLocaleDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, "d");
        }
        function getSetISODayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
            return this.day() || 7;
          }
        }
        function weekdaysRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysStrictRegex;
            } else {
              return this._weekdaysRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
          }
        }
        function weekdaysShortRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysShortStrictRegex;
            } else {
              return this._weekdaysShortRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysShortRegex")) {
              this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
          }
        }
        function weekdaysMinRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysMinStrictRegex;
            } else {
              return this._weekdaysMinRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysMinRegex")) {
              this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
          }
        }
        function computeWeekdaysParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, minp, shortp, longp;
          for (i2 = 0; i2 < 7; i2++) {
            mom = createUTC([2e3, 1]).day(i2);
            minp = regexEscape(this.weekdaysMin(mom, ""));
            shortp = regexEscape(this.weekdaysShort(mom, ""));
            longp = regexEscape(this.weekdays(mom, ""));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
          }
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;
          this._weekdaysStrictRegex = new RegExp(
            "^(" + longPieces.join("|") + ")",
            "i"
          );
          this._weekdaysShortStrictRegex = new RegExp(
            "^(" + shortPieces.join("|") + ")",
            "i"
          );
          this._weekdaysMinStrictRegex = new RegExp(
            "^(" + minPieces.join("|") + ")",
            "i"
          );
        }
        function hFormat() {
          return this.hours() % 12 || 12;
        }
        function kFormat() {
          return this.hours() || 24;
        }
        addFormatToken("H", ["HH", 2], 0, "hour");
        addFormatToken("h", ["hh", 2], 0, hFormat);
        addFormatToken("k", ["kk", 2], 0, kFormat);
        addFormatToken("hmm", 0, 0, function() {
          return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
        });
        addFormatToken("hmmss", 0, 0, function() {
          return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        addFormatToken("Hmm", 0, 0, function() {
          return "" + this.hours() + zeroFill(this.minutes(), 2);
        });
        addFormatToken("Hmmss", 0, 0, function() {
          return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        function meridiem(token2, lowercase) {
          addFormatToken(token2, 0, 0, function() {
            return this.localeData().meridiem(
              this.hours(),
              this.minutes(),
              lowercase
            );
          });
        }
        meridiem("a", true);
        meridiem("A", false);
        function matchMeridiem(isStrict, locale2) {
          return locale2._meridiemParse;
        }
        addRegexToken("a", matchMeridiem);
        addRegexToken("A", matchMeridiem);
        addRegexToken("H", match1to2, match1to2HasZero);
        addRegexToken("h", match1to2, match1to2NoLeadingZero);
        addRegexToken("k", match1to2, match1to2NoLeadingZero);
        addRegexToken("HH", match1to2, match2);
        addRegexToken("hh", match1to2, match2);
        addRegexToken("kk", match1to2, match2);
        addRegexToken("hmm", match3to4);
        addRegexToken("hmmss", match5to6);
        addRegexToken("Hmm", match3to4);
        addRegexToken("Hmmss", match5to6);
        addParseToken(["H", "HH"], HOUR);
        addParseToken(["k", "kk"], function(input, array, config) {
          var kInput = toInt(input);
          array[HOUR] = kInput === 24 ? 0 : kInput;
        });
        addParseToken(["a", "A"], function(input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
        });
        addParseToken(["h", "hh"], function(input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("hmm", function(input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("hmmss", function(input, array, config) {
          var pos1 = input.length - 4, pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("Hmm", function(input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
        });
        addParseToken("Hmmss", function(input, array, config) {
          var pos1 = input.length - 4, pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
        });
        function localeIsPM(input) {
          return (input + "").toLowerCase().charAt(0) === "p";
        }
        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
        function localeMeridiem(hours2, minutes2, isLower) {
          if (hours2 > 11) {
            return isLower ? "pm" : "PM";
          } else {
            return isLower ? "am" : "AM";
          }
        }
        var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
          relativeTime: defaultRelativeTime,
          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,
          week: defaultLocaleWeek,
          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,
          meridiemParse: defaultLocaleMeridiemParse
        };
        var locales = {}, localeFamilies = {}, globalLocale;
        function commonPrefix(arr1, arr2) {
          var i2, minl = Math.min(arr1.length, arr2.length);
          for (i2 = 0; i2 < minl; i2 += 1) {
            if (arr1[i2] !== arr2[i2]) {
              return i2;
            }
          }
          return minl;
        }
        function normalizeLocale(key) {
          return key ? key.toLowerCase().replace("_", "-") : key;
        }
        function chooseLocale(names) {
          var i2 = 0, j, next, locale2, split;
          while (i2 < names.length) {
            split = normalizeLocale(names[i2]).split("-");
            j = split.length;
            next = normalizeLocale(names[i2 + 1]);
            next = next ? next.split("-") : null;
            while (j > 0) {
              locale2 = loadLocale(split.slice(0, j).join("-"));
              if (locale2) {
                return locale2;
              }
              if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
                break;
              }
              j--;
            }
            i2++;
          }
          return globalLocale;
        }
        function isLocaleNameSane(name) {
          return !!(name && name.match("^[^/\\\\]*$"));
        }
        function loadLocale(name) {
          var oldLocale = null, aliasedRequire;
          if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
            try {
              oldLocale = globalLocale._abbr;
              aliasedRequire = __require;
              aliasedRequire("./locale/" + name);
              getSetGlobalLocale(oldLocale);
            } catch (e2) {
              locales[name] = null;
            }
          }
          return locales[name];
        }
        function getSetGlobalLocale(key, values) {
          var data;
          if (key) {
            if (isUndefined(values)) {
              data = getLocale(key);
            } else {
              data = defineLocale(key, values);
            }
            if (data) {
              globalLocale = data;
            } else {
              if (typeof console !== "undefined" && console.warn) {
                console.warn(
                  "Locale " + key + " not found. Did you forget to load it?"
                );
              }
            }
          }
          return globalLocale._abbr;
        }
        function defineLocale(name, config) {
          if (config !== null) {
            var locale2, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
              deprecateSimple(
                "defineLocaleOverride",
                "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
              );
              parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
              if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
              } else {
                locale2 = loadLocale(config.parentLocale);
                if (locale2 != null) {
                  parentConfig = locale2._config;
                } else {
                  if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                  }
                  localeFamilies[config.parentLocale].push({
                    name,
                    config
                  });
                  return null;
                }
              }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));
            if (localeFamilies[name]) {
              localeFamilies[name].forEach(function(x) {
                defineLocale(x.name, x.config);
              });
            }
            getSetGlobalLocale(name);
            return locales[name];
          } else {
            delete locales[name];
            return null;
          }
        }
        function updateLocale(name, config) {
          if (config != null) {
            var locale2, tmpLocale, parentConfig = baseConfig;
            if (locales[name] != null && locales[name].parentLocale != null) {
              locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
              tmpLocale = loadLocale(name);
              if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
              }
              config = mergeConfigs(parentConfig, config);
              if (tmpLocale == null) {
                config.abbr = name;
              }
              locale2 = new Locale(config);
              locale2.parentLocale = locales[name];
              locales[name] = locale2;
            }
            getSetGlobalLocale(name);
          } else {
            if (locales[name] != null) {
              if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
                if (name === getSetGlobalLocale()) {
                  getSetGlobalLocale(name);
                }
              } else if (locales[name] != null) {
                delete locales[name];
              }
            }
          }
          return locales[name];
        }
        function getLocale(key) {
          var locale2;
          if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
          }
          if (!key) {
            return globalLocale;
          }
          if (!isArray(key)) {
            locale2 = loadLocale(key);
            if (locale2) {
              return locale2;
            }
            key = [key];
          }
          return chooseLocale(key);
        }
        function listLocales() {
          return keys(locales);
        }
        function checkOverflow(m) {
          var overflow, a = m._a;
          if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
              overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
              overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
              overflow = WEEKDAY;
            }
            getParsingFlags(m).overflow = overflow;
          }
          return m;
        }
        var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
          ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
          ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
          ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
          ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
          ["YYYY-DDD", /\d{4}-\d{3}/],
          ["YYYY-MM", /\d{4}-\d\d/, false],
          ["YYYYYYMMDD", /[+-]\d{10}/],
          ["YYYYMMDD", /\d{8}/],
          ["GGGG[W]WWE", /\d{4}W\d{3}/],
          ["GGGG[W]WW", /\d{4}W\d{2}/, false],
          ["YYYYDDD", /\d{7}/],
          ["YYYYMM", /\d{6}/, false],
          ["YYYY", /\d{4}/, false]
        ], isoTimes = [
          ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
          ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
          ["HH:mm:ss", /\d\d:\d\d:\d\d/],
          ["HH:mm", /\d\d:\d\d/],
          ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
          ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
          ["HHmmss", /\d\d\d\d\d\d/],
          ["HHmm", /\d\d\d\d/],
          ["HH", /\d\d/]
        ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
          UT: 0,
          GMT: 0,
          EDT: -4 * 60,
          EST: -5 * 60,
          CDT: -5 * 60,
          CST: -6 * 60,
          MDT: -6 * 60,
          MST: -7 * 60,
          PDT: -7 * 60,
          PST: -8 * 60
        };
        function configFromISO(config) {
          var i2, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
          if (match) {
            getParsingFlags(config).iso = true;
            for (i2 = 0, l = isoDatesLen; i2 < l; i2++) {
              if (isoDates[i2][1].exec(match[1])) {
                dateFormat = isoDates[i2][0];
                allowTime = isoDates[i2][2] !== false;
                break;
              }
            }
            if (dateFormat == null) {
              config._isValid = false;
              return;
            }
            if (match[3]) {
              for (i2 = 0, l = isoTimesLen; i2 < l; i2++) {
                if (isoTimes[i2][1].exec(match[3])) {
                  timeFormat = (match[2] || " ") + isoTimes[i2][0];
                  break;
                }
              }
              if (timeFormat == null) {
                config._isValid = false;
                return;
              }
            }
            if (!allowTime && timeFormat != null) {
              config._isValid = false;
              return;
            }
            if (match[4]) {
              if (tzRegex.exec(match[4])) {
                tzFormat = "Z";
              } else {
                config._isValid = false;
                return;
              }
            }
            config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
            configFromStringAndFormat(config);
          } else {
            config._isValid = false;
          }
        }
        function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
          var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
          ];
          if (secondStr) {
            result.push(parseInt(secondStr, 10));
          }
          return result;
        }
        function untruncateYear(yearStr) {
          var year = parseInt(yearStr, 10);
          if (year <= 49) {
            return 2e3 + year;
          } else if (year <= 999) {
            return 1900 + year;
          }
          return year;
        }
        function preprocessRFC2822(s2) {
          return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
        }
        function checkWeekday(weekdayStr, parsedInput, config) {
          if (weekdayStr) {
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
              parsedInput[0],
              parsedInput[1],
              parsedInput[2]
            ).getDay();
            if (weekdayProvided !== weekdayActual) {
              getParsingFlags(config).weekdayMismatch = true;
              config._isValid = false;
              return false;
            }
          }
          return true;
        }
        function calculateOffset(obsOffset, militaryOffset, numOffset) {
          if (obsOffset) {
            return obsOffsets[obsOffset];
          } else if (militaryOffset) {
            return 0;
          } else {
            var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
          }
        }
        function configFromRFC2822(config) {
          var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
          if (match) {
            parsedArray = extractFromRFC2822Strings(
              match[4],
              match[3],
              match[2],
              match[5],
              match[6],
              match[7]
            );
            if (!checkWeekday(match[1], parsedArray, config)) {
              return;
            }
            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);
            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            getParsingFlags(config).rfc2822 = true;
          } else {
            config._isValid = false;
          }
        }
        function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);
          if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
          }
          configFromISO(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          configFromRFC2822(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          if (config._strict) {
            config._isValid = false;
          } else {
            hooks.createFromInputFallback(config);
          }
        }
        hooks.createFromInputFallback = deprecate(
          "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
          function(config) {
            config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
          }
        );
        function defaults(a, b, c) {
          if (a != null) {
            return a;
          }
          if (b != null) {
            return b;
          }
          return c;
        }
        function currentDateArray(config) {
          var nowValue = new Date(hooks.now());
          if (config._useUTC) {
            return [
              nowValue.getUTCFullYear(),
              nowValue.getUTCMonth(),
              nowValue.getUTCDate()
            ];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
        }
        function configFromArray(config) {
          var i2, date, input = [], currentDate, expectedWeekday, yearToUse;
          if (config._d) {
            return;
          }
          currentDate = currentDateArray(config);
          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
          }
          if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
              getParsingFlags(config)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
          }
          for (i2 = 0; i2 < 3 && config._a[i2] == null; ++i2) {
            config._a[i2] = input[i2] = currentDate[i2];
          }
          for (; i2 < 7; i2++) {
            config._a[i2] = input[i2] = config._a[i2] == null ? i2 === 2 ? 1 : 0 : config._a[i2];
          }
          if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
          }
          config._d = (config._useUTC ? createUTCDate : createDate).apply(
            null,
            input
          );
          expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
          if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }
          if (config._nextDay) {
            config._a[HOUR] = 24;
          }
          if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
          }
        }
        function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
          w = config._w;
          if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = defaults(
              w.GG,
              config._a[YEAR],
              weekOfYear(createLocal(), 1, 4).year
            );
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
              weekdayOverflow = true;
            }
          } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
            week = defaults(w.w, curWeek.week);
            if (w.d != null) {
              weekday = w.d;
              if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
              }
            } else if (w.e != null) {
              weekday = w.e + dow;
              if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
              }
            } else {
              weekday = dow;
            }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
          } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
          }
        }
        hooks.ISO_8601 = function() {
        };
        hooks.RFC_2822 = function() {
        };
        function configFromStringAndFormat(config) {
          if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
          }
          if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
          }
          config._a = [];
          getParsingFlags(config).empty = true;
          var string = "" + config._i, i2, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
          tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
          tokenLen = tokens2.length;
          for (i2 = 0; i2 < tokenLen; i2++) {
            token2 = tokens2[i2];
            parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
            if (parsedInput) {
              skipped = string.substr(0, string.indexOf(parsedInput));
              if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
              }
              string = string.slice(
                string.indexOf(parsedInput) + parsedInput.length
              );
              totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token2]) {
              if (parsedInput) {
                getParsingFlags(config).empty = false;
              } else {
                getParsingFlags(config).unusedTokens.push(token2);
              }
              addTimeToArrayFromToken(token2, parsedInput, config);
            } else if (config._strict && !parsedInput) {
              getParsingFlags(config).unusedTokens.push(token2);
            }
          }
          getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
          if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
          }
          if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = void 0;
          }
          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem;
          config._a[HOUR] = meridiemFixWrap(
            config._locale,
            config._a[HOUR],
            config._meridiem
          );
          era = getParsingFlags(config).era;
          if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
          }
          configFromArray(config);
          checkOverflow(config);
        }
        function meridiemFixWrap(locale2, hour, meridiem2) {
          var isPm;
          if (meridiem2 == null) {
            return hour;
          }
          if (locale2.meridiemHour != null) {
            return locale2.meridiemHour(hour, meridiem2);
          } else if (locale2.isPM != null) {
            isPm = locale2.isPM(meridiem2);
            if (isPm && hour < 12) {
              hour += 12;
            }
            if (!isPm && hour === 12) {
              hour = 0;
            }
            return hour;
          } else {
            return hour;
          }
        }
        function configFromStringAndArray(config) {
          var tempConfig, bestMoment, scoreToBeat, i2, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
          if (configfLen === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
          }
          for (i2 = 0; i2 < configfLen; i2++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
              tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i2];
            configFromStringAndFormat(tempConfig);
            if (isValid(tempConfig)) {
              validFormatFound = true;
            }
            currentScore += getParsingFlags(tempConfig).charsLeftOver;
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (!bestFormatIsValid) {
              if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
                if (validFormatFound) {
                  bestFormatIsValid = true;
                }
              }
            } else {
              if (currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
              }
            }
          }
          extend(config, bestMoment || tempConfig);
        }
        function configFromObject(config) {
          if (config._d) {
            return;
          }
          var i2 = normalizeObjectUnits(config._i), dayOrDate = i2.day === void 0 ? i2.date : i2.day;
          config._a = map(
            [i2.year, i2.month, dayOrDate, i2.hour, i2.minute, i2.second, i2.millisecond],
            function(obj) {
              return obj && parseInt(obj, 10);
            }
          );
          configFromArray(config);
        }
        function createFromConfig(config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));
          if (res._nextDay) {
            res.add(1, "d");
            res._nextDay = void 0;
          }
          return res;
        }
        function prepareConfig(config) {
          var input = config._i, format2 = config._f;
          config._locale = config._locale || getLocale(config._l);
          if (input === null || format2 === void 0 && input === "") {
            return createInvalid({ nullInput: true });
          }
          if (typeof input === "string") {
            config._i = input = config._locale.preparse(input);
          }
          if (isMoment(input)) {
            return new Moment(checkOverflow(input));
          } else if (isDate(input)) {
            config._d = input;
          } else if (isArray(format2)) {
            configFromStringAndArray(config);
          } else if (format2) {
            configFromStringAndFormat(config);
          } else {
            configFromInput(config);
          }
          if (!isValid(config)) {
            config._d = null;
          }
          return config;
        }
        function configFromInput(config) {
          var input = config._i;
          if (isUndefined(input)) {
            config._d = new Date(hooks.now());
          } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
          } else if (typeof input === "string") {
            configFromString(config);
          } else if (isArray(input)) {
            config._a = map(input.slice(0), function(obj) {
              return parseInt(obj, 10);
            });
            configFromArray(config);
          } else if (isObject(input)) {
            configFromObject(config);
          } else if (isNumber(input)) {
            config._d = new Date(input);
          } else {
            hooks.createFromInputFallback(config);
          }
        }
        function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
          var c = {};
          if (format2 === true || format2 === false) {
            strict = format2;
            format2 = void 0;
          }
          if (locale2 === true || locale2 === false) {
            strict = locale2;
            locale2 = void 0;
          }
          if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
            input = void 0;
          }
          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale2;
          c._i = input;
          c._f = format2;
          c._strict = strict;
          return createFromConfig(c);
        }
        function createLocal(input, format2, locale2, strict) {
          return createLocalOrUTC(input, format2, locale2, strict, false);
        }
        var prototypeMin = deprecate(
          "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
          function() {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
              return other < this ? this : other;
            } else {
              return createInvalid();
            }
          }
        ), prototypeMax = deprecate(
          "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
          function() {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
              return other > this ? this : other;
            } else {
              return createInvalid();
            }
          }
        );
        function pickBy(fn, moments) {
          var res, i2;
          if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
          }
          if (!moments.length) {
            return createLocal();
          }
          res = moments[0];
          for (i2 = 1; i2 < moments.length; ++i2) {
            if (!moments[i2].isValid() || moments[i2][fn](res)) {
              res = moments[i2];
            }
          }
          return res;
        }
        function min() {
          var args = [].slice.call(arguments, 0);
          return pickBy("isBefore", args);
        }
        function max() {
          var args = [].slice.call(arguments, 0);
          return pickBy("isAfter", args);
        }
        var now2 = function() {
          return Date.now ? Date.now() : +new Date();
        };
        var ordering = [
          "year",
          "quarter",
          "month",
          "week",
          "day",
          "hour",
          "minute",
          "second",
          "millisecond"
        ];
        function isDurationValid(m) {
          var key, unitHasDecimal = false, i2, orderLen = ordering.length;
          for (key in m) {
            if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
              return false;
            }
          }
          for (i2 = 0; i2 < orderLen; ++i2) {
            if (m[ordering[i2]]) {
              if (unitHasDecimal) {
                return false;
              }
              if (parseFloat(m[ordering[i2]]) !== toInt(m[ordering[i2]])) {
                unitHasDecimal = true;
              }
            }
          }
          return true;
        }
        function isValid$1() {
          return this._isValid;
        }
        function createInvalid$1() {
          return createDuration(NaN);
        }
        function Duration(duration) {
          var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
          this._isValid = isDurationValid(normalizedInput);
          this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
          minutes2 * 6e4 + // 1000 * 60
          hours2 * 1e3 * 60 * 60;
          this._days = +days2 + weeks2 * 7;
          this._months = +months2 + quarters * 3 + years2 * 12;
          this._data = {};
          this._locale = getLocale();
          this._bubble();
        }
        function isDuration(obj) {
          return obj instanceof Duration;
        }
        function absRound(number) {
          if (number < 0) {
            return Math.round(-1 * number) * -1;
          } else {
            return Math.round(number);
          }
        }
        function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i2;
          for (i2 = 0; i2 < len; i2++) {
            if (dontConvert && array1[i2] !== array2[i2] || !dontConvert && toInt(array1[i2]) !== toInt(array2[i2])) {
              diffs++;
            }
          }
          return diffs + lengthDiff;
        }
        function offset(token2, separator) {
          addFormatToken(token2, 0, 0, function() {
            var offset2 = this.utcOffset(), sign2 = "+";
            if (offset2 < 0) {
              offset2 = -offset2;
              sign2 = "-";
            }
            return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
          });
        }
        offset("Z", ":");
        offset("ZZ", "");
        addRegexToken("Z", matchShortOffset);
        addRegexToken("ZZ", matchShortOffset);
        addParseToken(["Z", "ZZ"], function(input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
        });
        var chunkOffset = /([\+\-]|\d\d)/gi;
        function offsetFromString(matcher, string) {
          var matches = (string || "").match(matcher), chunk, parts, minutes2;
          if (matches === null) {
            return null;
          }
          chunk = matches[matches.length - 1] || [];
          parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
          minutes2 = +(parts[1] * 60) + toInt(parts[2]);
          return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
        }
        function cloneWithOffset(input, model) {
          var res, diff2;
          if (model._isUTC) {
            res = model.clone();
            diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            res._d.setTime(res._d.valueOf() + diff2);
            hooks.updateOffset(res, false);
            return res;
          } else {
            return createLocal(input).local();
          }
        }
        function getDateOffset(m) {
          return -Math.round(m._d.getTimezoneOffset());
        }
        hooks.updateOffset = function() {
        };
        function getSetOffset(input, keepLocalTime, keepMinutes) {
          var offset2 = this._offset || 0, localAdjust;
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            if (typeof input === "string") {
              input = offsetFromString(matchShortOffset, input);
              if (input === null) {
                return this;
              }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
              input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
              localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
              this.add(localAdjust, "m");
            }
            if (offset2 !== input) {
              if (!keepLocalTime || this._changeInProgress) {
                addSubtract(
                  this,
                  createDuration(input - offset2, "m"),
                  1,
                  false
                );
              } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
              }
            }
            return this;
          } else {
            return this._isUTC ? offset2 : getDateOffset(this);
          }
        }
        function getSetZone(input, keepLocalTime) {
          if (input != null) {
            if (typeof input !== "string") {
              input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
          } else {
            return -this.utcOffset();
          }
        }
        function setOffsetToUTC(keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
        }
        function setOffsetToLocal(keepLocalTime) {
          if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
              this.subtract(getDateOffset(this), "m");
            }
          }
          return this;
        }
        function setOffsetToParsedOffset() {
          if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
          } else if (typeof this._i === "string") {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
              this.utcOffset(tZone);
            } else {
              this.utcOffset(0, true);
            }
          }
          return this;
        }
        function hasAlignedHourOffset(input) {
          if (!this.isValid()) {
            return false;
          }
          input = input ? createLocal(input).utcOffset() : 0;
          return (this.utcOffset() - input) % 60 === 0;
        }
        function isDaylightSavingTime() {
          return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
        }
        function isDaylightSavingTimeShifted() {
          if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
          }
          var c = {}, other;
          copyConfig(c, this);
          c = prepareConfig(c);
          if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
          } else {
            this._isDSTShifted = false;
          }
          return this._isDSTShifted;
        }
        function isLocal() {
          return this.isValid() ? !this._isUTC : false;
        }
        function isUtcOffset() {
          return this.isValid() ? this._isUTC : false;
        }
        function isUtc() {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
        }
        var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
        function createDuration(input, key) {
          var duration = input, match = null, sign2, ret, diffRes;
          if (isDuration(input)) {
            duration = {
              ms: input._milliseconds,
              d: input._days,
              M: input._months
            };
          } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
              duration[key] = +input;
            } else {
              duration.milliseconds = +input;
            }
          } else if (match = aspNetRegex.exec(input)) {
            sign2 = match[1] === "-" ? -1 : 1;
            duration = {
              y: 0,
              d: toInt(match[DATE]) * sign2,
              h: toInt(match[HOUR]) * sign2,
              m: toInt(match[MINUTE]) * sign2,
              s: toInt(match[SECOND]) * sign2,
              ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
              // the millisecond decimal point is included in the match
            };
          } else if (match = isoRegex.exec(input)) {
            sign2 = match[1] === "-" ? -1 : 1;
            duration = {
              y: parseIso(match[2], sign2),
              M: parseIso(match[3], sign2),
              w: parseIso(match[4], sign2),
              d: parseIso(match[5], sign2),
              h: parseIso(match[6], sign2),
              m: parseIso(match[7], sign2),
              s: parseIso(match[8], sign2)
            };
          } else if (duration == null) {
            duration = {};
          } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
            diffRes = momentsDifference(
              createLocal(duration.from),
              createLocal(duration.to)
            );
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
          }
          ret = new Duration(duration);
          if (isDuration(input) && hasOwnProp(input, "_locale")) {
            ret._locale = input._locale;
          }
          if (isDuration(input) && hasOwnProp(input, "_isValid")) {
            ret._isValid = input._isValid;
          }
          return ret;
        }
        createDuration.fn = Duration.prototype;
        createDuration.invalid = createInvalid$1;
        function parseIso(inp, sign2) {
          var res = inp && parseFloat(inp.replace(",", "."));
          return (isNaN(res) ? 0 : res) * sign2;
        }
        function positiveMomentsDifference(base, other) {
          var res = {};
          res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
          if (base.clone().add(res.months, "M").isAfter(other)) {
            --res.months;
          }
          res.milliseconds = +other - +base.clone().add(res.months, "M");
          return res;
        }
        function momentsDifference(base, other) {
          var res;
          if (!(base.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
          }
          other = cloneWithOffset(other, base);
          if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
          } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
          }
          return res;
        }
        function createAdder(direction, name) {
          return function(val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
              deprecateSimple(
                name,
                "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
              );
              tmp = val;
              val = period;
              period = tmp;
            }
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
          };
        }
        function addSubtract(mom, duration, isAdding, updateOffset) {
          var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
          if (!mom.isValid()) {
            return;
          }
          updateOffset = updateOffset == null ? true : updateOffset;
          if (months2) {
            setMonth(mom, get(mom, "Month") + months2 * isAdding);
          }
          if (days2) {
            set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
          }
          if (milliseconds2) {
            mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
          }
          if (updateOffset) {
            hooks.updateOffset(mom, days2 || months2);
          }
        }
        var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
        function isString(input) {
          return typeof input === "string" || input instanceof String;
        }
        function isMomentInput(input) {
          return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
        }
        function isMomentInputObject(input) {
          var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
            "years",
            "year",
            "y",
            "months",
            "month",
            "M",
            "days",
            "day",
            "d",
            "dates",
            "date",
            "D",
            "hours",
            "hour",
            "h",
            "minutes",
            "minute",
            "m",
            "seconds",
            "second",
            "s",
            "milliseconds",
            "millisecond",
            "ms"
          ], i2, property, propertyLen = properties.length;
          for (i2 = 0; i2 < propertyLen; i2 += 1) {
            property = properties[i2];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function isNumberOrStringArray(input) {
          var arrayTest = isArray(input), dataTypeTest = false;
          if (arrayTest) {
            dataTypeTest = input.filter(function(item) {
              return !isNumber(item) && isString(input);
            }).length === 0;
          }
          return arrayTest && dataTypeTest;
        }
        function isCalendarSpec(input) {
          var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
            "sameDay",
            "nextDay",
            "lastDay",
            "nextWeek",
            "lastWeek",
            "sameElse"
          ], i2, property;
          for (i2 = 0; i2 < properties.length; i2 += 1) {
            property = properties[i2];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function getCalendarFormat(myMoment, now3) {
          var diff2 = myMoment.diff(now3, "days", true);
          return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
        }
        function calendar$1(time, formats) {
          if (arguments.length === 1) {
            if (!arguments[0]) {
              time = void 0;
              formats = void 0;
            } else if (isMomentInput(arguments[0])) {
              time = arguments[0];
              formats = void 0;
            } else if (isCalendarSpec(arguments[0])) {
              formats = arguments[0];
              time = void 0;
            }
          }
          var now3 = time || createLocal(), sod = cloneWithOffset(now3, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now3) : formats[format2]);
          return this.format(
            output || this.localeData().calendar(format2, this, createLocal(now3))
          );
        }
        function clone() {
          return new Moment(this);
        }
        function isAfter(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() > localInput.valueOf();
          } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
        }
        function isBefore(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() < localInput.valueOf();
          } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
        }
        function isBetween(from2, to2, units, inclusivity) {
          var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
          if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
          }
          inclusivity = inclusivity || "()";
          return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
        }
        function isSame(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input), inputMs;
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() === localInput.valueOf();
          } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
          }
        }
        function isSameOrAfter(input, units) {
          return this.isSame(input, units) || this.isAfter(input, units);
        }
        function isSameOrBefore(input, units) {
          return this.isSame(input, units) || this.isBefore(input, units);
        }
        function diff(input, units, asFloat) {
          var that, zoneDelta, output;
          if (!this.isValid()) {
            return NaN;
          }
          that = cloneWithOffset(input, this);
          if (!that.isValid()) {
            return NaN;
          }
          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
          units = normalizeUnits(units);
          switch (units) {
            case "year":
              output = monthDiff(this, that) / 12;
              break;
            case "month":
              output = monthDiff(this, that);
              break;
            case "quarter":
              output = monthDiff(this, that) / 3;
              break;
            case "second":
              output = (this - that) / 1e3;
              break;
            case "minute":
              output = (this - that) / 6e4;
              break;
            case "hour":
              output = (this - that) / 36e5;
              break;
            case "day":
              output = (this - that - zoneDelta) / 864e5;
              break;
            case "week":
              output = (this - that - zoneDelta) / 6048e5;
              break;
            default:
              output = this - that;
          }
          return asFloat ? output : absFloor(output);
        }
        function monthDiff(a, b) {
          if (a.date() < b.date()) {
            return -monthDiff(b, a);
          }
          var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
          if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
            adjust = (b - anchor) / (anchor - anchor2);
          } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
            adjust = (b - anchor) / (anchor2 - anchor);
          }
          return -(wholeMonthDiff + adjust) || 0;
        }
        hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
        hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
        function toString() {
          return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        }
        function toISOString(keepOffset) {
          if (!this.isValid()) {
            return null;
          }
          var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
          if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(
              m,
              utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
            );
          }
          if (isFunction(Date.prototype.toISOString)) {
            if (utc) {
              return this.toDate().toISOString();
            } else {
              return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
            }
          }
          return formatMoment(
            m,
            utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        function inspect() {
          if (!this.isValid()) {
            return "moment.invalid(/* " + this._i + " */)";
          }
          var func = "moment", zone = "", prefix, year, datetime, suffix;
          if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
            zone = "Z";
          }
          prefix = "[" + func + '("]';
          year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
          datetime = "-MM-DD[T]HH:mm:ss.SSS";
          suffix = zone + '[")]';
          return this.format(prefix + year + datetime + suffix);
        }
        function format(inputString) {
          if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
        }
        function from(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function fromNow(withoutSuffix) {
          return this.from(createLocal(), withoutSuffix);
        }
        function to(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function toNow(withoutSuffix) {
          return this.to(createLocal(), withoutSuffix);
        }
        function locale(key) {
          var newLocaleData;
          if (key === void 0) {
            return this._locale._abbr;
          } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
              this._locale = newLocaleData;
            }
            return this;
          }
        }
        var lang = deprecate(
          "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
          function(key) {
            if (key === void 0) {
              return this.localeData();
            } else {
              return this.locale(key);
            }
          }
        );
        function localeData() {
          return this._locale;
        }
        var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
        function mod$1(dividend, divisor) {
          return (dividend % divisor + divisor) % divisor;
        }
        function localStartOfDate(y, m, d) {
          if (y < 100 && y >= 0) {
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return new Date(y, m, d).valueOf();
          }
        }
        function utcStartOfDate(y, m, d) {
          if (y < 100 && y >= 0) {
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return Date.UTC(y, m, d);
          }
        }
        function startOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === void 0 || units === "millisecond" || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case "year":
              time = startOfDate(this.year(), 0, 1);
              break;
            case "quarter":
              time = startOfDate(
                this.year(),
                this.month() - this.month() % 3,
                1
              );
              break;
            case "month":
              time = startOfDate(this.year(), this.month(), 1);
              break;
            case "week":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - this.weekday()
              );
              break;
            case "isoWeek":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - (this.isoWeekday() - 1)
              );
              break;
            case "day":
            case "date":
              time = startOfDate(this.year(), this.month(), this.date());
              break;
            case "hour":
              time = this._d.valueOf();
              time -= mod$1(
                time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                MS_PER_HOUR
              );
              break;
            case "minute":
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_MINUTE);
              break;
            case "second":
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_SECOND);
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function endOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === void 0 || units === "millisecond" || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case "year":
              time = startOfDate(this.year() + 1, 0, 1) - 1;
              break;
            case "quarter":
              time = startOfDate(
                this.year(),
                this.month() - this.month() % 3 + 3,
                1
              ) - 1;
              break;
            case "month":
              time = startOfDate(this.year(), this.month() + 1, 1) - 1;
              break;
            case "week":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - this.weekday() + 7
              ) - 1;
              break;
            case "isoWeek":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - (this.isoWeekday() - 1) + 7
              ) - 1;
              break;
            case "day":
            case "date":
              time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
              break;
            case "hour":
              time = this._d.valueOf();
              time += MS_PER_HOUR - mod$1(
                time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                MS_PER_HOUR
              ) - 1;
              break;
            case "minute":
              time = this._d.valueOf();
              time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
              break;
            case "second":
              time = this._d.valueOf();
              time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function valueOf() {
          return this._d.valueOf() - (this._offset || 0) * 6e4;
        }
        function unix() {
          return Math.floor(this.valueOf() / 1e3);
        }
        function toDate() {
          return new Date(this.valueOf());
        }
        function toArray() {
          var m = this;
          return [
            m.year(),
            m.month(),
            m.date(),
            m.hour(),
            m.minute(),
            m.second(),
            m.millisecond()
          ];
        }
        function toObject() {
          var m = this;
          return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
          };
        }
        function toJSON() {
          return this.isValid() ? this.toISOString() : null;
        }
        function isValid$2() {
          return isValid(this);
        }
        function parsingFlags() {
          return extend({}, getParsingFlags(this));
        }
        function invalidAt() {
          return getParsingFlags(this).overflow;
        }
        function creationData() {
          return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
          };
        }
        addFormatToken("N", 0, 0, "eraAbbr");
        addFormatToken("NN", 0, 0, "eraAbbr");
        addFormatToken("NNN", 0, 0, "eraAbbr");
        addFormatToken("NNNN", 0, 0, "eraName");
        addFormatToken("NNNNN", 0, 0, "eraNarrow");
        addFormatToken("y", ["y", 1], "yo", "eraYear");
        addFormatToken("y", ["yy", 2], 0, "eraYear");
        addFormatToken("y", ["yyy", 3], 0, "eraYear");
        addFormatToken("y", ["yyyy", 4], 0, "eraYear");
        addRegexToken("N", matchEraAbbr);
        addRegexToken("NN", matchEraAbbr);
        addRegexToken("NNN", matchEraAbbr);
        addRegexToken("NNNN", matchEraName);
        addRegexToken("NNNNN", matchEraNarrow);
        addParseToken(
          ["N", "NN", "NNN", "NNNN", "NNNNN"],
          function(input, array, config, token2) {
            var era = config._locale.erasParse(input, token2, config._strict);
            if (era) {
              getParsingFlags(config).era = era;
            } else {
              getParsingFlags(config).invalidEra = input;
            }
          }
        );
        addRegexToken("y", matchUnsigned);
        addRegexToken("yy", matchUnsigned);
        addRegexToken("yyy", matchUnsigned);
        addRegexToken("yyyy", matchUnsigned);
        addRegexToken("yo", matchEraYearOrdinal);
        addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
        addParseToken(["yo"], function(input, array, config, token2) {
          var match;
          if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
          }
          if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
          } else {
            array[YEAR] = parseInt(input, 10);
          }
        });
        function localeEras(m, format2) {
          var i2, l, date, eras = this._eras || getLocale("en")._eras;
          for (i2 = 0, l = eras.length; i2 < l; ++i2) {
            switch (typeof eras[i2].since) {
              case "string":
                date = hooks(eras[i2].since).startOf("day");
                eras[i2].since = date.valueOf();
                break;
            }
            switch (typeof eras[i2].until) {
              case "undefined":
                eras[i2].until = Infinity;
                break;
              case "string":
                date = hooks(eras[i2].until).startOf("day").valueOf();
                eras[i2].until = date.valueOf();
                break;
            }
          }
          return eras;
        }
        function localeErasParse(eraName, format2, strict) {
          var i2, l, eras = this.eras(), name, abbr, narrow;
          eraName = eraName.toUpperCase();
          for (i2 = 0, l = eras.length; i2 < l; ++i2) {
            name = eras[i2].name.toUpperCase();
            abbr = eras[i2].abbr.toUpperCase();
            narrow = eras[i2].narrow.toUpperCase();
            if (strict) {
              switch (format2) {
                case "N":
                case "NN":
                case "NNN":
                  if (abbr === eraName) {
                    return eras[i2];
                  }
                  break;
                case "NNNN":
                  if (name === eraName) {
                    return eras[i2];
                  }
                  break;
                case "NNNNN":
                  if (narrow === eraName) {
                    return eras[i2];
                  }
                  break;
              }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
              return eras[i2];
            }
          }
        }
        function localeErasConvertYear(era, year) {
          var dir = era.since <= era.until ? 1 : -1;
          if (year === void 0) {
            return hooks(era.since).year();
          } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
          }
        }
        function getEraName() {
          var i2, l, val, eras = this.localeData().eras();
          for (i2 = 0, l = eras.length; i2 < l; ++i2) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i2].since <= val && val <= eras[i2].until) {
              return eras[i2].name;
            }
            if (eras[i2].until <= val && val <= eras[i2].since) {
              return eras[i2].name;
            }
          }
          return "";
        }
        function getEraNarrow() {
          var i2, l, val, eras = this.localeData().eras();
          for (i2 = 0, l = eras.length; i2 < l; ++i2) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i2].since <= val && val <= eras[i2].until) {
              return eras[i2].narrow;
            }
            if (eras[i2].until <= val && val <= eras[i2].since) {
              return eras[i2].narrow;
            }
          }
          return "";
        }
        function getEraAbbr() {
          var i2, l, val, eras = this.localeData().eras();
          for (i2 = 0, l = eras.length; i2 < l; ++i2) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i2].since <= val && val <= eras[i2].until) {
              return eras[i2].abbr;
            }
            if (eras[i2].until <= val && val <= eras[i2].since) {
              return eras[i2].abbr;
            }
          }
          return "";
        }
        function getEraYear() {
          var i2, l, dir, val, eras = this.localeData().eras();
          for (i2 = 0, l = eras.length; i2 < l; ++i2) {
            dir = eras[i2].since <= eras[i2].until ? 1 : -1;
            val = this.clone().startOf("day").valueOf();
            if (eras[i2].since <= val && val <= eras[i2].until || eras[i2].until <= val && val <= eras[i2].since) {
              return (this.year() - hooks(eras[i2].since).year()) * dir + eras[i2].offset;
            }
          }
          return this.year();
        }
        function erasNameRegex(isStrict) {
          if (!hasOwnProp(this, "_erasNameRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNameRegex : this._erasRegex;
        }
        function erasAbbrRegex(isStrict) {
          if (!hasOwnProp(this, "_erasAbbrRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasAbbrRegex : this._erasRegex;
        }
        function erasNarrowRegex(isStrict) {
          if (!hasOwnProp(this, "_erasNarrowRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNarrowRegex : this._erasRegex;
        }
        function matchEraAbbr(isStrict, locale2) {
          return locale2.erasAbbrRegex(isStrict);
        }
        function matchEraName(isStrict, locale2) {
          return locale2.erasNameRegex(isStrict);
        }
        function matchEraNarrow(isStrict, locale2) {
          return locale2.erasNarrowRegex(isStrict);
        }
        function matchEraYearOrdinal(isStrict, locale2) {
          return locale2._eraYearOrdinalRegex || matchUnsigned;
        }
        function computeErasParse() {
          var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i2, l, erasName, erasAbbr, erasNarrow, eras = this.eras();
          for (i2 = 0, l = eras.length; i2 < l; ++i2) {
            erasName = regexEscape(eras[i2].name);
            erasAbbr = regexEscape(eras[i2].abbr);
            erasNarrow = regexEscape(eras[i2].narrow);
            namePieces.push(erasName);
            abbrPieces.push(erasAbbr);
            narrowPieces.push(erasNarrow);
            mixedPieces.push(erasName);
            mixedPieces.push(erasAbbr);
            mixedPieces.push(erasNarrow);
          }
          this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
          this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
          this._erasNarrowRegex = new RegExp(
            "^(" + narrowPieces.join("|") + ")",
            "i"
          );
        }
        addFormatToken(0, ["gg", 2], 0, function() {
          return this.weekYear() % 100;
        });
        addFormatToken(0, ["GG", 2], 0, function() {
          return this.isoWeekYear() % 100;
        });
        function addWeekYearFormatToken(token2, getter) {
          addFormatToken(0, [token2, token2.length], 0, getter);
        }
        addWeekYearFormatToken("gggg", "weekYear");
        addWeekYearFormatToken("ggggg", "weekYear");
        addWeekYearFormatToken("GGGG", "isoWeekYear");
        addWeekYearFormatToken("GGGGG", "isoWeekYear");
        addRegexToken("G", matchSigned);
        addRegexToken("g", matchSigned);
        addRegexToken("GG", match1to2, match2);
        addRegexToken("gg", match1to2, match2);
        addRegexToken("GGGG", match1to4, match4);
        addRegexToken("gggg", match1to4, match4);
        addRegexToken("GGGGG", match1to6, match6);
        addRegexToken("ggggg", match1to6, match6);
        addWeekParseToken(
          ["gggg", "ggggg", "GGGG", "GGGGG"],
          function(input, week, config, token2) {
            week[token2.substr(0, 2)] = toInt(input);
          }
        );
        addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
          week[token2] = hooks.parseTwoDigitYear(input);
        });
        function getSetWeekYear(input) {
          return getSetWeekYearHelper.call(
            this,
            input,
            this.week(),
            this.weekday() + this.localeData()._week.dow,
            this.localeData()._week.dow,
            this.localeData()._week.doy
          );
        }
        function getSetISOWeekYear(input) {
          return getSetWeekYearHelper.call(
            this,
            input,
            this.isoWeek(),
            this.isoWeekday(),
            1,
            4
          );
        }
        function getISOWeeksInYear() {
          return weeksInYear(this.year(), 1, 4);
        }
        function getISOWeeksInISOWeekYear() {
          return weeksInYear(this.isoWeekYear(), 1, 4);
        }
        function getWeeksInYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }
        function getWeeksInWeekYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
        }
        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
            return weekOfYear(this, dow, doy).year;
          } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
              week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
        }
        function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
        }
        addFormatToken("Q", 0, "Qo", "quarter");
        addRegexToken("Q", match1);
        addParseToken("Q", function(input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
        });
        function getSetQuarter(input) {
          return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        }
        addFormatToken("D", ["DD", 2], "Do", "date");
        addRegexToken("D", match1to2, match1to2NoLeadingZero);
        addRegexToken("DD", match1to2, match2);
        addRegexToken("Do", function(isStrict, locale2) {
          return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
        });
        addParseToken(["D", "DD"], DATE);
        addParseToken("Do", function(input, array) {
          array[DATE] = toInt(input.match(match1to2)[0]);
        });
        var getSetDayOfMonth = makeGetSet("Date", true);
        addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
        addRegexToken("DDD", match1to3);
        addRegexToken("DDDD", match3);
        addParseToken(["DDD", "DDDD"], function(input, array, config) {
          config._dayOfYear = toInt(input);
        });
        function getSetDayOfYear(input) {
          var dayOfYear = Math.round(
            (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
          ) + 1;
          return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
        }
        addFormatToken("m", ["mm", 2], 0, "minute");
        addRegexToken("m", match1to2, match1to2HasZero);
        addRegexToken("mm", match1to2, match2);
        addParseToken(["m", "mm"], MINUTE);
        var getSetMinute = makeGetSet("Minutes", false);
        addFormatToken("s", ["ss", 2], 0, "second");
        addRegexToken("s", match1to2, match1to2HasZero);
        addRegexToken("ss", match1to2, match2);
        addParseToken(["s", "ss"], SECOND);
        var getSetSecond = makeGetSet("Seconds", false);
        addFormatToken("S", 0, 0, function() {
          return ~~(this.millisecond() / 100);
        });
        addFormatToken(0, ["SS", 2], 0, function() {
          return ~~(this.millisecond() / 10);
        });
        addFormatToken(0, ["SSS", 3], 0, "millisecond");
        addFormatToken(0, ["SSSS", 4], 0, function() {
          return this.millisecond() * 10;
        });
        addFormatToken(0, ["SSSSS", 5], 0, function() {
          return this.millisecond() * 100;
        });
        addFormatToken(0, ["SSSSSS", 6], 0, function() {
          return this.millisecond() * 1e3;
        });
        addFormatToken(0, ["SSSSSSS", 7], 0, function() {
          return this.millisecond() * 1e4;
        });
        addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
          return this.millisecond() * 1e5;
        });
        addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
          return this.millisecond() * 1e6;
        });
        addRegexToken("S", match1to3, match1);
        addRegexToken("SS", match1to3, match2);
        addRegexToken("SSS", match1to3, match3);
        var token, getSetMillisecond;
        for (token = "SSSS"; token.length <= 9; token += "S") {
          addRegexToken(token, matchUnsigned);
        }
        function parseMs(input, array) {
          array[MILLISECOND] = toInt(("0." + input) * 1e3);
        }
        for (token = "S"; token.length <= 9; token += "S") {
          addParseToken(token, parseMs);
        }
        getSetMillisecond = makeGetSet("Milliseconds", false);
        addFormatToken("z", 0, 0, "zoneAbbr");
        addFormatToken("zz", 0, 0, "zoneName");
        function getZoneAbbr() {
          return this._isUTC ? "UTC" : "";
        }
        function getZoneName() {
          return this._isUTC ? "Coordinated Universal Time" : "";
        }
        var proto = Moment.prototype;
        proto.add = add;
        proto.calendar = calendar$1;
        proto.clone = clone;
        proto.diff = diff;
        proto.endOf = endOf;
        proto.format = format;
        proto.from = from;
        proto.fromNow = fromNow;
        proto.to = to;
        proto.toNow = toNow;
        proto.get = stringGet;
        proto.invalidAt = invalidAt;
        proto.isAfter = isAfter;
        proto.isBefore = isBefore;
        proto.isBetween = isBetween;
        proto.isSame = isSame;
        proto.isSameOrAfter = isSameOrAfter;
        proto.isSameOrBefore = isSameOrBefore;
        proto.isValid = isValid$2;
        proto.lang = lang;
        proto.locale = locale;
        proto.localeData = localeData;
        proto.max = prototypeMax;
        proto.min = prototypeMin;
        proto.parsingFlags = parsingFlags;
        proto.set = stringSet;
        proto.startOf = startOf;
        proto.subtract = subtract;
        proto.toArray = toArray;
        proto.toObject = toObject;
        proto.toDate = toDate;
        proto.toISOString = toISOString;
        proto.inspect = inspect;
        if (typeof Symbol !== "undefined" && Symbol.for != null) {
          proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
            return "Moment<" + this.format() + ">";
          };
        }
        proto.toJSON = toJSON;
        proto.toString = toString;
        proto.unix = unix;
        proto.valueOf = valueOf;
        proto.creationData = creationData;
        proto.eraName = getEraName;
        proto.eraNarrow = getEraNarrow;
        proto.eraAbbr = getEraAbbr;
        proto.eraYear = getEraYear;
        proto.year = getSetYear;
        proto.isLeapYear = getIsLeapYear;
        proto.weekYear = getSetWeekYear;
        proto.isoWeekYear = getSetISOWeekYear;
        proto.quarter = proto.quarters = getSetQuarter;
        proto.month = getSetMonth;
        proto.daysInMonth = getDaysInMonth;
        proto.week = proto.weeks = getSetWeek;
        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
        proto.weeksInYear = getWeeksInYear;
        proto.weeksInWeekYear = getWeeksInWeekYear;
        proto.isoWeeksInYear = getISOWeeksInYear;
        proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
        proto.date = getSetDayOfMonth;
        proto.day = proto.days = getSetDayOfWeek;
        proto.weekday = getSetLocaleDayOfWeek;
        proto.isoWeekday = getSetISODayOfWeek;
        proto.dayOfYear = getSetDayOfYear;
        proto.hour = proto.hours = getSetHour;
        proto.minute = proto.minutes = getSetMinute;
        proto.second = proto.seconds = getSetSecond;
        proto.millisecond = proto.milliseconds = getSetMillisecond;
        proto.utcOffset = getSetOffset;
        proto.utc = setOffsetToUTC;
        proto.local = setOffsetToLocal;
        proto.parseZone = setOffsetToParsedOffset;
        proto.hasAlignedHourOffset = hasAlignedHourOffset;
        proto.isDST = isDaylightSavingTime;
        proto.isLocal = isLocal;
        proto.isUtcOffset = isUtcOffset;
        proto.isUtc = isUtc;
        proto.isUTC = isUtc;
        proto.zoneAbbr = getZoneAbbr;
        proto.zoneName = getZoneName;
        proto.dates = deprecate(
          "dates accessor is deprecated. Use date instead.",
          getSetDayOfMonth
        );
        proto.months = deprecate(
          "months accessor is deprecated. Use month instead",
          getSetMonth
        );
        proto.years = deprecate(
          "years accessor is deprecated. Use year instead",
          getSetYear
        );
        proto.zone = deprecate(
          "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
          getSetZone
        );
        proto.isDSTShifted = deprecate(
          "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
          isDaylightSavingTimeShifted
        );
        function createUnix(input) {
          return createLocal(input * 1e3);
        }
        function createInZone() {
          return createLocal.apply(null, arguments).parseZone();
        }
        function preParsePostFormat(string) {
          return string;
        }
        var proto$1 = Locale.prototype;
        proto$1.calendar = calendar;
        proto$1.longDateFormat = longDateFormat;
        proto$1.invalidDate = invalidDate;
        proto$1.ordinal = ordinal;
        proto$1.preparse = preParsePostFormat;
        proto$1.postformat = preParsePostFormat;
        proto$1.relativeTime = relativeTime;
        proto$1.pastFuture = pastFuture;
        proto$1.set = set;
        proto$1.eras = localeEras;
        proto$1.erasParse = localeErasParse;
        proto$1.erasConvertYear = localeErasConvertYear;
        proto$1.erasAbbrRegex = erasAbbrRegex;
        proto$1.erasNameRegex = erasNameRegex;
        proto$1.erasNarrowRegex = erasNarrowRegex;
        proto$1.months = localeMonths;
        proto$1.monthsShort = localeMonthsShort;
        proto$1.monthsParse = localeMonthsParse;
        proto$1.monthsRegex = monthsRegex;
        proto$1.monthsShortRegex = monthsShortRegex;
        proto$1.week = localeWeek;
        proto$1.firstDayOfYear = localeFirstDayOfYear;
        proto$1.firstDayOfWeek = localeFirstDayOfWeek;
        proto$1.weekdays = localeWeekdays;
        proto$1.weekdaysMin = localeWeekdaysMin;
        proto$1.weekdaysShort = localeWeekdaysShort;
        proto$1.weekdaysParse = localeWeekdaysParse;
        proto$1.weekdaysRegex = weekdaysRegex;
        proto$1.weekdaysShortRegex = weekdaysShortRegex;
        proto$1.weekdaysMinRegex = weekdaysMinRegex;
        proto$1.isPM = localeIsPM;
        proto$1.meridiem = localeMeridiem;
        function get$1(format2, index, field, setter) {
          var locale2 = getLocale(), utc = createUTC().set(setter, index);
          return locale2[field](utc, format2);
        }
        function listMonthsImpl(format2, index, field) {
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
          if (index != null) {
            return get$1(format2, index, field, "month");
          }
          var i2, out = [];
          for (i2 = 0; i2 < 12; i2++) {
            out[i2] = get$1(format2, i2, field, "month");
          }
          return out;
        }
        function listWeekdaysImpl(localeSorted, format2, index, field) {
          if (typeof localeSorted === "boolean") {
            if (isNumber(format2)) {
              index = format2;
              format2 = void 0;
            }
            format2 = format2 || "";
          } else {
            format2 = localeSorted;
            index = format2;
            localeSorted = false;
            if (isNumber(format2)) {
              index = format2;
              format2 = void 0;
            }
            format2 = format2 || "";
          }
          var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i2, out = [];
          if (index != null) {
            return get$1(format2, (index + shift) % 7, field, "day");
          }
          for (i2 = 0; i2 < 7; i2++) {
            out[i2] = get$1(format2, (i2 + shift) % 7, field, "day");
          }
          return out;
        }
        function listMonths(format2, index) {
          return listMonthsImpl(format2, index, "months");
        }
        function listMonthsShort(format2, index) {
          return listMonthsImpl(format2, index, "monthsShort");
        }
        function listWeekdays(localeSorted, format2, index) {
          return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
        }
        function listWeekdaysShort(localeSorted, format2, index) {
          return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
        }
        function listWeekdaysMin(localeSorted, format2, index) {
          return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
        }
        getSetGlobalLocale("en", {
          eras: [
            {
              since: "0001-01-01",
              until: Infinity,
              offset: 1,
              name: "Anno Domini",
              narrow: "AD",
              abbr: "AD"
            },
            {
              since: "0000-12-31",
              until: -Infinity,
              offset: 1,
              name: "Before Christ",
              narrow: "BC",
              abbr: "BC"
            }
          ],
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal: function(number) {
            var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
          }
        });
        hooks.lang = deprecate(
          "moment.lang is deprecated. Use moment.locale instead.",
          getSetGlobalLocale
        );
        hooks.langData = deprecate(
          "moment.langData is deprecated. Use moment.localeData instead.",
          getLocale
        );
        var mathAbs = Math.abs;
        function abs() {
          var data = this._data;
          this._milliseconds = mathAbs(this._milliseconds);
          this._days = mathAbs(this._days);
          this._months = mathAbs(this._months);
          data.milliseconds = mathAbs(data.milliseconds);
          data.seconds = mathAbs(data.seconds);
          data.minutes = mathAbs(data.minutes);
          data.hours = mathAbs(data.hours);
          data.months = mathAbs(data.months);
          data.years = mathAbs(data.years);
          return this;
        }
        function addSubtract$1(duration, input, value, direction) {
          var other = createDuration(input, value);
          duration._milliseconds += direction * other._milliseconds;
          duration._days += direction * other._days;
          duration._months += direction * other._months;
          return duration._bubble();
        }
        function add$1(input, value) {
          return addSubtract$1(this, input, value, 1);
        }
        function subtract$1(input, value) {
          return addSubtract$1(this, input, value, -1);
        }
        function absCeil(number) {
          if (number < 0) {
            return Math.floor(number);
          } else {
            return Math.ceil(number);
          }
        }
        function bubble() {
          var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
          if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
            milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
            days2 = 0;
            months2 = 0;
          }
          data.milliseconds = milliseconds2 % 1e3;
          seconds2 = absFloor(milliseconds2 / 1e3);
          data.seconds = seconds2 % 60;
          minutes2 = absFloor(seconds2 / 60);
          data.minutes = minutes2 % 60;
          hours2 = absFloor(minutes2 / 60);
          data.hours = hours2 % 24;
          days2 += absFloor(hours2 / 24);
          monthsFromDays = absFloor(daysToMonths(days2));
          months2 += monthsFromDays;
          days2 -= absCeil(monthsToDays(monthsFromDays));
          years2 = absFloor(months2 / 12);
          months2 %= 12;
          data.days = days2;
          data.months = months2;
          data.years = years2;
          return this;
        }
        function daysToMonths(days2) {
          return days2 * 4800 / 146097;
        }
        function monthsToDays(months2) {
          return months2 * 146097 / 4800;
        }
        function as(units) {
          if (!this.isValid()) {
            return NaN;
          }
          var days2, months2, milliseconds2 = this._milliseconds;
          units = normalizeUnits(units);
          if (units === "month" || units === "quarter" || units === "year") {
            days2 = this._days + milliseconds2 / 864e5;
            months2 = this._months + daysToMonths(days2);
            switch (units) {
              case "month":
                return months2;
              case "quarter":
                return months2 / 3;
              case "year":
                return months2 / 12;
            }
          } else {
            days2 = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
              case "week":
                return days2 / 7 + milliseconds2 / 6048e5;
              case "day":
                return days2 + milliseconds2 / 864e5;
              case "hour":
                return days2 * 24 + milliseconds2 / 36e5;
              case "minute":
                return days2 * 1440 + milliseconds2 / 6e4;
              case "second":
                return days2 * 86400 + milliseconds2 / 1e3;
              case "millisecond":
                return Math.floor(days2 * 864e5) + milliseconds2;
              default:
                throw new Error("Unknown unit " + units);
            }
          }
        }
        function makeAs(alias) {
          return function() {
            return this.as(alias);
          };
        }
        var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y"), valueOf$1 = asMilliseconds;
        function clone$1() {
          return createDuration(this);
        }
        function get$2(units) {
          units = normalizeUnits(units);
          return this.isValid() ? this[units + "s"]() : NaN;
        }
        function makeGetter(name) {
          return function() {
            return this.isValid() ? this._data[name] : NaN;
          };
        }
        var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
        function weeks() {
          return absFloor(this.days() / 7);
        }
        var round = Math.round, thresholds = {
          ss: 44,
          // a few seconds to seconds
          s: 45,
          // seconds to minute
          m: 45,
          // minutes to hour
          h: 22,
          // hours to day
          d: 26,
          // days to month/week
          w: null,
          // weeks to month
          M: 11
          // months to year
        };
        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
          return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }
        function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
          var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
          if (thresholds2.w != null) {
            a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
          }
          a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale2;
          return substituteTimeAgo.apply(null, a);
        }
        function getSetRelativeTimeRounding(roundingFunction) {
          if (roundingFunction === void 0) {
            return round;
          }
          if (typeof roundingFunction === "function") {
            round = roundingFunction;
            return true;
          }
          return false;
        }
        function getSetRelativeTimeThreshold(threshold, limit) {
          if (thresholds[threshold] === void 0) {
            return false;
          }
          if (limit === void 0) {
            return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          if (threshold === "s") {
            thresholds.ss = limit - 1;
          }
          return true;
        }
        function humanize(argWithSuffix, argThresholds) {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var withSuffix = false, th = thresholds, locale2, output;
          if (typeof argWithSuffix === "object") {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
          }
          if (typeof argWithSuffix === "boolean") {
            withSuffix = argWithSuffix;
          }
          if (typeof argThresholds === "object") {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
              th.ss = argThresholds.s - 1;
            }
          }
          locale2 = this.localeData();
          output = relativeTime$1(this, !withSuffix, th, locale2);
          if (withSuffix) {
            output = locale2.pastFuture(+this, output);
          }
          return locale2.postformat(output);
        }
        var abs$1 = Math.abs;
        function sign(x) {
          return (x > 0) - (x < 0) || +x;
        }
        function toISOString$1() {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s2, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
          if (!total) {
            return "P0D";
          }
          minutes2 = absFloor(seconds2 / 60);
          hours2 = absFloor(minutes2 / 60);
          seconds2 %= 60;
          minutes2 %= 60;
          years2 = absFloor(months2 / 12);
          months2 %= 12;
          s2 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
          totalSign = total < 0 ? "-" : "";
          ymSign = sign(this._months) !== sign(total) ? "-" : "";
          daysSign = sign(this._days) !== sign(total) ? "-" : "";
          hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
          return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s2 + "S" : "");
        }
        var proto$2 = Duration.prototype;
        proto$2.isValid = isValid$1;
        proto$2.abs = abs;
        proto$2.add = add$1;
        proto$2.subtract = subtract$1;
        proto$2.as = as;
        proto$2.asMilliseconds = asMilliseconds;
        proto$2.asSeconds = asSeconds;
        proto$2.asMinutes = asMinutes;
        proto$2.asHours = asHours;
        proto$2.asDays = asDays;
        proto$2.asWeeks = asWeeks;
        proto$2.asMonths = asMonths;
        proto$2.asQuarters = asQuarters;
        proto$2.asYears = asYears;
        proto$2.valueOf = valueOf$1;
        proto$2._bubble = bubble;
        proto$2.clone = clone$1;
        proto$2.get = get$2;
        proto$2.milliseconds = milliseconds;
        proto$2.seconds = seconds;
        proto$2.minutes = minutes;
        proto$2.hours = hours;
        proto$2.days = days;
        proto$2.weeks = weeks;
        proto$2.months = months;
        proto$2.years = years;
        proto$2.humanize = humanize;
        proto$2.toISOString = toISOString$1;
        proto$2.toString = toISOString$1;
        proto$2.toJSON = toISOString$1;
        proto$2.locale = locale;
        proto$2.localeData = localeData;
        proto$2.toIsoString = deprecate(
          "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
          toISOString$1
        );
        proto$2.lang = lang;
        addFormatToken("X", 0, 0, "unix");
        addFormatToken("x", 0, 0, "valueOf");
        addRegexToken("x", matchSigned);
        addRegexToken("X", matchTimestamp);
        addParseToken("X", function(input, array, config) {
          config._d = new Date(parseFloat(input) * 1e3);
        });
        addParseToken("x", function(input, array, config) {
          config._d = new Date(toInt(input));
        });
        hooks.version = "2.30.1";
        setHookCallback(createLocal);
        hooks.fn = proto;
        hooks.min = min;
        hooks.max = max;
        hooks.now = now2;
        hooks.utc = createUTC;
        hooks.unix = createUnix;
        hooks.months = listMonths;
        hooks.isDate = isDate;
        hooks.locale = getSetGlobalLocale;
        hooks.invalid = createInvalid;
        hooks.duration = createDuration;
        hooks.isMoment = isMoment;
        hooks.weekdays = listWeekdays;
        hooks.parseZone = createInZone;
        hooks.localeData = getLocale;
        hooks.isDuration = isDuration;
        hooks.monthsShort = listMonthsShort;
        hooks.weekdaysMin = listWeekdaysMin;
        hooks.defineLocale = defineLocale;
        hooks.updateLocale = updateLocale;
        hooks.locales = listLocales;
        hooks.weekdaysShort = listWeekdaysShort;
        hooks.normalizeUnits = normalizeUnits;
        hooks.relativeTimeRounding = getSetRelativeTimeRounding;
        hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
        hooks.calendarFormat = getCalendarFormat;
        hooks.prototype = proto;
        hooks.HTML5_FMT = {
          DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
          // <input type="datetime-local" />
          DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
          // <input type="datetime-local" step="1" />
          DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
          // <input type="datetime-local" step="0.001" />
          DATE: "YYYY-MM-DD",
          // <input type="date" />
          TIME: "HH:mm",
          // <input type="time" />
          TIME_SECONDS: "HH:mm:ss",
          // <input type="time" step="1" />
          TIME_MS: "HH:mm:ss.SSS",
          // <input type="time" step="0.001" />
          WEEK: "GGGG-[W]WW",
          // <input type="week" />
          MONTH: "YYYY-MM"
          // <input type="month" />
        };
        return hooks;
      });
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/scales/scale.time.js
  var require_scale_time = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/scales/scale.time.js"(exports, module) {
      "use strict";
      var moment = require_moment();
      moment = typeof moment === "function" ? moment : window.moment;
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        var interval = {
          millisecond: {
            size: 1,
            steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
          },
          second: {
            size: 1e3,
            steps: [1, 2, 5, 10, 30]
          },
          minute: {
            size: 6e4,
            steps: [1, 2, 5, 10, 30]
          },
          hour: {
            size: 36e5,
            steps: [1, 2, 3, 6, 12]
          },
          day: {
            size: 864e5,
            steps: [1, 2, 5]
          },
          week: {
            size: 6048e5,
            maxStep: 4
          },
          month: {
            size: 2628e6,
            maxStep: 3
          },
          quarter: {
            size: 7884e6,
            maxStep: 4
          },
          year: {
            size: 3154e7,
            maxStep: false
          }
        };
        var defaultConfig = {
          position: "bottom",
          time: {
            parser: false,
            // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
            format: false,
            // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/
            unit: false,
            // false == automatic or override with week, month, year, etc.
            round: false,
            // none, or override with week, month, year, etc.
            displayFormat: false,
            // DEPRECATED
            isoWeekday: false,
            // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/
            minUnit: "millisecond",
            // defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/
            displayFormats: {
              millisecond: "h:mm:ss.SSS a",
              // 11:20:01.123 AM,
              second: "h:mm:ss a",
              // 11:20:01 AM
              minute: "h:mm:ss a",
              // 11:20:01 AM
              hour: "MMM D, hA",
              // Sept 4, 5PM
              day: "ll",
              // Sep 4 2015
              week: "ll",
              // Week 46, or maybe "[W]WW - YYYY" ?
              month: "MMM YYYY",
              // Sept 2015
              quarter: "[Q]Q - YYYY",
              // Q3
              year: "YYYY"
              // 2015
            }
          },
          ticks: {
            autoSkip: false
          }
        };
        function parseTime(axis, label) {
          var timeOpts = axis.options.time;
          if (typeof timeOpts.parser === "string") {
            return moment(label, timeOpts.parser);
          }
          if (typeof timeOpts.parser === "function") {
            return timeOpts.parser(label);
          }
          if (typeof label.getMonth === "function" || typeof label === "number") {
            return moment(label);
          }
          if (label.isValid && label.isValid()) {
            return label;
          }
          var format = timeOpts.format;
          if (typeof format !== "string" && format.call) {
            console.warn("options.time.format is deprecated and replaced by options.time.parser.");
            return format(label);
          }
          return moment(label, format);
        }
        function determineUnit(minUnit, min, max, maxTicks) {
          var units = Object.keys(interval);
          var unit;
          var numUnits = units.length;
          for (var i2 = units.indexOf(minUnit); i2 < numUnits; i2++) {
            unit = units[i2];
            var unitDetails = interval[unit];
            var steps = unitDetails.steps && unitDetails.steps[unitDetails.steps.length - 1] || unitDetails.maxStep;
            if (steps === void 0 || Math.ceil((max - min) / (steps * unitDetails.size)) <= maxTicks) {
              break;
            }
          }
          return unit;
        }
        function determineStepSize(min, max, unit, maxTicks) {
          var unitDefinition = interval[unit];
          var unitSizeInMilliSeconds = unitDefinition.size;
          var sizeInUnits = Math.ceil((max - min) / unitSizeInMilliSeconds);
          var multiplier = 1;
          var range = max - min;
          if (unitDefinition.steps) {
            var numSteps = unitDefinition.steps.length;
            for (var i2 = 0; i2 < numSteps && sizeInUnits > maxTicks; i2++) {
              multiplier = unitDefinition.steps[i2];
              sizeInUnits = Math.ceil(range / (unitSizeInMilliSeconds * multiplier));
            }
          } else {
            while (sizeInUnits > maxTicks && maxTicks > 0) {
              ++multiplier;
              sizeInUnits = Math.ceil(range / (unitSizeInMilliSeconds * multiplier));
            }
          }
          return multiplier;
        }
        function generateTicks(options, dataRange, niceRange) {
          var ticks = [];
          if (options.maxTicks) {
            var stepSize = options.stepSize;
            ticks.push(options.min !== void 0 ? options.min : niceRange.min);
            var cur = moment(niceRange.min);
            while (cur.add(stepSize, options.unit).valueOf() < niceRange.max) {
              ticks.push(cur.valueOf());
            }
            var realMax = options.max || niceRange.max;
            if (ticks[ticks.length - 1] !== realMax) {
              ticks.push(realMax);
            }
          }
          return ticks;
        }
        Chart2.Ticks.generators.time = function(options, dataRange) {
          var niceMin;
          var niceMax;
          var isoWeekday = options.isoWeekday;
          if (options.unit === "week" && isoWeekday !== false) {
            niceMin = moment(dataRange.min).startOf("isoWeek").isoWeekday(isoWeekday).valueOf();
            niceMax = moment(dataRange.max).startOf("isoWeek").isoWeekday(isoWeekday);
            if (dataRange.max - niceMax > 0) {
              niceMax.add(1, "week");
            }
            niceMax = niceMax.valueOf();
          } else {
            niceMin = moment(dataRange.min).startOf(options.unit).valueOf();
            niceMax = moment(dataRange.max).startOf(options.unit);
            if (dataRange.max - niceMax > 0) {
              niceMax.add(1, options.unit);
            }
            niceMax = niceMax.valueOf();
          }
          return generateTicks(options, dataRange, {
            min: niceMin,
            max: niceMax
          });
        };
        var TimeScale = Chart2.Scale.extend({
          initialize: function() {
            if (!moment) {
              throw new Error("Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com");
            }
            Chart2.Scale.prototype.initialize.call(this);
          },
          determineDataLimits: function() {
            var me = this;
            var timeOpts = me.options.time;
            var dataMin = Number.MAX_SAFE_INTEGER;
            var dataMax = Number.MIN_SAFE_INTEGER;
            var chartData = me.chart.data;
            var parsedData = {
              labels: [],
              datasets: []
            };
            var timestamp;
            helpers.each(chartData.labels, function(label, labelIndex) {
              var labelMoment = parseTime(me, label);
              if (labelMoment.isValid()) {
                if (timeOpts.round) {
                  labelMoment.startOf(timeOpts.round);
                }
                timestamp = labelMoment.valueOf();
                dataMin = Math.min(timestamp, dataMin);
                dataMax = Math.max(timestamp, dataMax);
                parsedData.labels[labelIndex] = timestamp;
              }
            });
            helpers.each(chartData.datasets, function(dataset, datasetIndex) {
              var timestamps = [];
              if (typeof dataset.data[0] === "object" && dataset.data[0] !== null && me.chart.isDatasetVisible(datasetIndex)) {
                helpers.each(dataset.data, function(value, dataIndex) {
                  var dataMoment = parseTime(me, me.getRightValue(value));
                  if (dataMoment.isValid()) {
                    if (timeOpts.round) {
                      dataMoment.startOf(timeOpts.round);
                    }
                    timestamp = dataMoment.valueOf();
                    dataMin = Math.min(timestamp, dataMin);
                    dataMax = Math.max(timestamp, dataMax);
                    timestamps[dataIndex] = timestamp;
                  }
                });
              } else {
                timestamps = parsedData.labels.slice();
              }
              parsedData.datasets[datasetIndex] = timestamps;
            });
            me.dataMin = dataMin;
            me.dataMax = dataMax;
            me._parsedData = parsedData;
          },
          buildTicks: function() {
            var me = this;
            var timeOpts = me.options.time;
            var minTimestamp;
            var maxTimestamp;
            var dataMin = me.dataMin;
            var dataMax = me.dataMax;
            if (timeOpts.min) {
              var minMoment = parseTime(me, timeOpts.min);
              if (timeOpts.round) {
                minMoment.round(timeOpts.round);
              }
              minTimestamp = minMoment.valueOf();
            }
            if (timeOpts.max) {
              maxTimestamp = parseTime(me, timeOpts.max).valueOf();
            }
            var maxTicks = me.getLabelCapacity(minTimestamp || dataMin);
            var unit = timeOpts.unit || determineUnit(timeOpts.minUnit, minTimestamp || dataMin, maxTimestamp || dataMax, maxTicks);
            me.displayFormat = timeOpts.displayFormats[unit];
            var stepSize = timeOpts.stepSize || determineStepSize(minTimestamp || dataMin, maxTimestamp || dataMax, unit, maxTicks);
            me.ticks = Chart2.Ticks.generators.time({
              maxTicks,
              min: minTimestamp,
              max: maxTimestamp,
              stepSize,
              unit,
              isoWeekday: timeOpts.isoWeekday
            }, {
              min: dataMin,
              max: dataMax
            });
            me.max = helpers.max(me.ticks);
            me.min = helpers.min(me.ticks);
          },
          // Get tooltip label
          getLabelForIndex: function(index, datasetIndex) {
            var me = this;
            var label = me.chart.data.labels && index < me.chart.data.labels.length ? me.chart.data.labels[index] : "";
            var value = me.chart.data.datasets[datasetIndex].data[index];
            if (value !== null && typeof value === "object") {
              label = me.getRightValue(value);
            }
            if (me.options.time.tooltipFormat) {
              label = parseTime(me, label).format(me.options.time.tooltipFormat);
            }
            return label;
          },
          // Function to format an individual tick mark
          tickFormatFunction: function(tick2, index, ticks) {
            var formattedTick = tick2.format(this.displayFormat);
            var tickOpts = this.options.ticks;
            var callback = helpers.getValueOrDefault(tickOpts.callback, tickOpts.userCallback);
            if (callback) {
              return callback(formattedTick, index, ticks);
            }
            return formattedTick;
          },
          convertTicksToLabels: function() {
            var me = this;
            me.ticksAsTimestamps = me.ticks;
            me.ticks = me.ticks.map(function(tick2) {
              return moment(tick2);
            }).map(me.tickFormatFunction, me);
          },
          getPixelForOffset: function(offset) {
            var me = this;
            var epochWidth = me.max - me.min;
            var decimal = epochWidth ? (offset - me.min) / epochWidth : 0;
            if (me.isHorizontal()) {
              var valueOffset = me.width * decimal;
              return me.left + Math.round(valueOffset);
            }
            var heightOffset = me.height * decimal;
            return me.top + Math.round(heightOffset);
          },
          getPixelForValue: function(value, index, datasetIndex) {
            var me = this;
            var offset = null;
            if (index !== void 0 && datasetIndex !== void 0) {
              offset = me._parsedData.datasets[datasetIndex][index];
            }
            if (offset === null) {
              if (!value || !value.isValid) {
                value = parseTime(me, me.getRightValue(value));
              }
              if (value && value.isValid && value.isValid()) {
                offset = value.valueOf();
              }
            }
            if (offset !== null) {
              return me.getPixelForOffset(offset);
            }
          },
          getPixelForTick: function(index) {
            return this.getPixelForOffset(this.ticksAsTimestamps[index]);
          },
          getValueForPixel: function(pixel) {
            var me = this;
            var innerDimension = me.isHorizontal() ? me.width : me.height;
            var offset = (pixel - (me.isHorizontal() ? me.left : me.top)) / innerDimension;
            return moment(me.min + offset * (me.max - me.min));
          },
          // Crude approximation of what the label width might be
          getLabelWidth: function(label) {
            var me = this;
            var ticks = me.options.ticks;
            var tickLabelWidth = me.ctx.measureText(label).width;
            var cosRotation = Math.cos(helpers.toRadians(ticks.maxRotation));
            var sinRotation = Math.sin(helpers.toRadians(ticks.maxRotation));
            var tickFontSize = helpers.getValueOrDefault(ticks.fontSize, Chart2.defaults.global.defaultFontSize);
            return tickLabelWidth * cosRotation + tickFontSize * sinRotation;
          },
          getLabelCapacity: function(exampleTime) {
            var me = this;
            me.displayFormat = me.options.time.displayFormats.millisecond;
            var exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, []);
            var tickLabelWidth = me.getLabelWidth(exampleLabel);
            var innerWidth = me.isHorizontal() ? me.width : me.height;
            var labelCapacity = innerWidth / tickLabelWidth;
            return labelCapacity;
          }
        });
        Chart2.scaleService.registerScaleType("time", TimeScale, defaultConfig);
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/controllers/controller.bar.js
  var require_controller_bar = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/controllers/controller.bar.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        Chart2.defaults.bar = {
          hover: {
            mode: "label"
          },
          scales: {
            xAxes: [{
              type: "category",
              // Specific to Bar Controller
              categoryPercentage: 0.8,
              barPercentage: 0.9,
              // grid line settings
              gridLines: {
                offsetGridLines: true
              }
            }],
            yAxes: [{
              type: "linear"
            }]
          }
        };
        Chart2.controllers.bar = Chart2.DatasetController.extend({
          dataElementType: Chart2.elements.Rectangle,
          initialize: function() {
            var me = this;
            var meta;
            Chart2.DatasetController.prototype.initialize.apply(me, arguments);
            meta = me.getMeta();
            meta.stack = me.getDataset().stack;
            meta.bar = true;
          },
          update: function(reset) {
            var me = this;
            var elements = me.getMeta().data;
            var i2, ilen;
            me._ruler = me.getRuler();
            for (i2 = 0, ilen = elements.length; i2 < ilen; ++i2) {
              me.updateElement(elements[i2], i2, reset);
            }
          },
          updateElement: function(rectangle, index, reset) {
            var me = this;
            var chart = me.chart;
            var meta = me.getMeta();
            var dataset = me.getDataset();
            var custom = rectangle.custom || {};
            var rectangleOptions = chart.options.elements.rectangle;
            rectangle._xScale = me.getScaleForId(meta.xAxisID);
            rectangle._yScale = me.getScaleForId(meta.yAxisID);
            rectangle._datasetIndex = me.index;
            rectangle._index = index;
            rectangle._model = {
              datasetLabel: dataset.label,
              label: chart.data.labels[index],
              borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,
              backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),
              borderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),
              borderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)
            };
            me.updateElementGeometry(rectangle, index, reset);
            rectangle.pivot();
          },
          /**
           * @private
           */
          updateElementGeometry: function(rectangle, index, reset) {
            var me = this;
            var model = rectangle._model;
            var vscale = me.getValueScale();
            var base = vscale.getBasePixel();
            var horizontal = vscale.isHorizontal();
            var ruler = me._ruler || me.getRuler();
            var vpixels = me.calculateBarValuePixels(me.index, index);
            var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);
            model.horizontal = horizontal;
            model.base = reset ? base : vpixels.base;
            model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
            model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
            model.height = horizontal ? ipixels.size : void 0;
            model.width = horizontal ? void 0 : ipixels.size;
          },
          /**
           * @private
           */
          getValueScaleId: function() {
            return this.getMeta().yAxisID;
          },
          /**
           * @private
           */
          getIndexScaleId: function() {
            return this.getMeta().xAxisID;
          },
          /**
           * @private
           */
          getValueScale: function() {
            return this.getScaleForId(this.getValueScaleId());
          },
          /**
           * @private
           */
          getIndexScale: function() {
            return this.getScaleForId(this.getIndexScaleId());
          },
          /**
           * Returns the effective number of stacks based on groups and bar visibility.
           * @private
           */
          getStackCount: function(last) {
            var me = this;
            var chart = me.chart;
            var scale = me.getIndexScale();
            var stacked = scale.options.stacked;
            var ilen = last === void 0 ? chart.data.datasets.length : last + 1;
            var stacks = [];
            var i2, meta;
            for (i2 = 0; i2 < ilen; ++i2) {
              meta = chart.getDatasetMeta(i2);
              if (meta.bar && chart.isDatasetVisible(i2) && (stacked === false || stacked === true && stacks.indexOf(meta.stack) === -1 || stacked === void 0 && (meta.stack === void 0 || stacks.indexOf(meta.stack) === -1))) {
                stacks.push(meta.stack);
              }
            }
            return stacks.length;
          },
          /**
           * Returns the stack index for the given dataset based on groups and bar visibility.
           * @private
           */
          getStackIndex: function(datasetIndex) {
            return this.getStackCount(datasetIndex) - 1;
          },
          /**
           * @private
           */
          getRuler: function() {
            var me = this;
            var scale = me.getIndexScale();
            var options = scale.options;
            var stackCount = me.getStackCount();
            var fullSize = scale.isHorizontal() ? scale.width : scale.height;
            var tickSize = fullSize / scale.ticks.length;
            var categorySize = tickSize * options.categoryPercentage;
            var fullBarSize = categorySize / stackCount;
            var barSize = fullBarSize * options.barPercentage;
            barSize = Math.min(
              helpers.getValueOrDefault(options.barThickness, barSize),
              helpers.getValueOrDefault(options.maxBarThickness, Infinity)
            );
            return {
              stackCount,
              tickSize,
              categorySize,
              categorySpacing: tickSize - categorySize,
              fullBarSize,
              barSize,
              barSpacing: fullBarSize - barSize,
              scale
            };
          },
          /**
           * Note: pixel values are not clamped to the scale area.
           * @private
           */
          calculateBarValuePixels: function(datasetIndex, index) {
            var me = this;
            var chart = me.chart;
            var meta = me.getMeta();
            var scale = me.getValueScale();
            var datasets = chart.data.datasets;
            var value = Number(datasets[datasetIndex].data[index]);
            var stacked = scale.options.stacked;
            var stack = meta.stack;
            var start = 0;
            var i2, imeta, ivalue, base, head, size;
            if (stacked || stacked === void 0 && stack !== void 0) {
              for (i2 = 0; i2 < datasetIndex; ++i2) {
                imeta = chart.getDatasetMeta(i2);
                if (imeta.bar && imeta.stack === stack && imeta.controller.getValueScaleId() === scale.id && chart.isDatasetVisible(i2)) {
                  ivalue = Number(datasets[i2].data[index]);
                  if (value < 0 && ivalue < 0 || value >= 0 && ivalue > 0) {
                    start += ivalue;
                  }
                }
              }
            }
            base = scale.getPixelForValue(start);
            head = scale.getPixelForValue(start + value);
            size = (head - base) / 2;
            return {
              size,
              base,
              head,
              center: head + size / 2
            };
          },
          /**
           * @private
           */
          calculateBarIndexPixels: function(datasetIndex, index, ruler) {
            var me = this;
            var scale = ruler.scale;
            var isCombo = me.chart.isCombo;
            var stackIndex = me.getStackIndex(datasetIndex);
            var base = scale.getPixelForValue(null, index, datasetIndex, isCombo);
            var size = ruler.barSize;
            base -= isCombo ? ruler.tickSize / 2 : 0;
            base += ruler.fullBarSize * stackIndex;
            base += ruler.categorySpacing / 2;
            base += ruler.barSpacing / 2;
            return {
              size,
              base,
              head: base + size,
              center: base + size / 2
            };
          },
          draw: function() {
            var me = this;
            var chart = me.chart;
            var elements = me.getMeta().data;
            var dataset = me.getDataset();
            var ilen = elements.length;
            var i2 = 0;
            var d;
            helpers.canvas.clipArea(chart.ctx, chart.chartArea);
            for (; i2 < ilen; ++i2) {
              d = dataset.data[i2];
              if (d !== null && d !== void 0 && !isNaN(d)) {
                elements[i2].draw();
              }
            }
            helpers.canvas.unclipArea(chart.ctx);
          },
          setHoverStyle: function(rectangle) {
            var dataset = this.chart.data.datasets[rectangle._datasetIndex];
            var index = rectangle._index;
            var custom = rectangle.custom || {};
            var model = rectangle._model;
            model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
            model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));
            model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
          },
          removeHoverStyle: function(rectangle) {
            var dataset = this.chart.data.datasets[rectangle._datasetIndex];
            var index = rectangle._index;
            var custom = rectangle.custom || {};
            var model = rectangle._model;
            var rectangleElementOptions = this.chart.options.elements.rectangle;
            model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);
            model.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);
            model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);
          }
        });
        Chart2.defaults.horizontalBar = {
          hover: {
            mode: "label"
          },
          scales: {
            xAxes: [{
              type: "linear",
              position: "bottom"
            }],
            yAxes: [{
              position: "left",
              type: "category",
              // Specific to Horizontal Bar Controller
              categoryPercentage: 0.8,
              barPercentage: 0.9,
              // grid line settings
              gridLines: {
                offsetGridLines: true
              }
            }]
          },
          elements: {
            rectangle: {
              borderSkipped: "left"
            }
          },
          tooltips: {
            callbacks: {
              title: function(tooltipItems, data) {
                var title = "";
                if (tooltipItems.length > 0) {
                  if (tooltipItems[0].yLabel) {
                    title = tooltipItems[0].yLabel;
                  } else if (data.labels.length > 0 && tooltipItems[0].index < data.labels.length) {
                    title = data.labels[tooltipItems[0].index];
                  }
                }
                return title;
              },
              label: function(tooltipItem, data) {
                var datasetLabel = data.datasets[tooltipItem.datasetIndex].label || "";
                return datasetLabel + ": " + tooltipItem.xLabel;
              }
            }
          }
        };
        Chart2.controllers.horizontalBar = Chart2.controllers.bar.extend({
          /**
           * @private
           */
          getValueScaleId: function() {
            return this.getMeta().xAxisID;
          },
          /**
           * @private
           */
          getIndexScaleId: function() {
            return this.getMeta().yAxisID;
          }
        });
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/controllers/controller.bubble.js
  var require_controller_bubble = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/controllers/controller.bubble.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        Chart2.defaults.bubble = {
          hover: {
            mode: "single"
          },
          scales: {
            xAxes: [{
              type: "linear",
              // bubble should probably use a linear scale by default
              position: "bottom",
              id: "x-axis-0"
              // need an ID so datasets can reference the scale
            }],
            yAxes: [{
              type: "linear",
              position: "left",
              id: "y-axis-0"
            }]
          },
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(tooltipItem, data) {
                var datasetLabel = data.datasets[tooltipItem.datasetIndex].label || "";
                var dataPoint = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
                return datasetLabel + ": (" + tooltipItem.xLabel + ", " + tooltipItem.yLabel + ", " + dataPoint.r + ")";
              }
            }
          }
        };
        Chart2.controllers.bubble = Chart2.DatasetController.extend({
          dataElementType: Chart2.elements.Point,
          update: function(reset) {
            var me = this;
            var meta = me.getMeta();
            var points = meta.data;
            helpers.each(points, function(point, index) {
              me.updateElement(point, index, reset);
            });
          },
          updateElement: function(point, index, reset) {
            var me = this;
            var meta = me.getMeta();
            var xScale = me.getScaleForId(meta.xAxisID);
            var yScale = me.getScaleForId(meta.yAxisID);
            var custom = point.custom || {};
            var dataset = me.getDataset();
            var data = dataset.data[index];
            var pointElementOptions = me.chart.options.elements.point;
            var dsIndex = me.index;
            helpers.extend(point, {
              // Utility
              _xScale: xScale,
              _yScale: yScale,
              _datasetIndex: dsIndex,
              _index: index,
              // Desired view properties
              _model: {
                x: reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === "object" ? data : NaN, index, dsIndex, me.chart.isCombo),
                y: reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex),
                // Appearance
                radius: reset ? 0 : custom.radius ? custom.radius : me.getRadius(data),
                // Tooltip
                hitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)
              }
            });
            Chart2.DatasetController.prototype.removeHoverStyle.call(me, point, pointElementOptions);
            var model = point._model;
            model.skip = custom.skip ? custom.skip : isNaN(model.x) || isNaN(model.y);
            point.pivot();
          },
          getRadius: function(value) {
            return value.r || this.chart.options.elements.point.radius;
          },
          setHoverStyle: function(point) {
            var me = this;
            Chart2.DatasetController.prototype.setHoverStyle.call(me, point);
            var dataset = me.chart.data.datasets[point._datasetIndex];
            var index = point._index;
            var custom = point.custom || {};
            var model = point._model;
            model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.hoverRadius, index, me.chart.options.elements.point.hoverRadius) + me.getRadius(dataset.data[index]);
          },
          removeHoverStyle: function(point) {
            var me = this;
            Chart2.DatasetController.prototype.removeHoverStyle.call(me, point, me.chart.options.elements.point);
            var dataVal = me.chart.data.datasets[point._datasetIndex].data[point._index];
            var custom = point.custom || {};
            var model = point._model;
            model.radius = custom.radius ? custom.radius : me.getRadius(dataVal);
          }
        });
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/controllers/controller.doughnut.js
  var require_controller_doughnut = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/controllers/controller.doughnut.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers, defaults = Chart2.defaults;
        defaults.doughnut = {
          animation: {
            // Boolean - Whether we animate the rotation of the Doughnut
            animateRotate: true,
            // Boolean - Whether we animate scaling the Doughnut from the centre
            animateScale: false
          },
          aspectRatio: 1,
          hover: {
            mode: "single"
          },
          legendCallback: function(chart) {
            var text2 = [];
            text2.push('<ul class="' + chart.id + '-legend">');
            var data = chart.data;
            var datasets = data.datasets;
            var labels = data.labels;
            if (datasets.length) {
              for (var i2 = 0; i2 < datasets[0].data.length; ++i2) {
                text2.push('<li><span style="background-color:' + datasets[0].backgroundColor[i2] + '"></span>');
                if (labels[i2]) {
                  text2.push(labels[i2]);
                }
                text2.push("</li>");
              }
            }
            text2.push("</ul>");
            return text2.join("");
          },
          legend: {
            labels: {
              generateLabels: function(chart) {
                var data = chart.data;
                if (data.labels.length && data.datasets.length) {
                  return data.labels.map(function(label, i2) {
                    var meta = chart.getDatasetMeta(0);
                    var ds = data.datasets[0];
                    var arc = meta.data[i2];
                    var custom = arc && arc.custom || {};
                    var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;
                    var arcOpts = chart.options.elements.arc;
                    var fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i2, arcOpts.backgroundColor);
                    var stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i2, arcOpts.borderColor);
                    var bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i2, arcOpts.borderWidth);
                    return {
                      text: label,
                      fillStyle: fill,
                      strokeStyle: stroke,
                      lineWidth: bw,
                      hidden: isNaN(ds.data[i2]) || meta.data[i2].hidden,
                      // Extra data used for toggling the correct item
                      index: i2
                    };
                  });
                }
                return [];
              }
            },
            onClick: function(e2, legendItem) {
              var index = legendItem.index;
              var chart = this.chart;
              var i2, ilen, meta;
              for (i2 = 0, ilen = (chart.data.datasets || []).length; i2 < ilen; ++i2) {
                meta = chart.getDatasetMeta(i2);
                if (meta.data[index]) {
                  meta.data[index].hidden = !meta.data[index].hidden;
                }
              }
              chart.update();
            }
          },
          // The percentage of the chart that we cut out of the middle.
          cutoutPercentage: 50,
          // The rotation of the chart, where the first data arc begins.
          rotation: Math.PI * -0.5,
          // The total circumference of the chart.
          circumference: Math.PI * 2,
          // Need to override these to give a nice default
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(tooltipItem, data) {
                var dataLabel = data.labels[tooltipItem.index];
                var value = ": " + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
                if (helpers.isArray(dataLabel)) {
                  dataLabel = dataLabel.slice();
                  dataLabel[0] += value;
                } else {
                  dataLabel += value;
                }
                return dataLabel;
              }
            }
          }
        };
        defaults.pie = helpers.clone(defaults.doughnut);
        helpers.extend(defaults.pie, {
          cutoutPercentage: 0
        });
        Chart2.controllers.doughnut = Chart2.controllers.pie = Chart2.DatasetController.extend({
          dataElementType: Chart2.elements.Arc,
          linkScales: helpers.noop,
          // Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
          getRingIndex: function(datasetIndex) {
            var ringIndex = 0;
            for (var j = 0; j < datasetIndex; ++j) {
              if (this.chart.isDatasetVisible(j)) {
                ++ringIndex;
              }
            }
            return ringIndex;
          },
          update: function(reset) {
            var me = this;
            var chart = me.chart, chartArea = chart.chartArea, opts = chart.options, arcOpts = opts.elements.arc, availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth, availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth, minSize = Math.min(availableWidth, availableHeight), offset = {
              x: 0,
              y: 0
            }, meta = me.getMeta(), cutoutPercentage = opts.cutoutPercentage, circumference = opts.circumference;
            if (circumference < Math.PI * 2) {
              var startAngle = opts.rotation % (Math.PI * 2);
              startAngle += Math.PI * 2 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
              var endAngle = startAngle + circumference;
              var start = { x: Math.cos(startAngle), y: Math.sin(startAngle) };
              var end = { x: Math.cos(endAngle), y: Math.sin(endAngle) };
              var contains0 = startAngle <= 0 && 0 <= endAngle || startAngle <= Math.PI * 2 && Math.PI * 2 <= endAngle;
              var contains90 = startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle;
              var contains180 = startAngle <= -Math.PI && -Math.PI <= endAngle || startAngle <= Math.PI && Math.PI <= endAngle;
              var contains270 = startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle;
              var cutout = cutoutPercentage / 100;
              var min = { x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout)) };
              var max = { x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout)) };
              var size = { width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5 };
              minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
              offset = { x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5 };
            }
            chart.borderWidth = me.getMaxBorderWidth(meta.data);
            chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
            chart.innerRadius = Math.max(cutoutPercentage ? chart.outerRadius / 100 * cutoutPercentage : 0, 0);
            chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
            chart.offsetX = offset.x * chart.outerRadius;
            chart.offsetY = offset.y * chart.outerRadius;
            meta.total = me.calculateTotal();
            me.outerRadius = chart.outerRadius - chart.radiusLength * me.getRingIndex(me.index);
            me.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);
            helpers.each(meta.data, function(arc, index) {
              me.updateElement(arc, index, reset);
            });
          },
          updateElement: function(arc, index, reset) {
            var me = this;
            var chart = me.chart, chartArea = chart.chartArea, opts = chart.options, animationOpts = opts.animation, centerX = (chartArea.left + chartArea.right) / 2, centerY = (chartArea.top + chartArea.bottom) / 2, startAngle = opts.rotation, endAngle = opts.rotation, dataset = me.getDataset(), circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2 * Math.PI)), innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius, outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius, valueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;
            helpers.extend(arc, {
              // Utility
              _datasetIndex: me.index,
              _index: index,
              // Desired view properties
              _model: {
                x: centerX + chart.offsetX,
                y: centerY + chart.offsetY,
                startAngle,
                endAngle,
                circumference,
                outerRadius,
                innerRadius,
                label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
              }
            });
            var model = arc._model;
            this.removeHoverStyle(arc);
            if (!reset || !animationOpts.animateRotate) {
              if (index === 0) {
                model.startAngle = opts.rotation;
              } else {
                model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
              }
              model.endAngle = model.startAngle + model.circumference;
            }
            arc.pivot();
          },
          removeHoverStyle: function(arc) {
            Chart2.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
          },
          calculateTotal: function() {
            var dataset = this.getDataset();
            var meta = this.getMeta();
            var total = 0;
            var value;
            helpers.each(meta.data, function(element2, index) {
              value = dataset.data[index];
              if (!isNaN(value) && !element2.hidden) {
                total += Math.abs(value);
              }
            });
            return total;
          },
          calculateCircumference: function(value) {
            var total = this.getMeta().total;
            if (total > 0 && !isNaN(value)) {
              return Math.PI * 2 * (value / total);
            }
            return 0;
          },
          // gets the max border or hover width to properly scale pie charts
          getMaxBorderWidth: function(elements) {
            var max = 0, index = this.index, length = elements.length, borderWidth, hoverWidth;
            for (var i2 = 0; i2 < length; i2++) {
              borderWidth = elements[i2]._model ? elements[i2]._model.borderWidth : 0;
              hoverWidth = elements[i2]._chart ? elements[i2]._chart.config.data.datasets[index].hoverBorderWidth : 0;
              max = borderWidth > max ? borderWidth : max;
              max = hoverWidth > max ? hoverWidth : max;
            }
            return max;
          }
        });
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/controllers/controller.line.js
  var require_controller_line = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/controllers/controller.line.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        Chart2.defaults.line = {
          showLines: true,
          spanGaps: false,
          hover: {
            mode: "label"
          },
          scales: {
            xAxes: [{
              type: "category",
              id: "x-axis-0"
            }],
            yAxes: [{
              type: "linear",
              id: "y-axis-0"
            }]
          }
        };
        function lineEnabled(dataset, options) {
          return helpers.getValueOrDefault(dataset.showLine, options.showLines);
        }
        Chart2.controllers.line = Chart2.DatasetController.extend({
          datasetElementType: Chart2.elements.Line,
          dataElementType: Chart2.elements.Point,
          update: function(reset) {
            var me = this;
            var meta = me.getMeta();
            var line = meta.dataset;
            var points = meta.data || [];
            var options = me.chart.options;
            var lineElementOptions = options.elements.line;
            var scale = me.getScaleForId(meta.yAxisID);
            var i2, ilen, custom;
            var dataset = me.getDataset();
            var showLine = lineEnabled(dataset, options);
            if (showLine) {
              custom = line.custom || {};
              if (dataset.tension !== void 0 && dataset.lineTension === void 0) {
                dataset.lineTension = dataset.tension;
              }
              line._scale = scale;
              line._datasetIndex = me.index;
              line._children = points;
              line._model = {
                // Appearance
                // The default behavior of lines is to break at null values, according
                // to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
                // This option gives lines the ability to span gaps
                spanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,
                tension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),
                backgroundColor: custom.backgroundColor ? custom.backgroundColor : dataset.backgroundColor || lineElementOptions.backgroundColor,
                borderWidth: custom.borderWidth ? custom.borderWidth : dataset.borderWidth || lineElementOptions.borderWidth,
                borderColor: custom.borderColor ? custom.borderColor : dataset.borderColor || lineElementOptions.borderColor,
                borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : dataset.borderCapStyle || lineElementOptions.borderCapStyle,
                borderDash: custom.borderDash ? custom.borderDash : dataset.borderDash || lineElementOptions.borderDash,
                borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : dataset.borderDashOffset || lineElementOptions.borderDashOffset,
                borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : dataset.borderJoinStyle || lineElementOptions.borderJoinStyle,
                fill: custom.fill ? custom.fill : dataset.fill !== void 0 ? dataset.fill : lineElementOptions.fill,
                steppedLine: custom.steppedLine ? custom.steppedLine : helpers.getValueOrDefault(dataset.steppedLine, lineElementOptions.stepped),
                cubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.getValueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode)
              };
              line.pivot();
            }
            for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
              me.updateElement(points[i2], i2, reset);
            }
            if (showLine && line._model.tension !== 0) {
              me.updateBezierControlPoints();
            }
            for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
              points[i2].pivot();
            }
          },
          getPointBackgroundColor: function(point, index) {
            var backgroundColor = this.chart.options.elements.point.backgroundColor;
            var dataset = this.getDataset();
            var custom = point.custom || {};
            if (custom.backgroundColor) {
              backgroundColor = custom.backgroundColor;
            } else if (dataset.pointBackgroundColor) {
              backgroundColor = helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);
            } else if (dataset.backgroundColor) {
              backgroundColor = dataset.backgroundColor;
            }
            return backgroundColor;
          },
          getPointBorderColor: function(point, index) {
            var borderColor = this.chart.options.elements.point.borderColor;
            var dataset = this.getDataset();
            var custom = point.custom || {};
            if (custom.borderColor) {
              borderColor = custom.borderColor;
            } else if (dataset.pointBorderColor) {
              borderColor = helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);
            } else if (dataset.borderColor) {
              borderColor = dataset.borderColor;
            }
            return borderColor;
          },
          getPointBorderWidth: function(point, index) {
            var borderWidth = this.chart.options.elements.point.borderWidth;
            var dataset = this.getDataset();
            var custom = point.custom || {};
            if (!isNaN(custom.borderWidth)) {
              borderWidth = custom.borderWidth;
            } else if (!isNaN(dataset.pointBorderWidth)) {
              borderWidth = helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);
            } else if (!isNaN(dataset.borderWidth)) {
              borderWidth = dataset.borderWidth;
            }
            return borderWidth;
          },
          updateElement: function(point, index, reset) {
            var me = this;
            var meta = me.getMeta();
            var custom = point.custom || {};
            var dataset = me.getDataset();
            var datasetIndex = me.index;
            var value = dataset.data[index];
            var yScale = me.getScaleForId(meta.yAxisID);
            var xScale = me.getScaleForId(meta.xAxisID);
            var pointOptions = me.chart.options.elements.point;
            var x, y;
            var labels = me.chart.data.labels || [];
            var includeOffset = labels.length === 1 || dataset.data.length === 1 || me.chart.isCombo;
            if (dataset.radius !== void 0 && dataset.pointRadius === void 0) {
              dataset.pointRadius = dataset.radius;
            }
            if (dataset.hitRadius !== void 0 && dataset.pointHitRadius === void 0) {
              dataset.pointHitRadius = dataset.hitRadius;
            }
            x = xScale.getPixelForValue(typeof value === "object" ? value : NaN, index, datasetIndex, includeOffset);
            y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);
            point._xScale = xScale;
            point._yScale = yScale;
            point._datasetIndex = datasetIndex;
            point._index = index;
            point._model = {
              x,
              y,
              skip: custom.skip || isNaN(x) || isNaN(y),
              // Appearance
              radius: custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),
              pointStyle: custom.pointStyle || helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),
              backgroundColor: me.getPointBackgroundColor(point, index),
              borderColor: me.getPointBorderColor(point, index),
              borderWidth: me.getPointBorderWidth(point, index),
              tension: meta.dataset._model ? meta.dataset._model.tension : 0,
              steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,
              // Tooltip
              hitRadius: custom.hitRadius || helpers.getValueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)
            };
          },
          calculatePointY: function(value, index, datasetIndex) {
            var me = this;
            var chart = me.chart;
            var meta = me.getMeta();
            var yScale = me.getScaleForId(meta.yAxisID);
            var sumPos = 0;
            var sumNeg = 0;
            var i2, ds, dsMeta;
            if (yScale.options.stacked) {
              for (i2 = 0; i2 < datasetIndex; i2++) {
                ds = chart.data.datasets[i2];
                dsMeta = chart.getDatasetMeta(i2);
                if (dsMeta.type === "line" && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i2)) {
                  var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));
                  if (stackedRightValue < 0) {
                    sumNeg += stackedRightValue || 0;
                  } else {
                    sumPos += stackedRightValue || 0;
                  }
                }
              }
              var rightValue = Number(yScale.getRightValue(value));
              if (rightValue < 0) {
                return yScale.getPixelForValue(sumNeg + rightValue);
              }
              return yScale.getPixelForValue(sumPos + rightValue);
            }
            return yScale.getPixelForValue(value);
          },
          updateBezierControlPoints: function() {
            var me = this;
            var meta = me.getMeta();
            var area = me.chart.chartArea;
            var points = meta.data || [];
            var i2, ilen, point, model, controlPoints;
            if (meta.dataset._model.spanGaps) {
              points = points.filter(function(pt) {
                return !pt._model.skip;
              });
            }
            function capControlPoint(pt, min, max) {
              return Math.max(Math.min(pt, max), min);
            }
            if (meta.dataset._model.cubicInterpolationMode === "monotone") {
              helpers.splineCurveMonotone(points);
            } else {
              for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
                point = points[i2];
                model = point._model;
                controlPoints = helpers.splineCurve(
                  helpers.previousItem(points, i2)._model,
                  model,
                  helpers.nextItem(points, i2)._model,
                  meta.dataset._model.tension
                );
                model.controlPointPreviousX = controlPoints.previous.x;
                model.controlPointPreviousY = controlPoints.previous.y;
                model.controlPointNextX = controlPoints.next.x;
                model.controlPointNextY = controlPoints.next.y;
              }
            }
            if (me.chart.options.elements.line.capBezierPoints) {
              for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
                model = points[i2]._model;
                model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
                model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
                model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
                model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
              }
            }
          },
          draw: function() {
            var me = this;
            var chart = me.chart;
            var meta = me.getMeta();
            var points = meta.data || [];
            var area = chart.chartArea;
            var ilen = points.length;
            var i2 = 0;
            Chart2.canvasHelpers.clipArea(chart.ctx, area);
            if (lineEnabled(me.getDataset(), chart.options)) {
              meta.dataset.draw();
            }
            Chart2.canvasHelpers.unclipArea(chart.ctx);
            for (; i2 < ilen; ++i2) {
              points[i2].draw(area);
            }
          },
          setHoverStyle: function(point) {
            var dataset = this.chart.data.datasets[point._datasetIndex];
            var index = point._index;
            var custom = point.custom || {};
            var model = point._model;
            model.radius = custom.hoverRadius || helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
            model.backgroundColor = custom.hoverBackgroundColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
            model.borderColor = custom.hoverBorderColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
            model.borderWidth = custom.hoverBorderWidth || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
          },
          removeHoverStyle: function(point) {
            var me = this;
            var dataset = me.chart.data.datasets[point._datasetIndex];
            var index = point._index;
            var custom = point.custom || {};
            var model = point._model;
            if (dataset.radius !== void 0 && dataset.pointRadius === void 0) {
              dataset.pointRadius = dataset.radius;
            }
            model.radius = custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);
            model.backgroundColor = me.getPointBackgroundColor(point, index);
            model.borderColor = me.getPointBorderColor(point, index);
            model.borderWidth = me.getPointBorderWidth(point, index);
          }
        });
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/controllers/controller.polarArea.js
  var require_controller_polarArea = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/controllers/controller.polarArea.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        Chart2.defaults.polarArea = {
          scale: {
            type: "radialLinear",
            angleLines: {
              display: false
            },
            gridLines: {
              circular: true
            },
            pointLabels: {
              display: false
            },
            ticks: {
              beginAtZero: true
            }
          },
          // Boolean - Whether to animate the rotation of the chart
          animation: {
            animateRotate: true,
            animateScale: true
          },
          startAngle: -0.5 * Math.PI,
          aspectRatio: 1,
          legendCallback: function(chart) {
            var text2 = [];
            text2.push('<ul class="' + chart.id + '-legend">');
            var data = chart.data;
            var datasets = data.datasets;
            var labels = data.labels;
            if (datasets.length) {
              for (var i2 = 0; i2 < datasets[0].data.length; ++i2) {
                text2.push('<li><span style="background-color:' + datasets[0].backgroundColor[i2] + '"></span>');
                if (labels[i2]) {
                  text2.push(labels[i2]);
                }
                text2.push("</li>");
              }
            }
            text2.push("</ul>");
            return text2.join("");
          },
          legend: {
            labels: {
              generateLabels: function(chart) {
                var data = chart.data;
                if (data.labels.length && data.datasets.length) {
                  return data.labels.map(function(label, i2) {
                    var meta = chart.getDatasetMeta(0);
                    var ds = data.datasets[0];
                    var arc = meta.data[i2];
                    var custom = arc.custom || {};
                    var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;
                    var arcOpts = chart.options.elements.arc;
                    var fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i2, arcOpts.backgroundColor);
                    var stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i2, arcOpts.borderColor);
                    var bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i2, arcOpts.borderWidth);
                    return {
                      text: label,
                      fillStyle: fill,
                      strokeStyle: stroke,
                      lineWidth: bw,
                      hidden: isNaN(ds.data[i2]) || meta.data[i2].hidden,
                      // Extra data used for toggling the correct item
                      index: i2
                    };
                  });
                }
                return [];
              }
            },
            onClick: function(e2, legendItem) {
              var index = legendItem.index;
              var chart = this.chart;
              var i2, ilen, meta;
              for (i2 = 0, ilen = (chart.data.datasets || []).length; i2 < ilen; ++i2) {
                meta = chart.getDatasetMeta(i2);
                meta.data[index].hidden = !meta.data[index].hidden;
              }
              chart.update();
            }
          },
          // Need to override these to give a nice default
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(tooltipItem, data) {
                return data.labels[tooltipItem.index] + ": " + tooltipItem.yLabel;
              }
            }
          }
        };
        Chart2.controllers.polarArea = Chart2.DatasetController.extend({
          dataElementType: Chart2.elements.Arc,
          linkScales: helpers.noop,
          update: function(reset) {
            var me = this;
            var chart = me.chart;
            var chartArea = chart.chartArea;
            var meta = me.getMeta();
            var opts = chart.options;
            var arcOpts = opts.elements.arc;
            var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
            chart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);
            chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
            chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
            me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
            me.innerRadius = me.outerRadius - chart.radiusLength;
            meta.count = me.countVisibleElements();
            helpers.each(meta.data, function(arc, index) {
              me.updateElement(arc, index, reset);
            });
          },
          updateElement: function(arc, index, reset) {
            var me = this;
            var chart = me.chart;
            var dataset = me.getDataset();
            var opts = chart.options;
            var animationOpts = opts.animation;
            var scale = chart.scale;
            var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;
            var labels = chart.data.labels;
            var circumference = me.calculateCircumference(dataset.data[index]);
            var centerX = scale.xCenter;
            var centerY = scale.yCenter;
            var visibleCount = 0;
            var meta = me.getMeta();
            for (var i2 = 0; i2 < index; ++i2) {
              if (!isNaN(dataset.data[i2]) && !meta.data[i2].hidden) {
                ++visibleCount;
              }
            }
            var datasetStartAngle = opts.startAngle;
            var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
            var startAngle = datasetStartAngle + circumference * visibleCount;
            var endAngle = startAngle + (arc.hidden ? 0 : circumference);
            var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
            helpers.extend(arc, {
              // Utility
              _datasetIndex: me.index,
              _index: index,
              _scale: scale,
              // Desired view properties
              _model: {
                x: centerX,
                y: centerY,
                innerRadius: 0,
                outerRadius: reset ? resetRadius : distance,
                startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
                endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
                label: getValueAtIndexOrDefault(labels, index, labels[index])
              }
            });
            me.removeHoverStyle(arc);
            arc.pivot();
          },
          removeHoverStyle: function(arc) {
            Chart2.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
          },
          countVisibleElements: function() {
            var dataset = this.getDataset();
            var meta = this.getMeta();
            var count = 0;
            helpers.each(meta.data, function(element2, index) {
              if (!isNaN(dataset.data[index]) && !element2.hidden) {
                count++;
              }
            });
            return count;
          },
          calculateCircumference: function(value) {
            var count = this.getMeta().count;
            if (count > 0 && !isNaN(value)) {
              return 2 * Math.PI / count;
            }
            return 0;
          }
        });
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/controllers/controller.radar.js
  var require_controller_radar = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/controllers/controller.radar.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        Chart2.defaults.radar = {
          aspectRatio: 1,
          scale: {
            type: "radialLinear"
          },
          elements: {
            line: {
              tension: 0
              // no bezier in radar
            }
          }
        };
        Chart2.controllers.radar = Chart2.DatasetController.extend({
          datasetElementType: Chart2.elements.Line,
          dataElementType: Chart2.elements.Point,
          linkScales: helpers.noop,
          update: function(reset) {
            var me = this;
            var meta = me.getMeta();
            var line = meta.dataset;
            var points = meta.data;
            var custom = line.custom || {};
            var dataset = me.getDataset();
            var lineElementOptions = me.chart.options.elements.line;
            var scale = me.chart.scale;
            if (dataset.tension !== void 0 && dataset.lineTension === void 0) {
              dataset.lineTension = dataset.tension;
            }
            helpers.extend(meta.dataset, {
              // Utility
              _datasetIndex: me.index,
              _scale: scale,
              // Data
              _children: points,
              _loop: true,
              // Model
              _model: {
                // Appearance
                tension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),
                backgroundColor: custom.backgroundColor ? custom.backgroundColor : dataset.backgroundColor || lineElementOptions.backgroundColor,
                borderWidth: custom.borderWidth ? custom.borderWidth : dataset.borderWidth || lineElementOptions.borderWidth,
                borderColor: custom.borderColor ? custom.borderColor : dataset.borderColor || lineElementOptions.borderColor,
                fill: custom.fill ? custom.fill : dataset.fill !== void 0 ? dataset.fill : lineElementOptions.fill,
                borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : dataset.borderCapStyle || lineElementOptions.borderCapStyle,
                borderDash: custom.borderDash ? custom.borderDash : dataset.borderDash || lineElementOptions.borderDash,
                borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : dataset.borderDashOffset || lineElementOptions.borderDashOffset,
                borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : dataset.borderJoinStyle || lineElementOptions.borderJoinStyle
              }
            });
            meta.dataset.pivot();
            helpers.each(points, function(point, index) {
              me.updateElement(point, index, reset);
            }, me);
            me.updateBezierControlPoints();
          },
          updateElement: function(point, index, reset) {
            var me = this;
            var custom = point.custom || {};
            var dataset = me.getDataset();
            var scale = me.chart.scale;
            var pointElementOptions = me.chart.options.elements.point;
            var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);
            if (dataset.radius !== void 0 && dataset.pointRadius === void 0) {
              dataset.pointRadius = dataset.radius;
            }
            if (dataset.hitRadius !== void 0 && dataset.pointHitRadius === void 0) {
              dataset.pointHitRadius = dataset.hitRadius;
            }
            helpers.extend(point, {
              // Utility
              _datasetIndex: me.index,
              _index: index,
              _scale: scale,
              // Desired view properties
              _model: {
                x: reset ? scale.xCenter : pointPosition.x,
                // value not used in dataset scale, but we want a consistent API between scales
                y: reset ? scale.yCenter : pointPosition.y,
                // Appearance
                tension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),
                radius: custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),
                backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),
                borderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),
                borderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),
                pointStyle: custom.pointStyle ? custom.pointStyle : helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),
                // Tooltip
                hitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)
              }
            });
            point._model.skip = custom.skip ? custom.skip : isNaN(point._model.x) || isNaN(point._model.y);
          },
          updateBezierControlPoints: function() {
            var chartArea = this.chart.chartArea;
            var meta = this.getMeta();
            helpers.each(meta.data, function(point, index) {
              var model = point._model;
              var controlPoints = helpers.splineCurve(
                helpers.previousItem(meta.data, index, true)._model,
                model,
                helpers.nextItem(meta.data, index, true)._model,
                model.tension
              );
              model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);
              model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);
              model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);
              model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);
              point.pivot();
            });
          },
          setHoverStyle: function(point) {
            var dataset = this.chart.data.datasets[point._datasetIndex];
            var custom = point.custom || {};
            var index = point._index;
            var model = point._model;
            model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
            model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
            model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
            model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
          },
          removeHoverStyle: function(point) {
            var dataset = this.chart.data.datasets[point._datasetIndex];
            var custom = point.custom || {};
            var index = point._index;
            var model = point._model;
            var pointElementOptions = this.chart.options.elements.point;
            model.radius = custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius);
            model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);
            model.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);
            model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);
          }
        });
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/charts/Chart.Bar.js
  var require_Chart_Bar = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/charts/Chart.Bar.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        Chart2.Bar = function(context, config) {
          config.type = "bar";
          return new Chart2(context, config);
        };
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/charts/Chart.Bubble.js
  var require_Chart_Bubble = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/charts/Chart.Bubble.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        Chart2.Bubble = function(context, config) {
          config.type = "bubble";
          return new Chart2(context, config);
        };
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/charts/Chart.Doughnut.js
  var require_Chart_Doughnut = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/charts/Chart.Doughnut.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        Chart2.Doughnut = function(context, config) {
          config.type = "doughnut";
          return new Chart2(context, config);
        };
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/charts/Chart.Line.js
  var require_Chart_Line = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/charts/Chart.Line.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        Chart2.Line = function(context, config) {
          config.type = "line";
          return new Chart2(context, config);
        };
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/charts/Chart.PolarArea.js
  var require_Chart_PolarArea = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/charts/Chart.PolarArea.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        Chart2.PolarArea = function(context, config) {
          config.type = "polarArea";
          return new Chart2(context, config);
        };
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/charts/Chart.Radar.js
  var require_Chart_Radar = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/charts/Chart.Radar.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        Chart2.Radar = function(context, config) {
          config.type = "radar";
          return new Chart2(context, config);
        };
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/charts/Chart.Scatter.js
  var require_Chart_Scatter = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/charts/Chart.Scatter.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var defaultConfig = {
          hover: {
            mode: "single"
          },
          scales: {
            xAxes: [{
              type: "linear",
              // scatter should not use a category axis
              position: "bottom",
              id: "x-axis-1"
              // need an ID so datasets can reference the scale
            }],
            yAxes: [{
              type: "linear",
              position: "left",
              id: "y-axis-1"
            }]
          },
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(tooltipItem) {
                return "(" + tooltipItem.xLabel + ", " + tooltipItem.yLabel + ")";
              }
            }
          }
        };
        Chart2.defaults.scatter = defaultConfig;
        Chart2.controllers.scatter = Chart2.controllers.line;
        Chart2.Scatter = function(context, config) {
          config.type = "scatter";
          return new Chart2(context, config);
        };
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/plugins/plugin.filler.js
  var require_plugin_filler = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/plugins/plugin.filler.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        Chart2.defaults.global.plugins.filler = {
          propagate: true
        };
        var defaults = Chart2.defaults;
        var helpers = Chart2.helpers;
        var mappers = {
          dataset: function(source) {
            var index = source.fill;
            var chart = source.chart;
            var meta = chart.getDatasetMeta(index);
            var visible = meta && chart.isDatasetVisible(index);
            var points = visible && meta.dataset._children || [];
            return !points.length ? null : function(point, i2) {
              return points[i2]._view || null;
            };
          },
          boundary: function(source) {
            var boundary = source.boundary;
            var x = boundary ? boundary.x : null;
            var y = boundary ? boundary.y : null;
            return function(point) {
              return {
                x: x === null ? point.x : x,
                y: y === null ? point.y : y
              };
            };
          }
        };
        function decodeFill(el, index, count) {
          var model = el._model || {};
          var fill = model.fill;
          var target;
          if (fill === void 0) {
            fill = !!model.backgroundColor;
          }
          if (fill === false || fill === null) {
            return false;
          }
          if (fill === true) {
            return "origin";
          }
          target = parseFloat(fill, 10);
          if (isFinite(target) && Math.floor(target) === target) {
            if (fill[0] === "-" || fill[0] === "+") {
              target = index + target;
            }
            if (target === index || target < 0 || target >= count) {
              return false;
            }
            return target;
          }
          switch (fill) {
            case "bottom":
              return "start";
            case "top":
              return "end";
            case "zero":
              return "origin";
            case "origin":
            case "start":
            case "end":
              return fill;
            default:
              return false;
          }
        }
        function computeBoundary(source) {
          var model = source.el._model || {};
          var scale = source.el._scale || {};
          var fill = source.fill;
          var target = null;
          var horizontal;
          if (isFinite(fill)) {
            return null;
          }
          if (fill === "start") {
            target = model.scaleBottom === void 0 ? scale.bottom : model.scaleBottom;
          } else if (fill === "end") {
            target = model.scaleTop === void 0 ? scale.top : model.scaleTop;
          } else if (model.scaleZero !== void 0) {
            target = model.scaleZero;
          } else if (scale.getBasePosition) {
            target = scale.getBasePosition();
          } else if (scale.getBasePixel) {
            target = scale.getBasePixel();
          }
          if (target !== void 0 && target !== null) {
            if (target.x !== void 0 && target.y !== void 0) {
              return target;
            }
            if (typeof target === "number" && isFinite(target)) {
              horizontal = scale.isHorizontal();
              return {
                x: horizontal ? target : null,
                y: horizontal ? null : target
              };
            }
          }
          return null;
        }
        function resolveTarget(sources, index, propagate) {
          var source = sources[index];
          var fill = source.fill;
          var visited = [index];
          var target;
          if (!propagate) {
            return fill;
          }
          while (fill !== false && visited.indexOf(fill) === -1) {
            if (!isFinite(fill)) {
              return fill;
            }
            target = sources[fill];
            if (!target) {
              return false;
            }
            if (target.visible) {
              return fill;
            }
            visited.push(fill);
            fill = target.fill;
          }
          return false;
        }
        function createMapper(source) {
          var fill = source.fill;
          var type = "dataset";
          if (fill === false) {
            return null;
          }
          if (!isFinite(fill)) {
            type = "boundary";
          }
          return mappers[type](source);
        }
        function isDrawable(point) {
          return point && !point.skip;
        }
        function drawArea(ctx, curve0, curve1, len0, len1) {
          var i2;
          if (!len0 || !len1) {
            return;
          }
          ctx.moveTo(curve0[0].x, curve0[0].y);
          for (i2 = 1; i2 < len0; ++i2) {
            helpers.canvas.lineTo(ctx, curve0[i2 - 1], curve0[i2]);
          }
          ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);
          for (i2 = len1 - 1; i2 > 0; --i2) {
            helpers.canvas.lineTo(ctx, curve1[i2], curve1[i2 - 1], true);
          }
        }
        function doFill(ctx, points, mapper, view, color, loop2) {
          var count = points.length;
          var span = view.spanGaps;
          var curve0 = [];
          var curve1 = [];
          var len0 = 0;
          var len1 = 0;
          var i2, ilen, index, p0, p1, d0, d1;
          ctx.beginPath();
          for (i2 = 0, ilen = count + !!loop2; i2 < ilen; ++i2) {
            index = i2 % count;
            p0 = points[index]._view;
            p1 = mapper(p0, index, view);
            d0 = isDrawable(p0);
            d1 = isDrawable(p1);
            if (d0 && d1) {
              len0 = curve0.push(p0);
              len1 = curve1.push(p1);
            } else if (len0 && len1) {
              if (!span) {
                drawArea(ctx, curve0, curve1, len0, len1);
                len0 = len1 = 0;
                curve0 = [];
                curve1 = [];
              } else {
                if (d0) {
                  curve0.push(p0);
                }
                if (d1) {
                  curve1.push(p1);
                }
              }
            }
          }
          drawArea(ctx, curve0, curve1, len0, len1);
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.fill();
        }
        return {
          id: "filler",
          afterDatasetsUpdate: function(chart, options) {
            var count = (chart.data.datasets || []).length;
            var propagate = options.propagate;
            var sources = [];
            var meta, i2, el, source;
            for (i2 = 0; i2 < count; ++i2) {
              meta = chart.getDatasetMeta(i2);
              el = meta.dataset;
              source = null;
              if (el && el._model && el instanceof Chart2.elements.Line) {
                source = {
                  visible: chart.isDatasetVisible(i2),
                  fill: decodeFill(el, i2, count),
                  chart,
                  el
                };
              }
              meta.$filler = source;
              sources.push(source);
            }
            for (i2 = 0; i2 < count; ++i2) {
              source = sources[i2];
              if (!source) {
                continue;
              }
              source.fill = resolveTarget(sources, i2, propagate);
              source.boundary = computeBoundary(source);
              source.mapper = createMapper(source);
            }
          },
          beforeDatasetDraw: function(chart, args) {
            var meta = args.meta.$filler;
            if (!meta) {
              return;
            }
            var el = meta.el;
            var view = el._view;
            var points = el._children || [];
            var mapper = meta.mapper;
            var color = view.backgroundColor || defaults.global.defaultColor;
            if (mapper && color && points.length) {
              doFill(chart.ctx, points, mapper, view, color, el._loop);
            }
          }
        };
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/plugins/plugin.legend.js
  var require_plugin_legend = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/plugins/plugin.legend.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        var layout = Chart2.layoutService;
        var noop2 = helpers.noop;
        Chart2.defaults.global.legend = {
          display: true,
          position: "top",
          fullWidth: true,
          reverse: false,
          weight: 1e3,
          // a callback that will handle
          onClick: function(e2, legendItem) {
            var index = legendItem.datasetIndex;
            var ci = this.chart;
            var meta = ci.getDatasetMeta(index);
            meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;
            ci.update();
          },
          onHover: null,
          labels: {
            boxWidth: 40,
            padding: 10,
            // Generates labels shown in the legend
            // Valid properties to return:
            // text : text to display
            // fillStyle : fill of coloured box
            // strokeStyle: stroke of coloured box
            // hidden : if this legend item refers to a hidden item
            // lineCap : cap style for line
            // lineDash
            // lineDashOffset :
            // lineJoin :
            // lineWidth :
            generateLabels: function(chart) {
              var data = chart.data;
              return helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i2) {
                return {
                  text: dataset.label,
                  fillStyle: !helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0],
                  hidden: !chart.isDatasetVisible(i2),
                  lineCap: dataset.borderCapStyle,
                  lineDash: dataset.borderDash,
                  lineDashOffset: dataset.borderDashOffset,
                  lineJoin: dataset.borderJoinStyle,
                  lineWidth: dataset.borderWidth,
                  strokeStyle: dataset.borderColor,
                  pointStyle: dataset.pointStyle,
                  // Below is extra data used for toggling the datasets
                  datasetIndex: i2
                };
              }, this) : [];
            }
          }
        };
        function getBoxWidth(labelOpts, fontSize) {
          return labelOpts.usePointStyle ? fontSize * Math.SQRT2 : labelOpts.boxWidth;
        }
        Chart2.Legend = Chart2.Element.extend({
          initialize: function(config) {
            helpers.extend(this, config);
            this.legendHitBoxes = [];
            this.doughnutMode = false;
          },
          // These methods are ordered by lifecycle. Utilities then follow.
          // Any function defined here is inherited by all legend types.
          // Any function can be extended by the legend type
          beforeUpdate: noop2,
          update: function(maxWidth, maxHeight, margins) {
            var me = this;
            me.beforeUpdate();
            me.maxWidth = maxWidth;
            me.maxHeight = maxHeight;
            me.margins = margins;
            me.beforeSetDimensions();
            me.setDimensions();
            me.afterSetDimensions();
            me.beforeBuildLabels();
            me.buildLabels();
            me.afterBuildLabels();
            me.beforeFit();
            me.fit();
            me.afterFit();
            me.afterUpdate();
            return me.minSize;
          },
          afterUpdate: noop2,
          //
          beforeSetDimensions: noop2,
          setDimensions: function() {
            var me = this;
            if (me.isHorizontal()) {
              me.width = me.maxWidth;
              me.left = 0;
              me.right = me.width;
            } else {
              me.height = me.maxHeight;
              me.top = 0;
              me.bottom = me.height;
            }
            me.paddingLeft = 0;
            me.paddingTop = 0;
            me.paddingRight = 0;
            me.paddingBottom = 0;
            me.minSize = {
              width: 0,
              height: 0
            };
          },
          afterSetDimensions: noop2,
          //
          beforeBuildLabels: noop2,
          buildLabels: function() {
            var me = this;
            var labelOpts = me.options.labels;
            var legendItems = labelOpts.generateLabels.call(me, me.chart);
            if (labelOpts.filter) {
              legendItems = legendItems.filter(function(item) {
                return labelOpts.filter(item, me.chart.data);
              });
            }
            if (me.options.reverse) {
              legendItems.reverse();
            }
            me.legendItems = legendItems;
          },
          afterBuildLabels: noop2,
          //
          beforeFit: noop2,
          fit: function() {
            var me = this;
            var opts = me.options;
            var labelOpts = opts.labels;
            var display = opts.display;
            var ctx = me.ctx;
            var globalDefault = Chart2.defaults.global, itemOrDefault = helpers.getValueOrDefault, fontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize), fontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle), fontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily), labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
            var hitboxes = me.legendHitBoxes = [];
            var minSize = me.minSize;
            var isHorizontal = me.isHorizontal();
            if (isHorizontal) {
              minSize.width = me.maxWidth;
              minSize.height = display ? 10 : 0;
            } else {
              minSize.width = display ? 10 : 0;
              minSize.height = me.maxHeight;
            }
            if (display) {
              ctx.font = labelFont;
              if (isHorizontal) {
                var lineWidths = me.lineWidths = [0];
                var totalHeight = me.legendItems.length ? fontSize + labelOpts.padding : 0;
                ctx.textAlign = "left";
                ctx.textBaseline = "top";
                helpers.each(me.legendItems, function(legendItem, i2) {
                  var boxWidth = getBoxWidth(labelOpts, fontSize);
                  var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
                  if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {
                    totalHeight += fontSize + labelOpts.padding;
                    lineWidths[lineWidths.length] = me.left;
                  }
                  hitboxes[i2] = {
                    left: 0,
                    top: 0,
                    width,
                    height: fontSize
                  };
                  lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
                });
                minSize.height += totalHeight;
              } else {
                var vPadding = labelOpts.padding;
                var columnWidths = me.columnWidths = [];
                var totalWidth = labelOpts.padding;
                var currentColWidth = 0;
                var currentColHeight = 0;
                var itemHeight = fontSize + vPadding;
                helpers.each(me.legendItems, function(legendItem, i2) {
                  var boxWidth = getBoxWidth(labelOpts, fontSize);
                  var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
                  if (currentColHeight + itemHeight > minSize.height) {
                    totalWidth += currentColWidth + labelOpts.padding;
                    columnWidths.push(currentColWidth);
                    currentColWidth = 0;
                    currentColHeight = 0;
                  }
                  currentColWidth = Math.max(currentColWidth, itemWidth);
                  currentColHeight += itemHeight;
                  hitboxes[i2] = {
                    left: 0,
                    top: 0,
                    width: itemWidth,
                    height: fontSize
                  };
                });
                totalWidth += currentColWidth;
                columnWidths.push(currentColWidth);
                minSize.width += totalWidth;
              }
            }
            me.width = minSize.width;
            me.height = minSize.height;
          },
          afterFit: noop2,
          // Shared Methods
          isHorizontal: function() {
            return this.options.position === "top" || this.options.position === "bottom";
          },
          // Actually draw the legend on the canvas
          draw: function() {
            var me = this;
            var opts = me.options;
            var labelOpts = opts.labels;
            var globalDefault = Chart2.defaults.global, lineDefault = globalDefault.elements.line, legendWidth = me.width, lineWidths = me.lineWidths;
            if (opts.display) {
              var ctx = me.ctx, cursor, itemOrDefault = helpers.getValueOrDefault, fontColor = itemOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor), fontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize), fontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle), fontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily), labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
              ctx.textAlign = "left";
              ctx.textBaseline = "top";
              ctx.lineWidth = 0.5;
              ctx.strokeStyle = fontColor;
              ctx.fillStyle = fontColor;
              ctx.font = labelFont;
              var boxWidth = getBoxWidth(labelOpts, fontSize), hitboxes = me.legendHitBoxes;
              var drawLegendBox = function(x, y, legendItem) {
                if (isNaN(boxWidth) || boxWidth <= 0) {
                  return;
                }
                ctx.save();
                ctx.fillStyle = itemOrDefault(legendItem.fillStyle, globalDefault.defaultColor);
                ctx.lineCap = itemOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
                ctx.lineDashOffset = itemOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
                ctx.lineJoin = itemOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
                ctx.lineWidth = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
                ctx.strokeStyle = itemOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);
                var isLineWidthZero = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0;
                if (ctx.setLineDash) {
                  ctx.setLineDash(itemOrDefault(legendItem.lineDash, lineDefault.borderDash));
                }
                if (opts.labels && opts.labels.usePointStyle) {
                  var radius = fontSize * Math.SQRT2 / 2;
                  var offSet = radius / Math.SQRT2;
                  var centerX = x + offSet;
                  var centerY = y + offSet;
                  Chart2.canvasHelpers.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
                } else {
                  if (!isLineWidthZero) {
                    ctx.strokeRect(x, y, boxWidth, fontSize);
                  }
                  ctx.fillRect(x, y, boxWidth, fontSize);
                }
                ctx.restore();
              };
              var fillText = function(x, y, legendItem, textWidth) {
                ctx.fillText(legendItem.text, boxWidth + fontSize / 2 + x, y);
                if (legendItem.hidden) {
                  ctx.beginPath();
                  ctx.lineWidth = 2;
                  ctx.moveTo(boxWidth + fontSize / 2 + x, y + fontSize / 2);
                  ctx.lineTo(boxWidth + fontSize / 2 + x + textWidth, y + fontSize / 2);
                  ctx.stroke();
                }
              };
              var isHorizontal = me.isHorizontal();
              if (isHorizontal) {
                cursor = {
                  x: me.left + (legendWidth - lineWidths[0]) / 2,
                  y: me.top + labelOpts.padding,
                  line: 0
                };
              } else {
                cursor = {
                  x: me.left + labelOpts.padding,
                  y: me.top + labelOpts.padding,
                  line: 0
                };
              }
              var itemHeight = fontSize + labelOpts.padding;
              helpers.each(me.legendItems, function(legendItem, i2) {
                var textWidth = ctx.measureText(legendItem.text).width, width = boxWidth + fontSize / 2 + textWidth, x = cursor.x, y = cursor.y;
                if (isHorizontal) {
                  if (x + width >= legendWidth) {
                    y = cursor.y += itemHeight;
                    cursor.line++;
                    x = cursor.x = me.left + (legendWidth - lineWidths[cursor.line]) / 2;
                  }
                } else if (y + itemHeight > me.bottom) {
                  x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
                  y = cursor.y = me.top + labelOpts.padding;
                  cursor.line++;
                }
                drawLegendBox(x, y, legendItem);
                hitboxes[i2].left = x;
                hitboxes[i2].top = y;
                fillText(x, y, legendItem, textWidth);
                if (isHorizontal) {
                  cursor.x += width + labelOpts.padding;
                } else {
                  cursor.y += itemHeight;
                }
              });
            }
          },
          /**
           * Handle an event
           * @private
           * @param {IEvent} event - The event to handle
           * @return {Boolean} true if a change occured
           */
          handleEvent: function(e2) {
            var me = this;
            var opts = me.options;
            var type = e2.type === "mouseup" ? "click" : e2.type;
            var changed = false;
            if (type === "mousemove") {
              if (!opts.onHover) {
                return;
              }
            } else if (type === "click") {
              if (!opts.onClick) {
                return;
              }
            } else {
              return;
            }
            var x = e2.x, y = e2.y;
            if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
              var lh = me.legendHitBoxes;
              for (var i2 = 0; i2 < lh.length; ++i2) {
                var hitBox = lh[i2];
                if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
                  if (type === "click") {
                    opts.onClick.call(me, e2.native, me.legendItems[i2]);
                    changed = true;
                    break;
                  } else if (type === "mousemove") {
                    opts.onHover.call(me, e2.native, me.legendItems[i2]);
                    changed = true;
                    break;
                  }
                }
              }
            }
            return changed;
          }
        });
        function createNewLegendAndAttach(chart, legendOpts) {
          var legend = new Chart2.Legend({
            ctx: chart.ctx,
            options: legendOpts,
            chart
          });
          layout.configure(chart, legend, legendOpts);
          layout.addBox(chart, legend);
          chart.legend = legend;
        }
        return {
          id: "legend",
          beforeInit: function(chart) {
            var legendOpts = chart.options.legend;
            if (legendOpts) {
              createNewLegendAndAttach(chart, legendOpts);
            }
          },
          beforeUpdate: function(chart) {
            var legendOpts = chart.options.legend;
            var legend = chart.legend;
            if (legendOpts) {
              legendOpts = helpers.configMerge(Chart2.defaults.global.legend, legendOpts);
              if (legend) {
                layout.configure(chart, legend, legendOpts);
                legend.options = legendOpts;
              } else {
                createNewLegendAndAttach(chart, legendOpts);
              }
            } else if (legend) {
              layout.removeBox(chart, legend);
              delete chart.legend;
            }
          },
          afterEvent: function(chart, e2) {
            var legend = chart.legend;
            if (legend) {
              legend.handleEvent(e2);
            }
          }
        };
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/plugins/plugin.title.js
  var require_plugin_title = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/plugins/plugin.title.js"(exports, module) {
      "use strict";
      module.exports = function(Chart2) {
        var helpers = Chart2.helpers;
        var layout = Chart2.layoutService;
        var noop2 = helpers.noop;
        Chart2.defaults.global.title = {
          display: false,
          position: "top",
          fullWidth: true,
          weight: 2e3,
          // by default greater than legend (1000) to be above
          fontStyle: "bold",
          padding: 10,
          // actual title
          text: ""
        };
        Chart2.Title = Chart2.Element.extend({
          initialize: function(config) {
            var me = this;
            helpers.extend(me, config);
            me.legendHitBoxes = [];
          },
          // These methods are ordered by lifecycle. Utilities then follow.
          beforeUpdate: noop2,
          update: function(maxWidth, maxHeight, margins) {
            var me = this;
            me.beforeUpdate();
            me.maxWidth = maxWidth;
            me.maxHeight = maxHeight;
            me.margins = margins;
            me.beforeSetDimensions();
            me.setDimensions();
            me.afterSetDimensions();
            me.beforeBuildLabels();
            me.buildLabels();
            me.afterBuildLabels();
            me.beforeFit();
            me.fit();
            me.afterFit();
            me.afterUpdate();
            return me.minSize;
          },
          afterUpdate: noop2,
          //
          beforeSetDimensions: noop2,
          setDimensions: function() {
            var me = this;
            if (me.isHorizontal()) {
              me.width = me.maxWidth;
              me.left = 0;
              me.right = me.width;
            } else {
              me.height = me.maxHeight;
              me.top = 0;
              me.bottom = me.height;
            }
            me.paddingLeft = 0;
            me.paddingTop = 0;
            me.paddingRight = 0;
            me.paddingBottom = 0;
            me.minSize = {
              width: 0,
              height: 0
            };
          },
          afterSetDimensions: noop2,
          //
          beforeBuildLabels: noop2,
          buildLabels: noop2,
          afterBuildLabels: noop2,
          //
          beforeFit: noop2,
          fit: function() {
            var me = this, valueOrDefault = helpers.getValueOrDefault, opts = me.options, globalDefaults = Chart2.defaults.global, display = opts.display, fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize), minSize = me.minSize;
            if (me.isHorizontal()) {
              minSize.width = me.maxWidth;
              minSize.height = display ? fontSize + opts.padding * 2 : 0;
            } else {
              minSize.width = display ? fontSize + opts.padding * 2 : 0;
              minSize.height = me.maxHeight;
            }
            me.width = minSize.width;
            me.height = minSize.height;
          },
          afterFit: noop2,
          // Shared Methods
          isHorizontal: function() {
            var pos = this.options.position;
            return pos === "top" || pos === "bottom";
          },
          // Actually draw the title block on the canvas
          draw: function() {
            var me = this, ctx = me.ctx, valueOrDefault = helpers.getValueOrDefault, opts = me.options, globalDefaults = Chart2.defaults.global;
            if (opts.display) {
              var fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize), fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle), fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily), titleFont = helpers.fontString(fontSize, fontStyle, fontFamily), rotation = 0, titleX, titleY, top = me.top, left = me.left, bottom = me.bottom, right = me.right, maxWidth;
              ctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor);
              ctx.font = titleFont;
              if (me.isHorizontal()) {
                titleX = left + (right - left) / 2;
                titleY = top + (bottom - top) / 2;
                maxWidth = right - left;
              } else {
                titleX = opts.position === "left" ? left + fontSize / 2 : right - fontSize / 2;
                titleY = top + (bottom - top) / 2;
                maxWidth = bottom - top;
                rotation = Math.PI * (opts.position === "left" ? -0.5 : 0.5);
              }
              ctx.save();
              ctx.translate(titleX, titleY);
              ctx.rotate(rotation);
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(opts.text, 0, 0, maxWidth);
              ctx.restore();
            }
          }
        });
        function createNewTitleBlockAndAttach(chart, titleOpts) {
          var title = new Chart2.Title({
            ctx: chart.ctx,
            options: titleOpts,
            chart
          });
          layout.configure(chart, title, titleOpts);
          layout.addBox(chart, title);
          chart.titleBlock = title;
        }
        return {
          id: "title",
          beforeInit: function(chart) {
            var titleOpts = chart.options.title;
            if (titleOpts) {
              createNewTitleBlockAndAttach(chart, titleOpts);
            }
          },
          beforeUpdate: function(chart) {
            var titleOpts = chart.options.title;
            var titleBlock = chart.titleBlock;
            if (titleOpts) {
              titleOpts = helpers.configMerge(Chart2.defaults.global.title, titleOpts);
              if (titleBlock) {
                layout.configure(chart, titleBlock, titleOpts);
                titleBlock.options = titleOpts;
              } else {
                createNewTitleBlockAndAttach(chart, titleOpts);
              }
            } else if (titleBlock) {
              Chart2.layoutService.removeBox(chart, titleBlock);
              delete chart.titleBlock;
            }
          }
        };
      };
    }
  });

  // node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/chart.js
  var require_chart = __commonJS({
    "node_modules/.pnpm/chart.js@2.6.0/node_modules/chart.js/src/chart.js"(exports, module) {
      var Chart2 = require_core()();
      require_core_helpers()(Chart2);
      require_platform()(Chart2);
      require_core_canvasHelpers()(Chart2);
      require_core_element()(Chart2);
      require_core_plugin()(Chart2);
      require_core_animation()(Chart2);
      require_core_controller()(Chart2);
      require_core_datasetController()(Chart2);
      require_core_layoutService()(Chart2);
      require_core_scaleService()(Chart2);
      require_core_ticks()(Chart2);
      require_core_scale()(Chart2);
      require_core_interaction()(Chart2);
      require_core_tooltip()(Chart2);
      require_element_arc()(Chart2);
      require_element_line()(Chart2);
      require_element_point()(Chart2);
      require_element_rectangle()(Chart2);
      require_scale_linearbase()(Chart2);
      require_scale_category()(Chart2);
      require_scale_linear()(Chart2);
      require_scale_logarithmic()(Chart2);
      require_scale_radialLinear()(Chart2);
      require_scale_time()(Chart2);
      require_controller_bar()(Chart2);
      require_controller_bubble()(Chart2);
      require_controller_doughnut()(Chart2);
      require_controller_line()(Chart2);
      require_controller_polarArea()(Chart2);
      require_controller_radar()(Chart2);
      require_Chart_Bar()(Chart2);
      require_Chart_Bubble()(Chart2);
      require_Chart_Doughnut()(Chart2);
      require_Chart_Line()(Chart2);
      require_Chart_PolarArea()(Chart2);
      require_Chart_Radar()(Chart2);
      require_Chart_Scatter()(Chart2);
      var plugins = [];
      plugins.push(
        require_plugin_filler()(Chart2),
        require_plugin_legend()(Chart2),
        require_plugin_title()(Chart2)
      );
      Chart2.plugins.register(plugins);
      module.exports = Chart2;
      if (typeof window !== "undefined") {
        window.Chart = Chart2;
      }
    }
  });

  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/utils.js
  function noop() {
  }
  function run(fn) {
    return fn();
  }
  function blank_object() {
    return /* @__PURE__ */ Object.create(null);
  }
  function run_all(fns) {
    fns.forEach(run);
  }
  function is_function(thing) {
    return typeof thing === "function";
  }
  function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
  }
  function is_empty(obj) {
    return Object.keys(obj).length === 0;
  }
  function subscribe(store, ...callbacks) {
    if (store == null) {
      for (const callback of callbacks) {
        callback(void 0);
      }
      return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
  }
  function component_subscribe(component, store, callback) {
    component.$.on_destroy.push(subscribe(store, callback));
  }
  function set_store_value(store, ret, value) {
    store.set(value);
    return ret;
  }

  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/globals.js
  var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
    // @ts-ignore Node typings have this
    global
  );

  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
  var ResizeObserverSingleton = class {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    _listeners = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
    /**
     * @private
     * @type {ResizeObserver}
     */
    _observer = void 0;
    /** @type {ResizeObserverOptions} */
    options;
    /** @param {ResizeObserverOptions} options */
    constructor(options) {
      this.options = options;
    }
    /**
     * @param {Element} element
     * @param {import('./private.js').Listener} listener
     * @returns {() => void}
     */
    observe(element2, listener) {
      this._listeners.set(element2, listener);
      this._getObserver().observe(element2, this.options);
      return () => {
        this._listeners.delete(element2);
        this._observer.unobserve(element2);
      };
    }
    /**
     * @private
     */
    _getObserver() {
      return this._observer ?? (this._observer = new ResizeObserver((entries) => {
        for (const entry of entries) {
          ResizeObserverSingleton.entries.set(entry.target, entry);
          this._listeners.get(entry.target)?.(entry);
        }
      }));
    }
  };
  ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/dom.js
  var is_hydrating = false;
  function start_hydrating() {
    is_hydrating = true;
  }
  function end_hydrating() {
    is_hydrating = false;
  }
  function append(target, node) {
    target.appendChild(node);
  }
  function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
  }
  function detach(node) {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
  function destroy_each(iterations, detaching) {
    for (let i2 = 0; i2 < iterations.length; i2 += 1) {
      if (iterations[i2])
        iterations[i2].d(detaching);
    }
  }
  function element(name) {
    return document.createElement(name);
  }
  function text(data) {
    return document.createTextNode(data);
  }
  function space() {
    return text(" ");
  }
  function empty() {
    return text("");
  }
  function comment(content) {
    return document.createComment(content);
  }
  function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
  }
  function attr(node, attribute, value) {
    if (value == null)
      node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
      node.setAttribute(attribute, value);
  }
  function children(element2) {
    return Array.from(element2.childNodes);
  }
  function set_data(text2, data) {
    data = "" + data;
    if (text2.data === data)
      return;
    text2.data = /** @type {string} */
    data;
  }
  function set_input_value(input, value) {
    input.value = value == null ? "" : value;
  }
  function set_style(node, key, value, important) {
    if (value == null) {
      node.style.removeProperty(key);
    } else {
      node.style.setProperty(key, value, important ? "important" : "");
    }
  }
  function select_option(select, value, mounting) {
    for (let i2 = 0; i2 < select.options.length; i2 += 1) {
      const option = select.options[i2];
      if (option.__value === value) {
        option.selected = true;
        return;
      }
    }
    if (!mounting || value !== void 0) {
      select.selectedIndex = -1;
    }
  }
  function get_custom_elements_slots(element2) {
    const result = {};
    element2.childNodes.forEach(
      /** @param {Element} node */
      (node) => {
        result[node.slot || "default"] = true;
      }
    );
    return result;
  }

  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/lifecycle.js
  var current_component;
  function set_current_component(component) {
    current_component = component;
  }
  function get_current_component() {
    if (!current_component)
      throw new Error("Function called outside component initialization");
    return current_component;
  }
  function onMount(fn) {
    get_current_component().$.on_mount.push(fn);
  }

  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/scheduler.js
  var dirty_components = [];
  var binding_callbacks = [];
  var render_callbacks = [];
  var flush_callbacks = [];
  var resolved_promise = /* @__PURE__ */ Promise.resolve();
  var update_scheduled = false;
  function schedule_update() {
    if (!update_scheduled) {
      update_scheduled = true;
      resolved_promise.then(flush);
    }
  }
  function add_render_callback(fn) {
    render_callbacks.push(fn);
  }
  var seen_callbacks = /* @__PURE__ */ new Set();
  var flushidx = 0;
  function flush() {
    if (flushidx !== 0) {
      return;
    }
    const saved_component = current_component;
    do {
      try {
        while (flushidx < dirty_components.length) {
          const component = dirty_components[flushidx];
          flushidx++;
          set_current_component(component);
          update(component.$);
        }
      } catch (e2) {
        dirty_components.length = 0;
        flushidx = 0;
        throw e2;
      }
      set_current_component(null);
      dirty_components.length = 0;
      flushidx = 0;
      while (binding_callbacks.length)
        binding_callbacks.pop()();
      for (let i2 = 0; i2 < render_callbacks.length; i2 += 1) {
        const callback = render_callbacks[i2];
        if (!seen_callbacks.has(callback)) {
          seen_callbacks.add(callback);
          callback();
        }
      }
      render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
      flush_callbacks.pop()();
    }
    update_scheduled = false;
    seen_callbacks.clear();
    set_current_component(saved_component);
  }
  function update($) {
    if ($.fragment !== null) {
      $.update();
      run_all($.before_update);
      const dirty = $.dirty;
      $.dirty = [-1];
      $.fragment && $.fragment.p($.ctx, dirty);
      $.after_update.forEach(add_render_callback);
    }
  }
  function flush_render_callbacks(fns) {
    const filtered = [];
    const targets = [];
    render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
    targets.forEach((c) => c());
    render_callbacks = filtered;
  }

  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/transitions.js
  var outroing = /* @__PURE__ */ new Set();
  var outros;
  function transition_in(block, local) {
    if (block && block.i) {
      outroing.delete(block);
      block.i(local);
    }
  }
  function transition_out(block, local, detach2, callback) {
    if (block && block.o) {
      if (outroing.has(block))
        return;
      outroing.add(block);
      outros.c.push(() => {
        outroing.delete(block);
        if (callback) {
          if (detach2)
            block.d(1);
          callback();
        }
      });
      block.o(local);
    } else if (callback) {
      callback();
    }
  }

  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/each.js
  function ensure_array_like(array_like_or_iterator) {
    return array_like_or_iterator?.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
  }

  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/shared/boolean_attributes.js
  var _boolean_attributes = (
    /** @type {const} */
    [
      "allowfullscreen",
      "allowpaymentrequest",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "defer",
      "disabled",
      "formnovalidate",
      "hidden",
      "inert",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "selected"
    ]
  );
  var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/Component.js
  function create_component(block) {
    block && block.c();
  }
  function mount_component(component, target, anchor) {
    const { fragment, after_update } = component.$;
    fragment && fragment.m(target, anchor);
    add_render_callback(() => {
      const new_on_destroy = component.$.on_mount.map(run).filter(is_function);
      if (component.$.on_destroy) {
        component.$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$.on_mount = [];
    });
    after_update.forEach(add_render_callback);
  }
  function destroy_component(component, detaching) {
    const $ = component.$;
    if ($.fragment !== null) {
      flush_render_callbacks($.after_update);
      run_all($.on_destroy);
      $.fragment && $.fragment.d(detaching);
      $.on_destroy = $.fragment = null;
      $.ctx = [];
    }
  }
  function make_dirty(component, i2) {
    if (component.$.dirty[0] === -1) {
      dirty_components.push(component);
      schedule_update();
      component.$.dirty.fill(0);
    }
    component.$.dirty[i2 / 31 | 0] |= 1 << i2 % 31;
  }
  function init(component, options, instance7, create_fragment7, not_equal, props, append_styles = null, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $ = component.$ = {
      fragment: null,
      ctx: [],
      // state
      props,
      update: noop,
      not_equal,
      bound: blank_object(),
      // lifecycle
      on_mount: [],
      on_destroy: [],
      on_disconnect: [],
      before_update: [],
      after_update: [],
      context: new Map(options.context || (parent_component ? parent_component.$.context : [])),
      // everything else
      callbacks: blank_object(),
      dirty,
      skip_bound: false,
      root: options.target || parent_component.$.root
    };
    append_styles && append_styles($.root);
    let ready = false;
    $.ctx = instance7 ? instance7(component, options.props || {}, (i2, ret, ...rest) => {
      const value = rest.length ? rest[0] : ret;
      if ($.ctx && not_equal($.ctx[i2], $.ctx[i2] = value)) {
        if (!$.skip_bound && $.bound[i2])
          $.bound[i2](value);
        if (ready)
          make_dirty(component, i2);
      }
      return ret;
    }) : [];
    $.update();
    ready = true;
    run_all($.before_update);
    $.fragment = create_fragment7 ? create_fragment7($.ctx) : false;
    if (options.target) {
      if (options.hydrate) {
        start_hydrating();
        const nodes = children(options.target);
        $.fragment && $.fragment.l(nodes);
        nodes.forEach(detach);
      } else {
        $.fragment && $.fragment.c();
      }
      if (options.intro)
        transition_in(component.$.fragment);
      mount_component(component, options.target, options.anchor);
      end_hydrating();
      flush();
    }
    set_current_component(parent_component);
  }
  var SvelteElement;
  if (typeof HTMLElement === "function") {
    SvelteElement = class extends HTMLElement {
      /** The Svelte component constructor */
      $ctor;
      /** Slots */
      $s;
      /** The Svelte component instance */
      $c;
      /** Whether or not the custom element is connected */
      $cn = false;
      /** Component props data */
      $d = {};
      /** `true` if currently in the process of reflecting component props back to attributes */
      $r = false;
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      $p_d = {};
      /** @type {Record<string, Function[]>} Event listeners */
      $l = {};
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      $l_u = /* @__PURE__ */ new Map();
      constructor($componentCtor, $slots, use_shadow_dom) {
        super();
        this.$ctor = $componentCtor;
        this.$s = $slots;
        if (use_shadow_dom) {
          this.attachShadow({ mode: "open" });
        }
      }
      addEventListener(type, listener, options) {
        this.$l[type] = this.$l[type] || [];
        this.$l[type].push(listener);
        if (this.$c) {
          const unsub = this.$c.$on(type, listener);
          this.$l_u.set(listener, unsub);
        }
        super.addEventListener(type, listener, options);
      }
      removeEventListener(type, listener, options) {
        super.removeEventListener(type, listener, options);
        if (this.$c) {
          const unsub = this.$l_u.get(listener);
          if (unsub) {
            unsub();
            this.$l_u.delete(listener);
          }
        }
      }
      async connectedCallback() {
        this.$cn = true;
        if (!this.$c) {
          let create_slot = function(name) {
            return () => {
              let node;
              const obj = {
                c: function create() {
                  node = element("slot");
                  if (name !== "default") {
                    attr(node, "name", name);
                  }
                },
                /**
                 * @param {HTMLElement} target
                 * @param {HTMLElement} [anchor]
                 */
                m: function mount(target, anchor) {
                  insert(target, node, anchor);
                },
                d: function destroy(detaching) {
                  if (detaching) {
                    detach(node);
                  }
                }
              };
              return obj;
            };
          };
          await Promise.resolve();
          if (!this.$cn || this.$c) {
            return;
          }
          const $slots = {};
          const existing_slots = get_custom_elements_slots(this);
          for (const name of this.$s) {
            if (name in existing_slots) {
              $slots[name] = [create_slot(name)];
            }
          }
          for (const attribute of this.attributes) {
            const name = this.$g_p(attribute.name);
            if (!(name in this.$d)) {
              this.$d[name] = get_custom_element_value(name, attribute.value, this.$p_d, "toProp");
            }
          }
          for (const key in this.$p_d) {
            if (!(key in this.$d) && this[key] !== void 0) {
              this.$d[key] = this[key];
              delete this[key];
            }
          }
          this.$c = new this.$ctor({
            target: this.shadowRoot || this,
            props: {
              ...this.$d,
              $slots,
              $scope: {
                ctx: []
              }
            }
          });
          const reflect_attributes = () => {
            this.$r = true;
            for (const key in this.$p_d) {
              this.$d[key] = this.$c.$.ctx[this.$c.$.props[key]];
              if (this.$p_d[key].reflect) {
                const attribute_value = get_custom_element_value(
                  key,
                  this.$d[key],
                  this.$p_d,
                  "toAttribute"
                );
                if (attribute_value == null) {
                  this.removeAttribute(this.$p_d[key].attribute || key);
                } else {
                  this.setAttribute(this.$p_d[key].attribute || key, attribute_value);
                }
              }
            }
            this.$r = false;
          };
          this.$c.$.after_update.push(reflect_attributes);
          reflect_attributes();
          for (const type in this.$l) {
            for (const listener of this.$l[type]) {
              const unsub = this.$c.$on(type, listener);
              this.$l_u.set(listener, unsub);
            }
          }
          this.$l = {};
        }
      }
      // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
      // and setting attributes through setAttribute etc, this is helpful
      attributeChangedCallback(attr2, _oldValue, newValue) {
        if (this.$r)
          return;
        attr2 = this.$g_p(attr2);
        this.$d[attr2] = get_custom_element_value(attr2, newValue, this.$p_d, "toProp");
        this.$c?.$set({ [attr2]: this.$d[attr2] });
      }
      disconnectedCallback() {
        this.$cn = false;
        Promise.resolve().then(() => {
          if (!this.$cn && this.$c) {
            this.$c.$destroy();
            this.$c = void 0;
          }
        });
      }
      $g_p(attribute_name) {
        return Object.keys(this.$p_d).find(
          (key) => this.$p_d[key].attribute === attribute_name || !this.$p_d[key].attribute && key.toLowerCase() === attribute_name
        ) || attribute_name;
      }
    };
  }
  function get_custom_element_value(prop, value, props_definition, transform) {
    const type = props_definition[prop]?.type;
    value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
    if (!transform || !props_definition[prop]) {
      return value;
    } else if (transform === "toAttribute") {
      switch (type) {
        case "Object":
        case "Array":
          return value == null ? null : JSON.stringify(value);
        case "Boolean":
          return value ? "" : null;
        case "Number":
          return value == null ? null : value;
        default:
          return value;
      }
    } else {
      switch (type) {
        case "Object":
        case "Array":
          return value && JSON.parse(value);
        case "Boolean":
          return value;
        case "Number":
          return value != null ? +value : value;
        default:
          return value;
      }
    }
  }
  var SvelteComponent = class {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    $ = void 0;
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    $set = void 0;
    /** @returns {void} */
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    /**
     * @template {Extract<keyof Events, string>} K
     * @param {K} type
     * @param {((e: Events[K]) => void) | null | undefined} callback
     * @returns {() => void}
     */
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$.callbacks[type] || (this.$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    /**
     * @param {Partial<Props>} props
     * @returns {void}
     */
    $set(props) {
      if (this.$set && !is_empty(props)) {
        this.$.skip_bound = true;
        this.$set(props);
        this.$.skip_bound = false;
      }
    }
  };

  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/shared/version.js
  var PUBLIC_VERSION = "4";

  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/internal/disclose-version/index.js
  if (typeof window !== "undefined")
    (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

  // node_modules/.pnpm/svelte@4.2.18/node_modules/svelte/src/runtime/store/index.js
  var subscriber_queue = [];
  function writable(value, start = noop) {
    let stop;
    const subscribers = /* @__PURE__ */ new Set();
    function set(new_value) {
      if (safe_not_equal(value, new_value)) {
        value = new_value;
        if (stop) {
          const run_queue = !subscriber_queue.length;
          for (const subscriber of subscribers) {
            subscriber[1]();
            subscriber_queue.push(subscriber, value);
          }
          if (run_queue) {
            for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
              subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
            }
            subscriber_queue.length = 0;
          }
        }
      }
    }
    function update2(fn) {
      set(fn(value));
    }
    function subscribe2(run2, invalidate = noop) {
      const subscriber = [run2, invalidate];
      subscribers.add(subscriber);
      if (subscribers.size === 1) {
        stop = start(set, update2) || noop;
      }
      run2(value);
      return () => {
        subscribers.delete(subscriber);
        if (subscribers.size === 0 && stop) {
          stop();
          stop = null;
        }
      };
    }
    return { set, update: update2, subscribe: subscribe2 };
  }

  // stores/ShowRoomModal.js
  var showRoomModal = writable(false);
  var ShowRoomModal_default = showRoomModal;

  // node_modules/.pnpm/pocketbase@0.21.3/node_modules/pocketbase/dist/pocketbase.es.mjs
  var ClientResponseError = class extends Error {
    constructor(e2) {
      super("ClientResponseError"), this.url = "", this.status = 0, this.response = {}, this.isAbort = false, this.originalError = null, Object.setPrototypeOf(this, ClientResponseError.prototype), null !== e2 && "object" == typeof e2 && (this.url = "string" == typeof e2.url ? e2.url : "", this.status = "number" == typeof e2.status ? e2.status : 0, this.isAbort = !!e2.isAbort, this.originalError = e2.originalError, null !== e2.response && "object" == typeof e2.response ? this.response = e2.response : null !== e2.data && "object" == typeof e2.data ? this.response = e2.data : this.response = {}), this.originalError || e2 instanceof ClientResponseError || (this.originalError = e2), "undefined" != typeof DOMException && e2 instanceof DOMException && (this.isAbort = true), this.name = "ClientResponseError " + this.status, this.message = this.response?.message, this.message || (this.isAbort ? this.message = "The request was autocancelled. You can find more info in https://github.com/pocketbase/js-sdk#auto-cancellation." : this.originalError?.cause?.message?.includes("ECONNREFUSED ::1") ? this.message = "Failed to connect to the PocketBase server. Try changing the SDK URL from localhost to 127.0.0.1 (https://github.com/pocketbase/js-sdk/issues/21)." : this.message = "Something went wrong while processing your request.");
    }
    get data() {
      return this.response;
    }
    toJSON() {
      return { ...this };
    }
  };
  var e = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
  function cookieParse(e2, t2) {
    const s2 = {};
    if ("string" != typeof e2)
      return s2;
    const i2 = Object.assign({}, t2 || {}).decode || defaultDecode;
    let n2 = 0;
    for (; n2 < e2.length; ) {
      const t3 = e2.indexOf("=", n2);
      if (-1 === t3)
        break;
      let r = e2.indexOf(";", n2);
      if (-1 === r)
        r = e2.length;
      else if (r < t3) {
        n2 = e2.lastIndexOf(";", t3 - 1) + 1;
        continue;
      }
      const o = e2.slice(n2, t3).trim();
      if (void 0 === s2[o]) {
        let n3 = e2.slice(t3 + 1, r).trim();
        34 === n3.charCodeAt(0) && (n3 = n3.slice(1, -1));
        try {
          s2[o] = i2(n3);
        } catch (e3) {
          s2[o] = n3;
        }
      }
      n2 = r + 1;
    }
    return s2;
  }
  function cookieSerialize(t2, s2, i2) {
    const n2 = Object.assign({}, i2 || {}), r = n2.encode || defaultEncode;
    if (!e.test(t2))
      throw new TypeError("argument name is invalid");
    const o = r(s2);
    if (o && !e.test(o))
      throw new TypeError("argument val is invalid");
    let a = t2 + "=" + o;
    if (null != n2.maxAge) {
      const e2 = n2.maxAge - 0;
      if (isNaN(e2) || !isFinite(e2))
        throw new TypeError("option maxAge is invalid");
      a += "; Max-Age=" + Math.floor(e2);
    }
    if (n2.domain) {
      if (!e.test(n2.domain))
        throw new TypeError("option domain is invalid");
      a += "; Domain=" + n2.domain;
    }
    if (n2.path) {
      if (!e.test(n2.path))
        throw new TypeError("option path is invalid");
      a += "; Path=" + n2.path;
    }
    if (n2.expires) {
      if (!function isDate(e2) {
        return "[object Date]" === Object.prototype.toString.call(e2) || e2 instanceof Date;
      }(n2.expires) || isNaN(n2.expires.valueOf()))
        throw new TypeError("option expires is invalid");
      a += "; Expires=" + n2.expires.toUTCString();
    }
    if (n2.httpOnly && (a += "; HttpOnly"), n2.secure && (a += "; Secure"), n2.priority) {
      switch ("string" == typeof n2.priority ? n2.priority.toLowerCase() : n2.priority) {
        case "low":
          a += "; Priority=Low";
          break;
        case "medium":
          a += "; Priority=Medium";
          break;
        case "high":
          a += "; Priority=High";
          break;
        default:
          throw new TypeError("option priority is invalid");
      }
    }
    if (n2.sameSite) {
      switch ("string" == typeof n2.sameSite ? n2.sameSite.toLowerCase() : n2.sameSite) {
        case true:
          a += "; SameSite=Strict";
          break;
        case "lax":
          a += "; SameSite=Lax";
          break;
        case "strict":
          a += "; SameSite=Strict";
          break;
        case "none":
          a += "; SameSite=None";
          break;
        default:
          throw new TypeError("option sameSite is invalid");
      }
    }
    return a;
  }
  function defaultDecode(e2) {
    return -1 !== e2.indexOf("%") ? decodeURIComponent(e2) : e2;
  }
  function defaultEncode(e2) {
    return encodeURIComponent(e2);
  }
  var t = "undefined" != typeof navigator && "ReactNative" === navigator.product || "undefined" != typeof global && global.HermesInternal;
  var s;
  function getTokenPayload(e2) {
    if (e2)
      try {
        const t2 = decodeURIComponent(s(e2.split(".")[1]).split("").map(function(e3) {
          return "%" + ("00" + e3.charCodeAt(0).toString(16)).slice(-2);
        }).join(""));
        return JSON.parse(t2) || {};
      } catch (e3) {
      }
    return {};
  }
  function isTokenExpired(e2, t2 = 0) {
    let s2 = getTokenPayload(e2);
    return !(Object.keys(s2).length > 0 && (!s2.exp || s2.exp - t2 > Date.now() / 1e3));
  }
  s = "function" != typeof atob || t ? (e2) => {
    let t2 = String(e2).replace(/=+$/, "");
    if (t2.length % 4 == 1)
      throw new Error("'atob' failed: The string to be decoded is not correctly encoded.");
    for (var s2, i2, n2 = 0, r = 0, o = ""; i2 = t2.charAt(r++); ~i2 && (s2 = n2 % 4 ? 64 * s2 + i2 : i2, n2++ % 4) ? o += String.fromCharCode(255 & s2 >> (-2 * n2 & 6)) : 0)
      i2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(i2);
    return o;
  } : atob;
  var i = "pb_auth";
  var BaseAuthStore = class {
    constructor() {
      this.baseToken = "", this.baseModel = null, this._onChangeCallbacks = [];
    }
    get token() {
      return this.baseToken;
    }
    get model() {
      return this.baseModel;
    }
    get isValid() {
      return !isTokenExpired(this.token);
    }
    get isAdmin() {
      return "admin" === getTokenPayload(this.token).type;
    }
    get isAuthRecord() {
      return "authRecord" === getTokenPayload(this.token).type;
    }
    save(e2, t2) {
      this.baseToken = e2 || "", this.baseModel = t2 || null, this.triggerChange();
    }
    clear() {
      this.baseToken = "", this.baseModel = null, this.triggerChange();
    }
    loadFromCookie(e2, t2 = i) {
      const s2 = cookieParse(e2 || "")[t2] || "";
      let n2 = {};
      try {
        n2 = JSON.parse(s2), (null === typeof n2 || "object" != typeof n2 || Array.isArray(n2)) && (n2 = {});
      } catch (e3) {
      }
      this.save(n2.token || "", n2.model || null);
    }
    exportToCookie(e2, t2 = i) {
      const s2 = { secure: true, sameSite: true, httpOnly: true, path: "/" }, n2 = getTokenPayload(this.token);
      s2.expires = n2?.exp ? new Date(1e3 * n2.exp) : new Date("1970-01-01"), e2 = Object.assign({}, s2, e2);
      const r = { token: this.token, model: this.model ? JSON.parse(JSON.stringify(this.model)) : null };
      let o = cookieSerialize(t2, JSON.stringify(r), e2);
      const a = "undefined" != typeof Blob ? new Blob([o]).size : o.length;
      if (r.model && a > 4096) {
        r.model = { id: r?.model?.id, email: r?.model?.email };
        const s3 = ["collectionId", "username", "verified"];
        for (const e3 in this.model)
          s3.includes(e3) && (r.model[e3] = this.model[e3]);
        o = cookieSerialize(t2, JSON.stringify(r), e2);
      }
      return o;
    }
    onChange(e2, t2 = false) {
      return this._onChangeCallbacks.push(e2), t2 && e2(this.token, this.model), () => {
        for (let t3 = this._onChangeCallbacks.length - 1; t3 >= 0; t3--)
          if (this._onChangeCallbacks[t3] == e2)
            return delete this._onChangeCallbacks[t3], void this._onChangeCallbacks.splice(t3, 1);
      };
    }
    triggerChange() {
      for (const e2 of this._onChangeCallbacks)
        e2 && e2(this.token, this.model);
    }
  };
  var LocalAuthStore = class extends BaseAuthStore {
    constructor(e2 = "pocketbase_auth") {
      super(), this.storageFallback = {}, this.storageKey = e2, this._bindStorageEvent();
    }
    get token() {
      return (this._storageGet(this.storageKey) || {}).token || "";
    }
    get model() {
      return (this._storageGet(this.storageKey) || {}).model || null;
    }
    save(e2, t2) {
      this._storageSet(this.storageKey, { token: e2, model: t2 }), super.save(e2, t2);
    }
    clear() {
      this._storageRemove(this.storageKey), super.clear();
    }
    _storageGet(e2) {
      if ("undefined" != typeof window && window?.localStorage) {
        const t2 = window.localStorage.getItem(e2) || "";
        try {
          return JSON.parse(t2);
        } catch (e3) {
          return t2;
        }
      }
      return this.storageFallback[e2];
    }
    _storageSet(e2, t2) {
      if ("undefined" != typeof window && window?.localStorage) {
        let s2 = t2;
        "string" != typeof t2 && (s2 = JSON.stringify(t2)), window.localStorage.setItem(e2, s2);
      } else
        this.storageFallback[e2] = t2;
    }
    _storageRemove(e2) {
      "undefined" != typeof window && window?.localStorage && window.localStorage?.removeItem(e2), delete this.storageFallback[e2];
    }
    _bindStorageEvent() {
      "undefined" != typeof window && window?.localStorage && window.addEventListener && window.addEventListener("storage", (e2) => {
        if (e2.key != this.storageKey)
          return;
        const t2 = this._storageGet(this.storageKey) || {};
        super.save(t2.token || "", t2.model || null);
      });
    }
  };
  var BaseService = class {
    constructor(e2) {
      this.client = e2;
    }
  };
  var SettingsService = class extends BaseService {
    async getAll(e2) {
      return e2 = Object.assign({ method: "GET" }, e2), this.client.send("/api/settings", e2);
    }
    async update(e2, t2) {
      return t2 = Object.assign({ method: "PATCH", body: e2 }, t2), this.client.send("/api/settings", t2);
    }
    async testS3(e2 = "storage", t2) {
      return t2 = Object.assign({ method: "POST", body: { filesystem: e2 } }, t2), this.client.send("/api/settings/test/s3", t2).then(() => true);
    }
    async testEmail(e2, t2, s2) {
      return s2 = Object.assign({ method: "POST", body: { email: e2, template: t2 } }, s2), this.client.send("/api/settings/test/email", s2).then(() => true);
    }
    async generateAppleClientSecret(e2, t2, s2, i2, n2, r) {
      return r = Object.assign({ method: "POST", body: { clientId: e2, teamId: t2, keyId: s2, privateKey: i2, duration: n2 } }, r), this.client.send("/api/settings/apple/generate-client-secret", r);
    }
  };
  var CrudService = class extends BaseService {
    decode(e2) {
      return e2;
    }
    async getFullList(e2, t2) {
      if ("number" == typeof e2)
        return this._getFullList(e2, t2);
      let s2 = 500;
      return (t2 = Object.assign({}, e2, t2)).batch && (s2 = t2.batch, delete t2.batch), this._getFullList(s2, t2);
    }
    async getList(e2 = 1, t2 = 30, s2) {
      return (s2 = Object.assign({ method: "GET" }, s2)).query = Object.assign({ page: e2, perPage: t2 }, s2.query), this.client.send(this.baseCrudPath, s2).then((e3) => (e3.items = e3.items?.map((e4) => this.decode(e4)) || [], e3));
    }
    async getFirstListItem(e2, t2) {
      return (t2 = Object.assign({ requestKey: "one_by_filter_" + this.baseCrudPath + "_" + e2 }, t2)).query = Object.assign({ filter: e2, skipTotal: 1 }, t2.query), this.getList(1, 1, t2).then((e3) => {
        if (!e3?.items?.length)
          throw new ClientResponseError({ status: 404, response: { code: 404, message: "The requested resource wasn't found.", data: {} } });
        return e3.items[0];
      });
    }
    async getOne(e2, t2) {
      if (!e2)
        throw new ClientResponseError({ url: this.client.buildUrl(this.baseCrudPath + "/"), status: 404, response: { code: 404, message: "Missing required record id.", data: {} } });
      return t2 = Object.assign({ method: "GET" }, t2), this.client.send(this.baseCrudPath + "/" + encodeURIComponent(e2), t2).then((e3) => this.decode(e3));
    }
    async create(e2, t2) {
      return t2 = Object.assign({ method: "POST", body: e2 }, t2), this.client.send(this.baseCrudPath, t2).then((e3) => this.decode(e3));
    }
    async update(e2, t2, s2) {
      return s2 = Object.assign({ method: "PATCH", body: t2 }, s2), this.client.send(this.baseCrudPath + "/" + encodeURIComponent(e2), s2).then((e3) => this.decode(e3));
    }
    async delete(e2, t2) {
      return t2 = Object.assign({ method: "DELETE" }, t2), this.client.send(this.baseCrudPath + "/" + encodeURIComponent(e2), t2).then(() => true);
    }
    _getFullList(e2 = 500, t2) {
      (t2 = t2 || {}).query = Object.assign({ skipTotal: 1 }, t2.query);
      let s2 = [], request = async (i2) => this.getList(i2, e2 || 500, t2).then((e3) => {
        const t3 = e3.items;
        return s2 = s2.concat(t3), t3.length == e3.perPage ? request(i2 + 1) : s2;
      });
      return request(1);
    }
  };
  function normalizeLegacyOptionsArgs(e2, t2, s2, i2) {
    const n2 = void 0 !== i2;
    return n2 || void 0 !== s2 ? n2 ? (console.warn(e2), t2.body = Object.assign({}, t2.body, s2), t2.query = Object.assign({}, t2.query, i2), t2) : Object.assign(t2, s2) : t2;
  }
  function resetAutoRefresh(e2) {
    e2._resetAutoRefresh?.();
  }
  var AdminService = class extends CrudService {
    get baseCrudPath() {
      return "/api/admins";
    }
    async update(e2, t2, s2) {
      return super.update(e2, t2, s2).then((e3) => (this.client.authStore.model?.id === e3.id && void 0 === this.client.authStore.model?.collectionId && this.client.authStore.save(this.client.authStore.token, e3), e3));
    }
    async delete(e2, t2) {
      return super.delete(e2, t2).then((t3) => (t3 && this.client.authStore.model?.id === e2 && void 0 === this.client.authStore.model?.collectionId && this.client.authStore.clear(), t3));
    }
    authResponse(e2) {
      const t2 = this.decode(e2?.admin || {});
      return e2?.token && e2?.admin && this.client.authStore.save(e2.token, t2), Object.assign({}, e2, { token: e2?.token || "", admin: t2 });
    }
    async authWithPassword(e2, t2, s2, i2) {
      let n2 = { method: "POST", body: { identity: e2, password: t2 } };
      n2 = normalizeLegacyOptionsArgs("This form of authWithPassword(email, pass, body?, query?) is deprecated. Consider replacing it with authWithPassword(email, pass, options?).", n2, s2, i2);
      const r = n2.autoRefreshThreshold;
      delete n2.autoRefreshThreshold, n2.autoRefresh || resetAutoRefresh(this.client);
      let o = await this.client.send(this.baseCrudPath + "/auth-with-password", n2);
      return o = this.authResponse(o), r && function registerAutoRefresh(e3, t3, s3, i3) {
        resetAutoRefresh(e3);
        const n3 = e3.beforeSend, r2 = e3.authStore.model, o2 = e3.authStore.onChange((t4, s4) => {
          (!t4 || s4?.id != r2?.id || (s4?.collectionId || r2?.collectionId) && s4?.collectionId != r2?.collectionId) && resetAutoRefresh(e3);
        });
        e3._resetAutoRefresh = function() {
          o2(), e3.beforeSend = n3, delete e3._resetAutoRefresh;
        }, e3.beforeSend = async (r3, o3) => {
          const a = e3.authStore.token;
          if (o3.query?.autoRefresh)
            return n3 ? n3(r3, o3) : { url: r3, sendOptions: o3 };
          let c = e3.authStore.isValid;
          if (c && isTokenExpired(e3.authStore.token, t3))
            try {
              await s3();
            } catch (e4) {
              c = false;
            }
          c || await i3();
          const l = o3.headers || {};
          for (let t4 in l)
            if ("authorization" == t4.toLowerCase() && a == l[t4] && e3.authStore.token) {
              l[t4] = e3.authStore.token;
              break;
            }
          return o3.headers = l, n3 ? n3(r3, o3) : { url: r3, sendOptions: o3 };
        };
      }(this.client, r, () => this.authRefresh({ autoRefresh: true }), () => this.authWithPassword(e2, t2, Object.assign({ autoRefresh: true }, n2))), o;
    }
    async authRefresh(e2, t2) {
      let s2 = { method: "POST" };
      return s2 = normalizeLegacyOptionsArgs("This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).", s2, e2, t2), this.client.send(this.baseCrudPath + "/auth-refresh", s2).then(this.authResponse.bind(this));
    }
    async requestPasswordReset(e2, t2, s2) {
      let i2 = { method: "POST", body: { email: e2 } };
      return i2 = normalizeLegacyOptionsArgs("This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).", i2, t2, s2), this.client.send(this.baseCrudPath + "/request-password-reset", i2).then(() => true);
    }
    async confirmPasswordReset(e2, t2, s2, i2, n2) {
      let r = { method: "POST", body: { token: e2, password: t2, passwordConfirm: s2 } };
      return r = normalizeLegacyOptionsArgs("This form of confirmPasswordReset(resetToken, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(resetToken, password, passwordConfirm, options?).", r, i2, n2), this.client.send(this.baseCrudPath + "/confirm-password-reset", r).then(() => true);
    }
  };
  var n = ["requestKey", "$cancelKey", "$autoCancel", "fetch", "headers", "body", "query", "params", "cache", "credentials", "headers", "integrity", "keepalive", "method", "mode", "redirect", "referrer", "referrerPolicy", "signal", "window"];
  function normalizeUnknownQueryParams(e2) {
    if (e2) {
      e2.query = e2.query || {};
      for (let t2 in e2)
        n.includes(t2) || (e2.query[t2] = e2[t2], delete e2[t2]);
    }
  }
  var RealtimeService = class extends BaseService {
    constructor() {
      super(...arguments), this.clientId = "", this.eventSource = null, this.subscriptions = {}, this.lastSentSubscriptions = [], this.maxConnectTimeout = 15e3, this.reconnectAttempts = 0, this.maxReconnectAttempts = 1 / 0, this.predefinedReconnectIntervals = [200, 300, 500, 1e3, 1200, 1500, 2e3], this.pendingConnects = [];
    }
    get isConnected() {
      return !!this.eventSource && !!this.clientId && !this.pendingConnects.length;
    }
    async subscribe(e2, t2, s2) {
      if (!e2)
        throw new Error("topic must be set.");
      let i2 = e2;
      if (s2) {
        normalizeUnknownQueryParams(s2);
        const e3 = "options=" + encodeURIComponent(JSON.stringify({ query: s2.query, headers: s2.headers }));
        i2 += (i2.includes("?") ? "&" : "?") + e3;
      }
      const listener = function(e3) {
        const s3 = e3;
        let i3;
        try {
          i3 = JSON.parse(s3?.data);
        } catch {
        }
        t2(i3 || {});
      };
      return this.subscriptions[i2] || (this.subscriptions[i2] = []), this.subscriptions[i2].push(listener), this.isConnected ? 1 === this.subscriptions[i2].length ? await this.submitSubscriptions() : this.eventSource?.addEventListener(i2, listener) : await this.connect(), async () => this.unsubscribeByTopicAndListener(e2, listener);
    }
    async unsubscribe(e2) {
      let t2 = false;
      if (e2) {
        const s2 = this.getSubscriptionsByTopic(e2);
        for (let e3 in s2)
          if (this.hasSubscriptionListeners(e3)) {
            for (let t3 of this.subscriptions[e3])
              this.eventSource?.removeEventListener(e3, t3);
            delete this.subscriptions[e3], t2 || (t2 = true);
          }
      } else
        this.subscriptions = {};
      this.hasSubscriptionListeners() ? t2 && await this.submitSubscriptions() : this.disconnect();
    }
    async unsubscribeByPrefix(e2) {
      let t2 = false;
      for (let s2 in this.subscriptions)
        if ((s2 + "?").startsWith(e2)) {
          t2 = true;
          for (let e3 of this.subscriptions[s2])
            this.eventSource?.removeEventListener(s2, e3);
          delete this.subscriptions[s2];
        }
      t2 && (this.hasSubscriptionListeners() ? await this.submitSubscriptions() : this.disconnect());
    }
    async unsubscribeByTopicAndListener(e2, t2) {
      let s2 = false;
      const i2 = this.getSubscriptionsByTopic(e2);
      for (let e3 in i2) {
        if (!Array.isArray(this.subscriptions[e3]) || !this.subscriptions[e3].length)
          continue;
        let i3 = false;
        for (let s3 = this.subscriptions[e3].length - 1; s3 >= 0; s3--)
          this.subscriptions[e3][s3] === t2 && (i3 = true, delete this.subscriptions[e3][s3], this.subscriptions[e3].splice(s3, 1), this.eventSource?.removeEventListener(e3, t2));
        i3 && (this.subscriptions[e3].length || delete this.subscriptions[e3], s2 || this.hasSubscriptionListeners(e3) || (s2 = true));
      }
      this.hasSubscriptionListeners() ? s2 && await this.submitSubscriptions() : this.disconnect();
    }
    hasSubscriptionListeners(e2) {
      if (this.subscriptions = this.subscriptions || {}, e2)
        return !!this.subscriptions[e2]?.length;
      for (let e3 in this.subscriptions)
        if (this.subscriptions[e3]?.length)
          return true;
      return false;
    }
    async submitSubscriptions() {
      if (this.clientId)
        return this.addAllSubscriptionListeners(), this.lastSentSubscriptions = this.getNonEmptySubscriptionKeys(), this.client.send("/api/realtime", { method: "POST", body: { clientId: this.clientId, subscriptions: this.lastSentSubscriptions }, requestKey: this.getSubscriptionsCancelKey() }).catch((e2) => {
          if (!e2?.isAbort)
            throw e2;
        });
    }
    getSubscriptionsCancelKey() {
      return "realtime_" + this.clientId;
    }
    getSubscriptionsByTopic(e2) {
      const t2 = {};
      e2 = e2.includes("?") ? e2 : e2 + "?";
      for (let s2 in this.subscriptions)
        (s2 + "?").startsWith(e2) && (t2[s2] = this.subscriptions[s2]);
      return t2;
    }
    getNonEmptySubscriptionKeys() {
      const e2 = [];
      for (let t2 in this.subscriptions)
        this.subscriptions[t2].length && e2.push(t2);
      return e2;
    }
    addAllSubscriptionListeners() {
      if (this.eventSource) {
        this.removeAllSubscriptionListeners();
        for (let e2 in this.subscriptions)
          for (let t2 of this.subscriptions[e2])
            this.eventSource.addEventListener(e2, t2);
      }
    }
    removeAllSubscriptionListeners() {
      if (this.eventSource)
        for (let e2 in this.subscriptions)
          for (let t2 of this.subscriptions[e2])
            this.eventSource.removeEventListener(e2, t2);
    }
    async connect() {
      if (!(this.reconnectAttempts > 0))
        return new Promise((e2, t2) => {
          this.pendingConnects.push({ resolve: e2, reject: t2 }), this.pendingConnects.length > 1 || this.initConnect();
        });
    }
    initConnect() {
      this.disconnect(true), clearTimeout(this.connectTimeoutId), this.connectTimeoutId = setTimeout(() => {
        this.connectErrorHandler(new Error("EventSource connect took too long."));
      }, this.maxConnectTimeout), this.eventSource = new EventSource(this.client.buildUrl("/api/realtime")), this.eventSource.onerror = (e2) => {
        this.connectErrorHandler(new Error("Failed to establish realtime connection."));
      }, this.eventSource.addEventListener("PB_CONNECT", (e2) => {
        const t2 = e2;
        this.clientId = t2?.lastEventId, this.submitSubscriptions().then(async () => {
          let e3 = 3;
          for (; this.hasUnsentSubscriptions() && e3 > 0; )
            e3--, await this.submitSubscriptions();
        }).then(() => {
          for (let e3 of this.pendingConnects)
            e3.resolve();
          this.pendingConnects = [], this.reconnectAttempts = 0, clearTimeout(this.reconnectTimeoutId), clearTimeout(this.connectTimeoutId);
          const t3 = this.getSubscriptionsByTopic("PB_CONNECT");
          for (let s2 in t3)
            for (let i2 of t3[s2])
              i2(e2);
        }).catch((e3) => {
          this.clientId = "", this.connectErrorHandler(e3);
        });
      });
    }
    hasUnsentSubscriptions() {
      const e2 = this.getNonEmptySubscriptionKeys();
      if (e2.length != this.lastSentSubscriptions.length)
        return true;
      for (const t2 of e2)
        if (!this.lastSentSubscriptions.includes(t2))
          return true;
      return false;
    }
    connectErrorHandler(e2) {
      if (clearTimeout(this.connectTimeoutId), clearTimeout(this.reconnectTimeoutId), !this.clientId && !this.reconnectAttempts || this.reconnectAttempts > this.maxReconnectAttempts) {
        for (let t3 of this.pendingConnects)
          t3.reject(new ClientResponseError(e2));
        return this.pendingConnects = [], void this.disconnect();
      }
      this.disconnect(true);
      const t2 = this.predefinedReconnectIntervals[this.reconnectAttempts] || this.predefinedReconnectIntervals[this.predefinedReconnectIntervals.length - 1];
      this.reconnectAttempts++, this.reconnectTimeoutId = setTimeout(() => {
        this.initConnect();
      }, t2);
    }
    disconnect(e2 = false) {
      if (clearTimeout(this.connectTimeoutId), clearTimeout(this.reconnectTimeoutId), this.removeAllSubscriptionListeners(), this.client.cancelRequest(this.getSubscriptionsCancelKey()), this.eventSource?.close(), this.eventSource = null, this.clientId = "", !e2) {
        this.reconnectAttempts = 0;
        for (let e3 of this.pendingConnects)
          e3.resolve();
        this.pendingConnects = [];
      }
    }
  };
  var RecordService = class extends CrudService {
    constructor(e2, t2) {
      super(e2), this.collectionIdOrName = t2;
    }
    get baseCrudPath() {
      return this.baseCollectionPath + "/records";
    }
    get baseCollectionPath() {
      return "/api/collections/" + encodeURIComponent(this.collectionIdOrName);
    }
    async subscribe(e2, t2, s2) {
      if (!e2)
        throw new Error("Missing topic.");
      if (!t2)
        throw new Error("Missing subscription callback.");
      return this.client.realtime.subscribe(this.collectionIdOrName + "/" + e2, t2, s2);
    }
    async unsubscribe(e2) {
      return e2 ? this.client.realtime.unsubscribe(this.collectionIdOrName + "/" + e2) : this.client.realtime.unsubscribeByPrefix(this.collectionIdOrName);
    }
    async getFullList(e2, t2) {
      if ("number" == typeof e2)
        return super.getFullList(e2, t2);
      const s2 = Object.assign({}, e2, t2);
      return super.getFullList(s2);
    }
    async getList(e2 = 1, t2 = 30, s2) {
      return super.getList(e2, t2, s2);
    }
    async getFirstListItem(e2, t2) {
      return super.getFirstListItem(e2, t2);
    }
    async getOne(e2, t2) {
      return super.getOne(e2, t2);
    }
    async create(e2, t2) {
      return super.create(e2, t2);
    }
    async update(e2, t2, s2) {
      return super.update(e2, t2, s2).then((e3) => (this.client.authStore.model?.id !== e3?.id || this.client.authStore.model?.collectionId !== this.collectionIdOrName && this.client.authStore.model?.collectionName !== this.collectionIdOrName || this.client.authStore.save(this.client.authStore.token, e3), e3));
    }
    async delete(e2, t2) {
      return super.delete(e2, t2).then((t3) => (!t3 || this.client.authStore.model?.id !== e2 || this.client.authStore.model?.collectionId !== this.collectionIdOrName && this.client.authStore.model?.collectionName !== this.collectionIdOrName || this.client.authStore.clear(), t3));
    }
    authResponse(e2) {
      const t2 = this.decode(e2?.record || {});
      return this.client.authStore.save(e2?.token, t2), Object.assign({}, e2, { token: e2?.token || "", record: t2 });
    }
    async listAuthMethods(e2) {
      return e2 = Object.assign({ method: "GET" }, e2), this.client.send(this.baseCollectionPath + "/auth-methods", e2).then((e3) => Object.assign({}, e3, { usernamePassword: !!e3?.usernamePassword, emailPassword: !!e3?.emailPassword, authProviders: Array.isArray(e3?.authProviders) ? e3?.authProviders : [] }));
    }
    async authWithPassword(e2, t2, s2, i2) {
      let n2 = { method: "POST", body: { identity: e2, password: t2 } };
      return n2 = normalizeLegacyOptionsArgs("This form of authWithPassword(usernameOrEmail, pass, body?, query?) is deprecated. Consider replacing it with authWithPassword(usernameOrEmail, pass, options?).", n2, s2, i2), this.client.send(this.baseCollectionPath + "/auth-with-password", n2).then((e3) => this.authResponse(e3));
    }
    async authWithOAuth2Code(e2, t2, s2, i2, n2, r, o) {
      let a = { method: "POST", body: { provider: e2, code: t2, codeVerifier: s2, redirectUrl: i2, createData: n2 } };
      return a = normalizeLegacyOptionsArgs("This form of authWithOAuth2Code(provider, code, codeVerifier, redirectUrl, createData?, body?, query?) is deprecated. Consider replacing it with authWithOAuth2Code(provider, code, codeVerifier, redirectUrl, createData?, options?).", a, r, o), this.client.send(this.baseCollectionPath + "/auth-with-oauth2", a).then((e3) => this.authResponse(e3));
    }
    async authWithOAuth2(...e2) {
      if (e2.length > 1 || "string" == typeof e2?.[0])
        return console.warn("PocketBase: This form of authWithOAuth2() is deprecated and may get removed in the future. Please replace with authWithOAuth2Code() OR use the authWithOAuth2() realtime form as shown in https://pocketbase.io/docs/authentication/#oauth2-integration."), this.authWithOAuth2Code(e2?.[0] || "", e2?.[1] || "", e2?.[2] || "", e2?.[3] || "", e2?.[4] || {}, e2?.[5] || {}, e2?.[6] || {});
      const t2 = e2?.[0] || {}, s2 = (await this.listAuthMethods()).authProviders.find((e3) => e3.name === t2.provider);
      if (!s2)
        throw new ClientResponseError(new Error(`Missing or invalid provider "${t2.provider}".`));
      const i2 = this.client.buildUrl("/api/oauth2-redirect"), n2 = new RealtimeService(this.client);
      let r = null;
      function cleanup() {
        r?.close(), n2.unsubscribe();
      }
      return t2.urlCallback || (r = openBrowserPopup(void 0)), new Promise(async (e3, o) => {
        try {
          await n2.subscribe("@oauth2", async (r2) => {
            const a2 = n2.clientId;
            try {
              if (!r2.state || a2 !== r2.state)
                throw new Error("State parameters don't match.");
              if (r2.error || !r2.code)
                throw new Error("OAuth2 redirect error or missing code: " + r2.error);
              const n3 = Object.assign({}, t2);
              delete n3.provider, delete n3.scopes, delete n3.createData, delete n3.urlCallback;
              const o2 = await this.authWithOAuth2Code(s2.name, r2.code, s2.codeVerifier, i2, t2.createData, n3);
              e3(o2);
            } catch (e4) {
              o(new ClientResponseError(e4));
            }
            cleanup();
          });
          const a = { state: n2.clientId };
          t2.scopes?.length && (a.scope = t2.scopes.join(" "));
          const c = this._replaceQueryParams(s2.authUrl + i2, a);
          let l = t2.urlCallback || function(e4) {
            r ? r.location.href = e4 : r = openBrowserPopup(e4);
          };
          await l(c);
        } catch (e4) {
          cleanup(), o(new ClientResponseError(e4));
        }
      });
    }
    async authRefresh(e2, t2) {
      let s2 = { method: "POST" };
      return s2 = normalizeLegacyOptionsArgs("This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).", s2, e2, t2), this.client.send(this.baseCollectionPath + "/auth-refresh", s2).then((e3) => this.authResponse(e3));
    }
    async requestPasswordReset(e2, t2, s2) {
      let i2 = { method: "POST", body: { email: e2 } };
      return i2 = normalizeLegacyOptionsArgs("This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).", i2, t2, s2), this.client.send(this.baseCollectionPath + "/request-password-reset", i2).then(() => true);
    }
    async confirmPasswordReset(e2, t2, s2, i2, n2) {
      let r = { method: "POST", body: { token: e2, password: t2, passwordConfirm: s2 } };
      return r = normalizeLegacyOptionsArgs("This form of confirmPasswordReset(token, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(token, password, passwordConfirm, options?).", r, i2, n2), this.client.send(this.baseCollectionPath + "/confirm-password-reset", r).then(() => true);
    }
    async requestVerification(e2, t2, s2) {
      let i2 = { method: "POST", body: { email: e2 } };
      return i2 = normalizeLegacyOptionsArgs("This form of requestVerification(email, body?, query?) is deprecated. Consider replacing it with requestVerification(email, options?).", i2, t2, s2), this.client.send(this.baseCollectionPath + "/request-verification", i2).then(() => true);
    }
    async confirmVerification(e2, t2, s2) {
      let i2 = { method: "POST", body: { token: e2 } };
      return i2 = normalizeLegacyOptionsArgs("This form of confirmVerification(token, body?, query?) is deprecated. Consider replacing it with confirmVerification(token, options?).", i2, t2, s2), this.client.send(this.baseCollectionPath + "/confirm-verification", i2).then(() => {
        const t3 = getTokenPayload(e2), s3 = this.client.authStore.model;
        return s3 && !s3.verified && s3.id === t3.id && s3.collectionId === t3.collectionId && (s3.verified = true, this.client.authStore.save(this.client.authStore.token, s3)), true;
      });
    }
    async requestEmailChange(e2, t2, s2) {
      let i2 = { method: "POST", body: { newEmail: e2 } };
      return i2 = normalizeLegacyOptionsArgs("This form of requestEmailChange(newEmail, body?, query?) is deprecated. Consider replacing it with requestEmailChange(newEmail, options?).", i2, t2, s2), this.client.send(this.baseCollectionPath + "/request-email-change", i2).then(() => true);
    }
    async confirmEmailChange(e2, t2, s2, i2) {
      let n2 = { method: "POST", body: { token: e2, password: t2 } };
      return n2 = normalizeLegacyOptionsArgs("This form of confirmEmailChange(token, password, body?, query?) is deprecated. Consider replacing it with confirmEmailChange(token, password, options?).", n2, s2, i2), this.client.send(this.baseCollectionPath + "/confirm-email-change", n2).then(() => {
        const t3 = getTokenPayload(e2), s3 = this.client.authStore.model;
        return s3 && s3.id === t3.id && s3.collectionId === t3.collectionId && this.client.authStore.clear(), true;
      });
    }
    async listExternalAuths(e2, t2) {
      return t2 = Object.assign({ method: "GET" }, t2), this.client.send(this.baseCrudPath + "/" + encodeURIComponent(e2) + "/external-auths", t2);
    }
    async unlinkExternalAuth(e2, t2, s2) {
      return s2 = Object.assign({ method: "DELETE" }, s2), this.client.send(this.baseCrudPath + "/" + encodeURIComponent(e2) + "/external-auths/" + encodeURIComponent(t2), s2).then(() => true);
    }
    _replaceQueryParams(e2, t2 = {}) {
      let s2 = e2, i2 = "";
      e2.indexOf("?") >= 0 && (s2 = e2.substring(0, e2.indexOf("?")), i2 = e2.substring(e2.indexOf("?") + 1));
      const n2 = {}, r = i2.split("&");
      for (const e3 of r) {
        if ("" == e3)
          continue;
        const t3 = e3.split("=");
        n2[decodeURIComponent(t3[0].replace(/\+/g, " "))] = decodeURIComponent((t3[1] || "").replace(/\+/g, " "));
      }
      for (let e3 in t2)
        t2.hasOwnProperty(e3) && (null == t2[e3] ? delete n2[e3] : n2[e3] = t2[e3]);
      i2 = "";
      for (let e3 in n2)
        n2.hasOwnProperty(e3) && ("" != i2 && (i2 += "&"), i2 += encodeURIComponent(e3.replace(/%20/g, "+")) + "=" + encodeURIComponent(n2[e3].replace(/%20/g, "+")));
      return "" != i2 ? s2 + "?" + i2 : s2;
    }
  };
  function openBrowserPopup(e2) {
    if ("undefined" == typeof window || !window?.open)
      throw new ClientResponseError(new Error("Not in a browser context - please pass a custom urlCallback function."));
    let t2 = 1024, s2 = 768, i2 = window.innerWidth, n2 = window.innerHeight;
    t2 = t2 > i2 ? i2 : t2, s2 = s2 > n2 ? n2 : s2;
    let r = i2 / 2 - t2 / 2, o = n2 / 2 - s2 / 2;
    return window.open(e2, "popup_window", "width=" + t2 + ",height=" + s2 + ",top=" + o + ",left=" + r + ",resizable,menubar=no");
  }
  var CollectionService = class extends CrudService {
    get baseCrudPath() {
      return "/api/collections";
    }
    async import(e2, t2 = false, s2) {
      return s2 = Object.assign({ method: "PUT", body: { collections: e2, deleteMissing: t2 } }, s2), this.client.send(this.baseCrudPath + "/import", s2).then(() => true);
    }
  };
  var LogService = class extends BaseService {
    async getList(e2 = 1, t2 = 30, s2) {
      return (s2 = Object.assign({ method: "GET" }, s2)).query = Object.assign({ page: e2, perPage: t2 }, s2.query), this.client.send("/api/logs", s2);
    }
    async getOne(e2, t2) {
      if (!e2)
        throw new ClientResponseError({ url: this.client.buildUrl("/api/logs/"), status: 404, response: { code: 404, message: "Missing required log id.", data: {} } });
      return t2 = Object.assign({ method: "GET" }, t2), this.client.send("/api/logs/" + encodeURIComponent(e2), t2);
    }
    async getStats(e2) {
      return e2 = Object.assign({ method: "GET" }, e2), this.client.send("/api/logs/stats", e2);
    }
  };
  var HealthService = class extends BaseService {
    async check(e2) {
      return e2 = Object.assign({ method: "GET" }, e2), this.client.send("/api/health", e2);
    }
  };
  var FileService = class extends BaseService {
    getUrl(e2, t2, s2 = {}) {
      if (!t2 || !e2?.id || !e2?.collectionId && !e2?.collectionName)
        return "";
      const i2 = [];
      i2.push("api"), i2.push("files"), i2.push(encodeURIComponent(e2.collectionId || e2.collectionName)), i2.push(encodeURIComponent(e2.id)), i2.push(encodeURIComponent(t2));
      let n2 = this.client.buildUrl(i2.join("/"));
      if (Object.keys(s2).length) {
        false === s2.download && delete s2.download;
        const e3 = new URLSearchParams(s2);
        n2 += (n2.includes("?") ? "&" : "?") + e3;
      }
      return n2;
    }
    async getToken(e2) {
      return e2 = Object.assign({ method: "POST" }, e2), this.client.send("/api/files/token", e2).then((e3) => e3?.token || "");
    }
  };
  var BackupService = class extends BaseService {
    async getFullList(e2) {
      return e2 = Object.assign({ method: "GET" }, e2), this.client.send("/api/backups", e2);
    }
    async create(e2, t2) {
      return t2 = Object.assign({ method: "POST", body: { name: e2 } }, t2), this.client.send("/api/backups", t2).then(() => true);
    }
    async upload(e2, t2) {
      return t2 = Object.assign({ method: "POST", body: e2 }, t2), this.client.send("/api/backups/upload", t2).then(() => true);
    }
    async delete(e2, t2) {
      return t2 = Object.assign({ method: "DELETE" }, t2), this.client.send(`/api/backups/${encodeURIComponent(e2)}`, t2).then(() => true);
    }
    async restore(e2, t2) {
      return t2 = Object.assign({ method: "POST" }, t2), this.client.send(`/api/backups/${encodeURIComponent(e2)}/restore`, t2).then(() => true);
    }
    getDownloadUrl(e2, t2) {
      return this.client.buildUrl(`/api/backups/${encodeURIComponent(t2)}?token=${encodeURIComponent(e2)}`);
    }
  };
  var Client = class {
    constructor(e2 = "/", t2, s2 = "en-US") {
      this.cancelControllers = {}, this.recordServices = {}, this.enableAutoCancellation = true, this.baseUrl = e2, this.lang = s2, this.authStore = t2 || new LocalAuthStore(), this.admins = new AdminService(this), this.collections = new CollectionService(this), this.files = new FileService(this), this.logs = new LogService(this), this.settings = new SettingsService(this), this.realtime = new RealtimeService(this), this.health = new HealthService(this), this.backups = new BackupService(this);
    }
    collection(e2) {
      return this.recordServices[e2] || (this.recordServices[e2] = new RecordService(this, e2)), this.recordServices[e2];
    }
    autoCancellation(e2) {
      return this.enableAutoCancellation = !!e2, this;
    }
    cancelRequest(e2) {
      return this.cancelControllers[e2] && (this.cancelControllers[e2].abort(), delete this.cancelControllers[e2]), this;
    }
    cancelAllRequests() {
      for (let e2 in this.cancelControllers)
        this.cancelControllers[e2].abort();
      return this.cancelControllers = {}, this;
    }
    filter(e2, t2) {
      if (!t2)
        return e2;
      for (let s2 in t2) {
        let i2 = t2[s2];
        switch (typeof i2) {
          case "boolean":
          case "number":
            i2 = "" + i2;
            break;
          case "string":
            i2 = "'" + i2.replace(/'/g, "\\'") + "'";
            break;
          default:
            i2 = null === i2 ? "null" : i2 instanceof Date ? "'" + i2.toISOString().replace("T", " ") + "'" : "'" + JSON.stringify(i2).replace(/'/g, "\\'") + "'";
        }
        e2 = e2.replaceAll("{:" + s2 + "}", i2);
      }
      return e2;
    }
    getFileUrl(e2, t2, s2 = {}) {
      return this.files.getUrl(e2, t2, s2);
    }
    buildUrl(e2) {
      let t2 = this.baseUrl;
      return "undefined" == typeof window || !window.location || t2.startsWith("https://") || t2.startsWith("http://") || (t2 = window.location.origin?.endsWith("/") ? window.location.origin.substring(0, window.location.origin.length - 1) : window.location.origin || "", this.baseUrl.startsWith("/") || (t2 += window.location.pathname || "/", t2 += t2.endsWith("/") ? "" : "/"), t2 += this.baseUrl), e2 && (t2 += t2.endsWith("/") ? "" : "/", t2 += e2.startsWith("/") ? e2.substring(1) : e2), t2;
    }
    async send(e2, t2) {
      t2 = this.initSendOptions(e2, t2);
      let s2 = this.buildUrl(e2);
      if (this.beforeSend) {
        const e3 = Object.assign({}, await this.beforeSend(s2, t2));
        void 0 !== e3.url || void 0 !== e3.options ? (s2 = e3.url || s2, t2 = e3.options || t2) : Object.keys(e3).length && (t2 = e3, console?.warn && console.warn("Deprecated format of beforeSend return: please use `return { url, options }`, instead of `return options`."));
      }
      if (void 0 !== t2.query) {
        const e3 = this.serializeQueryParams(t2.query);
        e3 && (s2 += (s2.includes("?") ? "&" : "?") + e3), delete t2.query;
      }
      "application/json" == this.getHeader(t2.headers, "Content-Type") && t2.body && "string" != typeof t2.body && (t2.body = JSON.stringify(t2.body));
      return (t2.fetch || fetch)(s2, t2).then(async (e3) => {
        let t3 = {};
        try {
          t3 = await e3.json();
        } catch (e4) {
        }
        if (this.afterSend && (t3 = await this.afterSend(e3, t3)), e3.status >= 400)
          throw new ClientResponseError({ url: e3.url, status: e3.status, data: t3 });
        return t3;
      }).catch((e3) => {
        throw new ClientResponseError(e3);
      });
    }
    initSendOptions(e2, t2) {
      if ((t2 = Object.assign({ method: "GET" }, t2)).body = this.convertToFormDataIfNeeded(t2.body), normalizeUnknownQueryParams(t2), t2.query = Object.assign({}, t2.params, t2.query), void 0 === t2.requestKey && (false === t2.$autoCancel || false === t2.query.$autoCancel ? t2.requestKey = null : (t2.$cancelKey || t2.query.$cancelKey) && (t2.requestKey = t2.$cancelKey || t2.query.$cancelKey)), delete t2.$autoCancel, delete t2.query.$autoCancel, delete t2.$cancelKey, delete t2.query.$cancelKey, null !== this.getHeader(t2.headers, "Content-Type") || this.isFormData(t2.body) || (t2.headers = Object.assign({}, t2.headers, { "Content-Type": "application/json" })), null === this.getHeader(t2.headers, "Accept-Language") && (t2.headers = Object.assign({}, t2.headers, { "Accept-Language": this.lang })), this.authStore.token && null === this.getHeader(t2.headers, "Authorization") && (t2.headers = Object.assign({}, t2.headers, { Authorization: this.authStore.token })), this.enableAutoCancellation && null !== t2.requestKey) {
        const s2 = t2.requestKey || (t2.method || "GET") + e2;
        delete t2.requestKey, this.cancelRequest(s2);
        const i2 = new AbortController();
        this.cancelControllers[s2] = i2, t2.signal = i2.signal;
      }
      return t2;
    }
    convertToFormDataIfNeeded(e2) {
      if ("undefined" == typeof FormData || void 0 === e2 || "object" != typeof e2 || null === e2 || this.isFormData(e2) || !this.hasBlobField(e2))
        return e2;
      const t2 = new FormData();
      for (const s2 in e2) {
        const i2 = e2[s2];
        if ("object" != typeof i2 || this.hasBlobField({ data: i2 })) {
          const e3 = Array.isArray(i2) ? i2 : [i2];
          for (let i3 of e3)
            t2.append(s2, i3);
        } else {
          let e3 = {};
          e3[s2] = i2, t2.append("@jsonPayload", JSON.stringify(e3));
        }
      }
      return t2;
    }
    hasBlobField(e2) {
      for (const t2 in e2) {
        const s2 = Array.isArray(e2[t2]) ? e2[t2] : [e2[t2]];
        for (const e3 of s2)
          if ("undefined" != typeof Blob && e3 instanceof Blob || "undefined" != typeof File && e3 instanceof File)
            return true;
      }
      return false;
    }
    getHeader(e2, t2) {
      e2 = e2 || {}, t2 = t2.toLowerCase();
      for (let s2 in e2)
        if (s2.toLowerCase() == t2)
          return e2[s2];
      return null;
    }
    isFormData(e2) {
      return e2 && ("FormData" === e2.constructor.name || "undefined" != typeof FormData && e2 instanceof FormData);
    }
    serializeQueryParams(e2) {
      const t2 = [];
      for (const s2 in e2) {
        if (null === e2[s2])
          continue;
        const i2 = e2[s2], n2 = encodeURIComponent(s2);
        if (Array.isArray(i2))
          for (const e3 of i2)
            t2.push(n2 + "=" + encodeURIComponent(e3));
        else
          i2 instanceof Date ? t2.push(n2 + "=" + encodeURIComponent(i2.toISOString())) : null !== typeof i2 && "object" == typeof i2 ? t2.push(n2 + "=" + encodeURIComponent(JSON.stringify(i2))) : t2.push(n2 + "=" + encodeURIComponent(i2));
      }
      return t2.join("&");
    }
  };

  // pb.js
  var url = "https://hostel-st.pockethost.io/";
  var pb = new Client(url);

  // _components/RoomsTable.svelte
  function get_each_context(ctx, list, i2) {
    const child_ctx = ctx.slice();
    child_ctx[8] = list[i2];
    return child_ctx;
  }
  function create_each_block(ctx) {
    let tr;
    let td0;
    let span;
    let t0_value = (
      /*$Vagas*/
      ctx[4].filter(func).length + ""
    );
    let t0;
    let t1;
    let td1;
    let t2;
    let td2;
    let t3_value = (
      /*q*/
      ctx[8].quarto + ""
    );
    let t3;
    let t4;
    let td3;
    let t5;
    let t6_value = (
      /*q*/
      ctx[8].diaria + ""
    );
    let t6;
    let t7;
    let td4;
    let t8;
    let td5;
    let t11;
    function func(...args) {
      return (
        /*func*/
        ctx[6](
          /*q*/
          ctx[8],
          ...args
        )
      );
    }
    return {
      c() {
        tr = element("tr");
        td0 = element("td");
        span = element("span");
        t0 = text(t0_value);
        t1 = space();
        td1 = element("td");
        t2 = space();
        td2 = element("td");
        t3 = text(t3_value);
        t4 = space();
        td3 = element("td");
        t5 = text("R$ ");
        t6 = text(t6_value);
        t7 = space();
        td4 = element("td");
        t8 = space();
        td5 = element("td");
        td5.innerHTML = `<div class="flex gap-2"><button class="border border-white/30 hover:bg-violet-900/30 hover:border-none transition-all rounded p-1"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M240-400q-33 0-56.5-23.5T160-480q0-33 23.5-56.5T240-560q33 0 56.5 23.5T320-480q0 33-23.5 56.5T240-400Zm240 0q-33 0-56.5-23.5T400-480q0-33 23.5-56.5T480-560q33 0 56.5 23.5T560-480q0 33-23.5 56.5T480-400Zm240 0q-33 0-56.5-23.5T640-480q0-33 23.5-56.5T720-560q33 0 56.5 23.5T800-480q0 33-23.5 56.5T720-400Z"></path></svg></button> <button class="border border-white/30 hover:bg-lime-400/30 hover:border-none transition-all rounded p-1"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M200-200h57l391-391-57-57-391 391v57Zm-80 80v-170l528-527q12-11 26.5-17t30.5-6q16 0 31 6t26 18l55 56q12 11 17.5 26t5.5 30q0 16-5.5 30.5T817-647L290-120H120Zm640-584-56-56 56 56Zm-141 85-28-29 57 57-29-28Z"></path></svg></button> <button class="border border-white/30 hover:bg-red-900/30 hover:border-none transition-all rounded p-1"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm400-600H280v520h400v-520ZM360-280h80v-360h-80v360Zm160 0h80v-360h-80v360ZM280-720v520-520Z"></path></svg></button></div>`;
        t11 = space();
        attr(span, "class", "mx-auto");
        attr(td0, "class", "flex");
        attr(td2, "class", "p-10");
        attr(td3, "class", "whitespace-nowrap");
        attr(tr, "class", "border-b border-white/40");
      },
      m(target, anchor) {
        insert(target, tr, anchor);
        append(tr, td0);
        append(td0, span);
        append(span, t0);
        append(tr, t1);
        append(tr, td1);
        append(tr, t2);
        append(tr, td2);
        append(td2, t3);
        append(tr, t4);
        append(tr, td3);
        append(td3, t5);
        append(td3, t6);
        append(tr, t7);
        append(tr, td4);
        append(tr, t8);
        append(tr, td5);
        append(tr, t11);
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & /*$Vagas, $Quartos*/
        24 && t0_value !== (t0_value = /*$Vagas*/
        ctx[4].filter(func).length + ""))
          set_data(t0, t0_value);
        if (dirty & /*$Quartos*/
        8 && t3_value !== (t3_value = /*q*/
        ctx[8].quarto + ""))
          set_data(t3, t3_value);
        if (dirty & /*$Quartos*/
        8 && t6_value !== (t6_value = /*q*/
        ctx[8].diaria + ""))
          set_data(t6, t6_value);
      },
      d(detaching) {
        if (detaching) {
          detach(tr);
        }
      }
    };
  }
  function create_fragment(ctx) {
    let div3;
    let div1;
    let div0;
    let t1;
    let button;
    let t3;
    let div2;
    let table;
    let colgroup;
    let t10;
    let thead;
    let t18;
    let tbody;
    let mounted;
    let dispose;
    let each_value = ensure_array_like(
      /*$Quartos*/
      ctx[3]
    );
    let each_blocks = [];
    for (let i2 = 0; i2 < each_value.length; i2 += 1) {
      each_blocks[i2] = create_each_block(get_each_context(ctx, each_value, i2));
    }
    return {
      c() {
        div3 = element("div");
        div1 = element("div");
        div0 = element("div");
        div0.textContent = "Quartos";
        t1 = space();
        button = element("button");
        button.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-plus"><path d="M12 5v14M5 12h14"></path></svg>
			Create`;
        t3 = space();
        div2 = element("div");
        table = element("table");
        colgroup = element("colgroup");
        colgroup.innerHTML = `<!-- <col span="1" class="w-24" /> --> <col span="1" class="w-20"/> <col span="1" class="w-3"/> <col span="1"/> <col span="1" class="w-10"/> <col span="1" class="w-3"/> <col span="1" class="w-14"/>`;
        t10 = space();
        thead = element("thead");
        thead.innerHTML = `<tr><th>Capacidade</th> <th></th> <th>Quarto</th> <th>Di\xE1ria</th> <th></th></tr>`;
        t18 = space();
        tbody = element("tbody");
        for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].c();
        }
        attr(div0, "class", "cards-view !block");
        attr(button, "class", "cards-button button !flex ml-auto cursor-pointer hover:scale-105 transition-all");
        attr(div1, "class", "cards-header");
        attr(table, "class", "table");
        attr(div2, "class", "cards card overflow-scroll hover:scale-100");
        attr(div3, "class", "cards-wrapper");
        set_style(div3, "--delay", ".8s");
      },
      m(target, anchor) {
        insert(target, div3, anchor);
        append(div3, div1);
        append(div1, div0);
        append(div1, t1);
        append(div1, button);
        append(div3, t3);
        append(div3, div2);
        append(div2, table);
        append(table, colgroup);
        append(table, t10);
        append(table, thead);
        append(table, t18);
        append(table, tbody);
        for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
          if (each_blocks[i2]) {
            each_blocks[i2].m(tbody, null);
          }
        }
        if (!mounted) {
          dispose = listen(
            button,
            "click",
            /*click_handler*/
            ctx[5]
          );
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & /*$Quartos, $Vagas*/
        24) {
          each_value = ensure_array_like(
            /*$Quartos*/
            ctx2[3]
          );
          let i2;
          for (i2 = 0; i2 < each_value.length; i2 += 1) {
            const child_ctx = get_each_context(ctx2, each_value, i2);
            if (each_blocks[i2]) {
              each_blocks[i2].p(child_ctx, dirty);
            } else {
              each_blocks[i2] = create_each_block(child_ctx);
              each_blocks[i2].c();
              each_blocks[i2].m(tbody, null);
            }
          }
          for (; i2 < each_blocks.length; i2 += 1) {
            each_blocks[i2].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div3);
        }
        destroy_each(each_blocks, detaching);
        mounted = false;
        dispose();
      }
    };
  }
  function instance($self, $props, $invalidate) {
    let $showRoomModal;
    let $Quartos, $unsubscribe_Quartos = noop, $subscribe_Quartos = () => ($unsubscribe_Quartos(), $unsubscribe_Quartos = subscribe(Quartos, ($value) => $invalidate(3, $Quartos = $value)), Quartos);
    let $Vagas, $unsubscribe_Vagas = noop, $subscribe_Vagas = () => ($unsubscribe_Vagas(), $unsubscribe_Vagas = subscribe(Vagas, ($value) => $invalidate(4, $Vagas = $value)), Vagas);
    component_subscribe($self, ShowRoomModal_default, ($value) => $invalidate(2, $showRoomModal = $value));
    $self.$.on_destroy.push(() => $unsubscribe_Quartos());
    $self.$.on_destroy.push(() => $unsubscribe_Vagas());
    const data = writable({});
    let { Quartos = [] } = $props;
    $subscribe_Quartos();
    let { Vagas = [] } = $props;
    $subscribe_Vagas();
    const click_handler = () => set_store_value(ShowRoomModal_default, $showRoomModal = true, $showRoomModal);
    const func = (q, v) => v.quarto = q.id;
    $self.$set = ($props2) => {
      if ("Quartos" in $props2)
        $subscribe_Quartos($invalidate(0, Quartos = $props2.Quartos));
      if ("Vagas" in $props2)
        $subscribe_Vagas($invalidate(1, Vagas = $props2.Vagas));
    };
    return [Quartos, Vagas, $showRoomModal, $Quartos, $Vagas, click_handler, func];
  }
  var RoomsTable = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance, create_fragment, safe_not_equal, { Quartos: 0, Vagas: 1 });
    }
  };
  var RoomsTable_default = RoomsTable;

  // stores/ShowSpotModal.js
  var showSpotModal = writable(false);
  var ShowSpotModal_default = showSpotModal;

  // _components/SpotsTable.svelte
  function get_each_context2(ctx, list, i2) {
    const child_ctx = ctx.slice();
    child_ctx[7] = list[i2];
    return child_ctx;
  }
  function create_each_block2(ctx) {
    let tr;
    let td0;
    let span;
    let t0_value = (
      /*vaga*/
      ctx[7].tipo + ""
    );
    let t0;
    let t1;
    let td1;
    let t2;
    let td2;
    let t3_value = (
      /*$Quartos*/
      ctx[4].find(func).quarto + ""
    );
    let t3;
    let t4;
    let td3;
    let t5;
    let t6_value = (
      /*vaga*/
      ctx[7].diaria + ""
    );
    let t6;
    let t7;
    let td4;
    let t8;
    let td5;
    let t11;
    function func(...args) {
      return (
        /*func*/
        ctx[6](
          /*vaga*/
          ctx[7],
          ...args
        )
      );
    }
    return {
      c() {
        tr = element("tr");
        td0 = element("td");
        span = element("span");
        t0 = text(t0_value);
        t1 = space();
        td1 = element("td");
        t2 = space();
        td2 = element("td");
        t3 = text(t3_value);
        t4 = space();
        td3 = element("td");
        t5 = text("R$ ");
        t6 = text(t6_value);
        t7 = space();
        td4 = element("td");
        t8 = space();
        td5 = element("td");
        td5.innerHTML = `<div class="flex gap-2"><button class="border border-white/30 hover:bg-violet-900/30 hover:border-none transition-all rounded p-1"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M240-400q-33 0-56.5-23.5T160-480q0-33 23.5-56.5T240-560q33 0 56.5 23.5T320-480q0 33-23.5 56.5T240-400Zm240 0q-33 0-56.5-23.5T400-480q0-33 23.5-56.5T480-560q33 0 56.5 23.5T560-480q0 33-23.5 56.5T480-400Zm240 0q-33 0-56.5-23.5T640-480q0-33 23.5-56.5T720-560q33 0 56.5 23.5T800-480q0 33-23.5 56.5T720-400Z"></path></svg></button> <button class="border border-white/30 hover:bg-lime-400/30 hover:border-none transition-all rounded p-1"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M200-200h57l391-391-57-57-391 391v57Zm-80 80v-170l528-527q12-11 26.5-17t30.5-6q16 0 31 6t26 18l55 56q12 11 17.5 26t5.5 30q0 16-5.5 30.5T817-647L290-120H120Zm640-584-56-56 56 56Zm-141 85-28-29 57 57-29-28Z"></path></svg></button> <button class="border border-white/30 hover:bg-red-900/30 hover:border-none transition-all rounded p-1"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm400-600H280v520h400v-520ZM360-280h80v-360h-80v360Zm160 0h80v-360h-80v360ZM280-720v520-520Z"></path></svg></button></div>`;
        t11 = space();
        attr(span, "class", "mx-auto whitespace-nowrap");
        attr(td0, "class", "flex");
        attr(td3, "class", "whitespace-nowrap");
        attr(tr, "class", "border-b border-white/40");
      },
      m(target, anchor) {
        insert(target, tr, anchor);
        append(tr, td0);
        append(td0, span);
        append(span, t0);
        append(tr, t1);
        append(tr, td1);
        append(tr, t2);
        append(tr, td2);
        append(td2, t3);
        append(tr, t4);
        append(tr, td3);
        append(td3, t5);
        append(td3, t6);
        append(tr, t7);
        append(tr, td4);
        append(tr, t8);
        append(tr, td5);
        append(tr, t11);
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & /*$Vagas*/
        8 && t0_value !== (t0_value = /*vaga*/
        ctx[7].tipo + ""))
          set_data(t0, t0_value);
        if (dirty & /*$Quartos, $Vagas*/
        24 && t3_value !== (t3_value = /*$Quartos*/
        ctx[4].find(func).quarto + ""))
          set_data(t3, t3_value);
        if (dirty & /*$Vagas*/
        8 && t6_value !== (t6_value = /*vaga*/
        ctx[7].diaria + ""))
          set_data(t6, t6_value);
      },
      d(detaching) {
        if (detaching) {
          detach(tr);
        }
      }
    };
  }
  function create_fragment2(ctx) {
    let div3;
    let div1;
    let div0;
    let t1;
    let button;
    let t3;
    let div2;
    let table;
    let colgroup;
    let t10;
    let thead;
    let t17;
    let tbody;
    let mounted;
    let dispose;
    let each_value = ensure_array_like(
      /*$Vagas*/
      ctx[3]
    );
    let each_blocks = [];
    for (let i2 = 0; i2 < each_value.length; i2 += 1) {
      each_blocks[i2] = create_each_block2(get_each_context2(ctx, each_value, i2));
    }
    return {
      c() {
        div3 = element("div");
        div1 = element("div");
        div0 = element("div");
        div0.textContent = "Vagas";
        t1 = space();
        button = element("button");
        button.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-plus"><path d="M12 5v14M5 12h14"></path></svg>
			Create`;
        t3 = space();
        div2 = element("div");
        table = element("table");
        colgroup = element("colgroup");
        colgroup.innerHTML = `<!-- <col span="1" class="w-24" /> --> <col span="1" class="w-20"/> <col span="1" class="w-3"/> <col span="1"/> <col span="1" class="w-10"/> <col span="1" class="w-3"/> <col span="1" class="w-14"/>`;
        t10 = space();
        thead = element("thead");
        thead.innerHTML = `<tr><th class="text-start">Tipo</th> <th></th> <th>Quarto</th> <th>Di\xE1ria</th></tr>`;
        t17 = space();
        tbody = element("tbody");
        for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].c();
        }
        attr(div0, "class", "cards-view !block");
        attr(button, "class", "cards-button button !flex ml-auto cursor-pointer hover:scale-105 transition-all");
        attr(div1, "class", "cards-header");
        attr(table, "class", "table");
        attr(div2, "class", "cards card overflow-scroll hover:scale-100");
        attr(div3, "class", "cards-wrapper");
        set_style(div3, "--delay", ".6s");
      },
      m(target, anchor) {
        insert(target, div3, anchor);
        append(div3, div1);
        append(div1, div0);
        append(div1, t1);
        append(div1, button);
        append(div3, t3);
        append(div3, div2);
        append(div2, table);
        append(table, colgroup);
        append(table, t10);
        append(table, thead);
        append(table, t17);
        append(table, tbody);
        for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
          if (each_blocks[i2]) {
            each_blocks[i2].m(tbody, null);
          }
        }
        if (!mounted) {
          dispose = listen(
            button,
            "click",
            /*click_handler*/
            ctx[5]
          );
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & /*$Vagas, $Quartos*/
        24) {
          each_value = ensure_array_like(
            /*$Vagas*/
            ctx2[3]
          );
          let i2;
          for (i2 = 0; i2 < each_value.length; i2 += 1) {
            const child_ctx = get_each_context2(ctx2, each_value, i2);
            if (each_blocks[i2]) {
              each_blocks[i2].p(child_ctx, dirty);
            } else {
              each_blocks[i2] = create_each_block2(child_ctx);
              each_blocks[i2].c();
              each_blocks[i2].m(tbody, null);
            }
          }
          for (; i2 < each_blocks.length; i2 += 1) {
            each_blocks[i2].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div3);
        }
        destroy_each(each_blocks, detaching);
        mounted = false;
        dispose();
      }
    };
  }
  function instance2($self, $props, $invalidate) {
    let $showSpotModal;
    let $Vagas, $unsubscribe_Vagas = noop, $subscribe_Vagas = () => ($unsubscribe_Vagas(), $unsubscribe_Vagas = subscribe(Vagas, ($value) => $invalidate(3, $Vagas = $value)), Vagas);
    let $Quartos, $unsubscribe_Quartos = noop, $subscribe_Quartos = () => ($unsubscribe_Quartos(), $unsubscribe_Quartos = subscribe(Quartos, ($value) => $invalidate(4, $Quartos = $value)), Quartos);
    component_subscribe($self, ShowSpotModal_default, ($value) => $invalidate(2, $showSpotModal = $value));
    $self.$.on_destroy.push(() => $unsubscribe_Vagas());
    $self.$.on_destroy.push(() => $unsubscribe_Quartos());
    let { Vagas = [] } = $props;
    $subscribe_Vagas();
    let { Quartos = [] } = $props;
    $subscribe_Quartos();
    const click_handler = () => set_store_value(ShowSpotModal_default, $showSpotModal = true, $showSpotModal);
    const func = (vaga, q) => q.id == vaga.quarto;
    $self.$set = ($props2) => {
      if ("Vagas" in $props2)
        $subscribe_Vagas($invalidate(0, Vagas = $props2.Vagas));
      if ("Quartos" in $props2)
        $subscribe_Quartos($invalidate(1, Quartos = $props2.Quartos));
    };
    return [Vagas, Quartos, $showSpotModal, $Vagas, $Quartos, click_handler, func];
  }
  var SpotsTable = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance2, create_fragment2, safe_not_equal, { Vagas: 0, Quartos: 1 });
    }
  };
  var SpotsTable_default = SpotsTable;

  // _components/VacancyChart.svelte
  var import_chart = __toESM(require_chart());
  function create_fragment3(ctx) {
    let canvas_1;
    return {
      c() {
        canvas_1 = element("canvas");
        attr(canvas_1, "class", "my-auto max-h-72");
      },
      m(target, anchor) {
        insert(target, canvas_1, anchor);
        ctx[1](canvas_1);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(canvas_1);
        }
        ctx[1](null);
      }
    };
  }
  function instance3($self, $props, $invalidate) {
    let values = [20, 10, 5, 2, 20, 30, 45];
    let labels = ["January", "February", "March", "April", "May", "June", "July"];
    let canvas;
    onMount(async (promise) => {
      let ctx = canvas.getContext("2d");
      import_chart.default.defaults.color = "#000";
      var chart = new import_chart.default(
        ctx,
        {
          type: "line",
          data: {
            labels,
            datasets: [
              {
                backgroundColor: "rgba(255, 99, 132, .1)",
                borderColor: "rgb(255, 99, 132)",
                data: values
              }
            ]
          },
          options: { legend: { display: false } }
        }
      );
    });
    function canvas_1_binding($value) {
      binding_callbacks[$value ? "unshift" : "push"](() => {
        canvas = $value;
        $invalidate(0, canvas);
      });
    }
    return [canvas, canvas_1_binding];
  }
  var VacancyChart = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance3, create_fragment3, safe_not_equal, {});
    }
  };
  var VacancyChart_default = VacancyChart;

  // _components/RoomsModal.svelte
  function create_if_block(ctx) {
    let div2;
    let div1;
    let div0;
    let label0;
    let span0;
    let t1;
    let input0;
    let t2;
    let label1;
    let span1;
    let t4;
    let input1;
    let input1_value_value;
    let t5;
    let label2;
    let span2;
    let t7;
    let input2;
    let input2_value_value;
    let t8;
    let label3;
    let span3;
    let t10;
    let textarea;
    let textarea_value_value;
    let t11;
    let button;
    let mounted;
    let dispose;
    return {
      c() {
        div2 = element("div");
        div1 = element("div");
        div0 = element("div");
        label0 = element("label");
        span0 = element("span");
        span0.textContent = "Logo:";
        t1 = space();
        input0 = element("input");
        t2 = space();
        label1 = element("label");
        span1 = element("span");
        span1.textContent = "Quarto:";
        t4 = space();
        input1 = element("input");
        t5 = space();
        label2 = element("label");
        span2 = element("span");
        span2.textContent = "Diaria:";
        t7 = space();
        input2 = element("input");
        t8 = space();
        label3 = element("label");
        span3 = element("span");
        span3.textContent = "Detalhes:";
        t10 = space();
        textarea = element("textarea");
        t11 = space();
        button = element("button");
        button.textContent = "+ Create";
        attr(span0, "class", "text-xl");
        attr(input0, "type", "file");
        attr(input0, "accept", ".jpg, .png, .jpeg");
        attr(input0, "class", "bg-transparent border border-white/50 w-full p-3 rounded-lg focus:outline-none");
        attr(span1, "class", "text-xl");
        attr(input1, "type", "text");
        input1.value = input1_value_value = /*$data*/
        ctx[1].quarto;
        attr(input1, "class", "bg-transparent border border-white/50 w-full p-3 rounded-lg focus:outline-none");
        attr(span2, "class", "text-xl");
        attr(input2, "type", "number");
        input2.value = input2_value_value = /*$data*/
        ctx[1].diaria;
        attr(input2, "class", "bg-transparent border border-white/50 w-full p-3 rounded-lg focus:outline-none");
        attr(span3, "class", "text-xl");
        textarea.value = textarea_value_value = /*$data*/
        ctx[1].detalhes;
        attr(textarea, "class", "bg-transparent border border-white/50 w-full h-full p-3 rounded-lg resize-none focus:outline-none");
        attr(button, "class", "p-3 rounded-sm mx-auto mt-auto w-fit border border-white/40");
        attr(div0, "class", "size-full flex flex-col gap-5");
        attr(div1, "class", "w-2/5 h-5/6 max-h-[600px] min-w-[600px] bg-black/40 rounded-xl backdrop-blur-sm mx-auto mt-48 lg:my-auto border border-white/30 transition-all p-5");
        attr(div2, "class", "absolute h-svh w-svw bg-black/20 backdrop-blur-sm flex");
      },
      m(target, anchor) {
        insert(target, div2, anchor);
        append(div2, div1);
        append(div1, div0);
        append(div0, label0);
        append(label0, span0);
        append(label0, t1);
        append(label0, input0);
        append(div0, t2);
        append(div0, label1);
        append(label1, span1);
        append(label1, t4);
        append(label1, input1);
        append(div0, t5);
        append(div0, label2);
        append(label2, span2);
        append(label2, t7);
        append(label2, input2);
        append(div0, t8);
        append(div0, label3);
        append(label3, span3);
        append(label3, t10);
        append(label3, textarea);
        append(div0, t11);
        append(div0, button);
        if (!mounted) {
          dispose = [
            listen(
              input0,
              "input",
              /*input_handler*/
              ctx[4]
            ),
            listen(
              input1,
              "input",
              /*input_handler_1*/
              ctx[5]
            ),
            listen(
              input2,
              "input",
              /*input_handler_2*/
              ctx[6]
            ),
            listen(
              textarea,
              "input",
              /*input_handler_3*/
              ctx[7]
            ),
            listen(
              button,
              "click",
              /*create*/
              ctx[3]
            ),
            listen(
              div2,
              "click",
              /*click_handler*/
              ctx[8]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & /*$data*/
        2 && input1_value_value !== (input1_value_value = /*$data*/
        ctx2[1].quarto) && input1.value !== input1_value_value) {
          input1.value = input1_value_value;
        }
        if (dirty & /*$data*/
        2 && input2_value_value !== (input2_value_value = /*$data*/
        ctx2[1].diaria) && input2.value !== input2_value_value) {
          input2.value = input2_value_value;
        }
        if (dirty & /*$data*/
        2 && textarea_value_value !== (textarea_value_value = /*$data*/
        ctx2[1].detalhes)) {
          textarea.value = textarea_value_value;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div2);
        }
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function create_fragment4(ctx) {
    let if_block_anchor;
    let if_block = (
      /*$showRoomModal*/
      ctx[0] && create_if_block(ctx)
    );
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, [dirty]) {
        if (
          /*$showRoomModal*/
          ctx2[0]
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if (if_block)
          if_block.d(detaching);
      }
    };
  }
  function instance4($self, $props, $invalidate) {
    let $showRoomModal;
    let $data;
    component_subscribe($self, ShowRoomModal_default, ($value) => $invalidate(0, $showRoomModal = $value));
    let data = writable({
      quarto: "",
      diaria: 40,
      detalhes: "",
      logo: {}
    });
    component_subscribe($self, data, (value) => $invalidate(1, $data = value));
    async function create() {
      await pb.collection("quartos").create($data);
      set_store_value(ShowRoomModal_default, $showRoomModal = false, $showRoomModal);
    }
    const input_handler = (e2) => set_store_value(data, $data.logo = e2.target.files[0], $data);
    const input_handler_1 = (e2) => set_store_value(data, $data.quarto = e2.target.value, $data);
    const input_handler_2 = (e2) => set_store_value(data, $data.diaria = e2.target.value, $data);
    const input_handler_3 = (e2) => set_store_value(data, $data.detalhes = e2.target.value, $data);
    const click_handler = (e2) => {
      e2.stopPropagation();
      if (e2.target != e2.currentTarget)
        return;
      set_store_value(ShowRoomModal_default, $showRoomModal = false, $showRoomModal);
    };
    return [
      $showRoomModal,
      $data,
      data,
      create,
      input_handler,
      input_handler_1,
      input_handler_2,
      input_handler_3,
      click_handler
    ];
  }
  var RoomsModal = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance4, create_fragment4, safe_not_equal, {});
    }
  };
  var RoomsModal_default = RoomsModal;

  // _components/SpotsModal.svelte
  function get_each_context3(ctx, list, i2) {
    const child_ctx = ctx.slice();
    child_ctx[12] = list[i2];
    return child_ctx;
  }
  function create_if_block2(ctx) {
    let c0;
    let t0;
    let c1;
    let t1;
    let div2;
    let div1;
    let div0;
    let label0;
    let span0;
    let t3;
    let input0;
    let t4;
    let label1;
    let span1;
    let t6;
    let select;
    let select_value_value;
    let t7;
    let label2;
    let span2;
    let t9;
    let input1;
    let input1_value_value;
    let t10;
    let label3;
    let span3;
    let t12;
    let textarea;
    let textarea_value_value;
    let t13;
    let button;
    let mounted;
    let dispose;
    let each_value = ensure_array_like(
      /*Quartos*/
      ctx[0]
    );
    let each_blocks = [];
    for (let i2 = 0; i2 < each_value.length; i2 += 1) {
      each_blocks[i2] = create_each_block3(get_each_context3(ctx, each_value, i2));
    }
    return {
      c() {
        c0 = comment(" svelte-ignore a11y-click-events-have-key-events ");
        t0 = space();
        c1 = comment(" svelte-ignore a11y-no-static-element-interactions ");
        t1 = space();
        div2 = element("div");
        div1 = element("div");
        div0 = element("div");
        label0 = element("label");
        span0 = element("span");
        span0.textContent = "Logo:";
        t3 = space();
        input0 = element("input");
        t4 = space();
        label1 = element("label");
        span1 = element("span");
        span1.textContent = "Quarto:";
        t6 = space();
        select = element("select");
        for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].c();
        }
        t7 = space();
        label2 = element("label");
        span2 = element("span");
        span2.textContent = "Diaria:";
        t9 = space();
        input1 = element("input");
        t10 = space();
        label3 = element("label");
        span3 = element("span");
        span3.textContent = "Detalhes:";
        t12 = space();
        textarea = element("textarea");
        t13 = space();
        button = element("button");
        button.textContent = "+ Create";
        attr(span0, "class", "text-xl");
        attr(input0, "type", "file");
        attr(input0, "accept", ".jpg, .png, .jpeg");
        attr(input0, "class", "bg-transparent border border-white/50 w-full p-3 rounded-lg focus:outline-none");
        attr(span1, "class", "text-xl");
        attr(select, "class", "bg-transparent border border-white/50 w-full p-3 rounded-lg focus:outline-none");
        attr(span2, "class", "text-xl");
        attr(input1, "type", "number");
        input1.value = input1_value_value = /*$data*/
        ctx[2].diaria;
        attr(input1, "class", "bg-transparent border border-white/50 w-full p-3 rounded-lg focus:outline-none");
        attr(span3, "class", "text-xl");
        textarea.value = textarea_value_value = /*$data*/
        ctx[2].detalhes;
        attr(textarea, "class", "bg-transparent border border-white/50 w-full h-full p-3 rounded-lg resize-none focus:outline-none");
        attr(button, "class", "p-3 rounded-sm mx-auto mt-auto w-fit border border-white/40");
        attr(div0, "class", "size-full flex flex-col gap-5");
        attr(div1, "class", "w-2/5 h-5/6 max-h-[600px] min-w-[600px] bg-black/40 rounded-xl backdrop-blur-sm mx-auto mt-48 lg:my-auto border border-white/30 transition-all p-5");
        attr(div2, "class", "absolute h-svh w-svw bg-black/20 backdrop-blur-sm flex");
      },
      m(target, anchor) {
        insert(target, c0, anchor);
        insert(target, t0, anchor);
        insert(target, c1, anchor);
        insert(target, t1, anchor);
        insert(target, div2, anchor);
        append(div2, div1);
        append(div1, div0);
        append(div0, label0);
        append(label0, span0);
        append(label0, t3);
        append(label0, input0);
        append(div0, t4);
        append(div0, label1);
        append(label1, span1);
        append(label1, t6);
        append(label1, select);
        for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
          if (each_blocks[i2]) {
            each_blocks[i2].m(select, null);
          }
        }
        select_option(
          select,
          /*$data*/
          ctx[2].quarto
        );
        append(div0, t7);
        append(div0, label2);
        append(label2, span2);
        append(label2, t9);
        append(label2, input1);
        append(div0, t10);
        append(div0, label3);
        append(label3, span3);
        append(label3, t12);
        append(label3, textarea);
        append(div0, t13);
        append(div0, button);
        if (!mounted) {
          dispose = [
            listen(
              input0,
              "input",
              /*input_handler*/
              ctx[6]
            ),
            listen(
              select,
              "input",
              /*input_handler_1*/
              ctx[7]
            ),
            listen(
              input1,
              "input",
              /*input_handler_2*/
              ctx[8]
            ),
            listen(
              textarea,
              "input",
              /*input_handler_3*/
              ctx[9]
            ),
            listen(
              button,
              "click",
              /*create*/
              ctx[4]
            ),
            listen(
              div2,
              "click",
              /*click_handler*/
              ctx[10]
            )
          ];
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & /*Quartos*/
        1) {
          each_value = ensure_array_like(
            /*Quartos*/
            ctx2[0]
          );
          let i2;
          for (i2 = 0; i2 < each_value.length; i2 += 1) {
            const child_ctx = get_each_context3(ctx2, each_value, i2);
            if (each_blocks[i2]) {
              each_blocks[i2].p(child_ctx, dirty);
            } else {
              each_blocks[i2] = create_each_block3(child_ctx);
              each_blocks[i2].c();
              each_blocks[i2].m(select, null);
            }
          }
          for (; i2 < each_blocks.length; i2 += 1) {
            each_blocks[i2].d(1);
          }
          each_blocks.length = each_value.length;
        }
        if (dirty & /*$data, Quartos*/
        5 && select_value_value !== (select_value_value = /*$data*/
        ctx2[2].quarto)) {
          select_option(
            select,
            /*$data*/
            ctx2[2].quarto
          );
        }
        if (dirty & /*$data, Quartos*/
        5 && input1_value_value !== (input1_value_value = /*$data*/
        ctx2[2].diaria) && input1.value !== input1_value_value) {
          input1.value = input1_value_value;
        }
        if (dirty & /*$data, Quartos*/
        5 && textarea_value_value !== (textarea_value_value = /*$data*/
        ctx2[2].detalhes)) {
          textarea.value = textarea_value_value;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(c0);
          detach(t0);
          detach(c1);
          detach(t1);
          detach(div2);
        }
        destroy_each(each_blocks, detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function create_each_block3(ctx) {
    let option;
    let t_value = (
      /*q*/
      ctx[12].quarto + ""
    );
    let t2;
    let option_value_value;
    return {
      c() {
        option = element("option");
        t2 = text(t_value);
        option.__value = option_value_value = /*q*/
        ctx[12].id;
        set_input_value(option, option.__value);
      },
      m(target, anchor) {
        insert(target, option, anchor);
        append(option, t2);
      },
      p(ctx2, dirty) {
        if (dirty & /*Quartos*/
        1 && t_value !== (t_value = /*q*/
        ctx2[12].quarto + ""))
          set_data(t2, t_value);
        if (dirty & /*Quartos*/
        1 && option_value_value !== (option_value_value = /*q*/
        ctx2[12].id)) {
          option.__value = option_value_value;
          set_input_value(option, option.__value);
        }
      },
      d(detaching) {
        if (detaching) {
          detach(option);
        }
      }
    };
  }
  function create_fragment5(ctx) {
    let if_block_anchor;
    let if_block = (
      /*$showSpotModal*/
      ctx[1] && create_if_block2(ctx)
    );
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, [dirty]) {
        if (
          /*$showSpotModal*/
          ctx2[1]
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block2(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if (if_block)
          if_block.d(detaching);
      }
    };
  }
  function instance5($self, $props, $invalidate) {
    let $showSpotModal;
    let $data;
    component_subscribe($self, ShowSpotModal_default, ($value) => $invalidate(1, $showSpotModal = $value));
    let data = writable({
      quarto: "",
      diaria: 40,
      detalhes: "",
      logo: {}
    });
    component_subscribe($self, data, (value) => $invalidate(2, $data = value));
    let { Quartos = [] } = $props;
    console.log(Quartos);
    let Vaga = $showSpotModal;
    let { opt = "" } = $props;
    async function create() {
      await pb.collection("vagas").create($data);
      set_store_value(ShowSpotModal_default, $showSpotModal = false, $showSpotModal);
    }
    const input_handler = (e2) => set_store_value(data, $data.logo = e2.target.files[0], $data);
    const input_handler_1 = (e2) => set_store_value(data, $data.quarto = e2.target.value, $data);
    const input_handler_2 = (e2) => set_store_value(data, $data.diaria = e2.target.value, $data);
    const input_handler_3 = (e2) => set_store_value(data, $data.detalhes = e2.target.value, $data);
    const click_handler = (e2) => {
      e2.stopPropagation();
      if (e2.target != e2.currentTarget)
        return;
      set_store_value(ShowSpotModal_default, $showSpotModal = false, $showSpotModal);
    };
    $self.$set = ($props2) => {
      if ("Quartos" in $props2)
        $invalidate(0, Quartos = $props2.Quartos);
      if ("opt" in $props2)
        $invalidate(5, opt = $props2.opt);
    };
    return [
      Quartos,
      $showSpotModal,
      $data,
      data,
      create,
      opt,
      input_handler,
      input_handler_1,
      input_handler_2,
      input_handler_3,
      click_handler
    ];
  }
  var SpotsModal = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance5, create_fragment5, safe_not_equal, { Quartos: 0, opt: 5 });
    }
  };
  var SpotsModal_default = SpotsModal;

  // pages/Dashboard/Vagas.svelte
  function create_fragment6(ctx) {
    let div8;
    let div0;
    let t5;
    let div7;
    let div5;
    let div2;
    let div1;
    let t7;
    let vacancychart0;
    let t8;
    let div4;
    let div3;
    let t10;
    let vacancychart1;
    let t11;
    let div6;
    let spotstable;
    let t12;
    let roomstable;
    let t13;
    let roomsmodal;
    let t14;
    let spotsmodal;
    let current;
    vacancychart0 = new VacancyChart_default({});
    vacancychart1 = new VacancyChart_default({});
    spotstable = new SpotsTable_default({
      props: {
        Quartos: (
          /*Quartos*/
          ctx[2]
        ),
        Vagas: (
          /*Vagas*/
          ctx[1]
        )
      }
    });
    roomstable = new RoomsTable_default({
      props: {
        Quartos: (
          /*Quartos*/
          ctx[2]
        ),
        Vagas: (
          /*Vagas*/
          ctx[1]
        )
      }
    });
    roomsmodal = new RoomsModal_default({});
    spotsmodal = new SpotsModal_default({ props: { Quartos: (
      /*$Quartos*/
      ctx[0]
    ) } });
    return {
      c() {
        div8 = element("div");
        div0 = element("div");
        div0.innerHTML = `<svg fill="currentColor" viewBox="0 0 1024 1024" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M789.3 513.2c31.1 0 56.5 3.6 75.5 10.7 14.5 5.4 25.2 12.8 32.7 22.6 13.9 18 19.8 46.3 19.8 94.7v213.3h-42.7v-21.3c0-35.3-28.7-64-64-64H213.3c-35.3 0-64 28.7-64 64v21.3h-42.7V641.2c0-48.3 5.9-76.6 19.8-94.7 7.6-9.8 18.3-17.2 32.7-22.6 19-7.1 44.4-10.7 75.5-10.7h554.7m0-42.7H234.7C83.5 470.5 64 546.9 64 641.2v213.3c0 23.6 19.1 42.7 42.7 42.7h42.7c23.6 0 42.7-19.1 42.7-42.7v-21.3c0-11.8 9.6-21.3 21.3-21.3h597.3c11.8 0 21.3 9.6 21.3 21.3v21.3c0 23.6 19.1 42.7 42.7 42.7h42.7c23.6 0 42.7-19.1 42.7-42.7V641.2c-0.1-94.3-19.6-170.7-170.8-170.7z"></path><path d="M512 169.5c44.3 0 87 7.4 123.5 21.5 32.6 12.6 59.1 30.2 74.6 49.7l10 12.5 15.7 2.9c8.8 1.6 18.3 3.3 28.3 5.1 13.4 2.4 27.3 4.8 41.2 7.4 40.2 7.5 69.3 42.8 69.3 83.8v131.3c-29.2-8.7-60.2-13.2-85.3-13.2H234.7c-25.2 0-56.1 4.5-85.3 13.2V352.4c0-41 29.2-76.3 69.3-83.8 13.9-2.6 27.8-5.1 41.2-7.4 10.1-1.8 19.5-3.4 28.3-5.1l15.7-2.9 10-12.5c15.5-19.5 41.9-37.1 74.6-49.7 36.5-14.1 79.2-21.5 123.5-21.5m0-42.7c-102.5 0-190.6 35.8-231.5 87.3-20.3 3.7-45 7.9-69.7 12.5-60.4 11.3-104.1 64.3-104.1 125.8v198.3c29.2-23.5 87.6-37.6 128-37.6h554.7c40.4 0 98.8 14.1 128 37.6V352.4c0-61.5-43.7-114.4-104.1-125.8-24.6-4.6-49.4-8.8-69.7-12.5-41-51.5-129.1-87.3-231.6-87.3z"></path><path d="M177.1 516.3l7.8-28.9c7.9-29.4 29.4-55.9 60.5-74.5 30-17.9 67.8-27.7 106.6-27.7 39 0 75.6 9.5 105.9 27.4 31 18.3 52.6 44.4 60.9 73.4l7.7 27.2H234.7c-8.9 0-18 0.3-27.7 1l-29.9 2.1z m64.5-45.8h220.8c-6.9-7.9-15.8-15.1-26.2-21.2-23.4-13.8-53.3-21.5-84.2-21.5-31.2 0-61.3 7.7-84.7 21.7-10.3 6.2-18.9 13.3-25.7 21z"></path><path d="M846.9 516.3l-29.8-2.1c-9.8-0.7-18.8-1-27.7-1h-292l7.7-27.2c8.3-29 29.9-55.1 60.9-73.4 30.3-17.9 67-27.4 105.9-27.4 38.8 0 76.7 9.9 106.6 27.7 31.1 18.6 52.7 45 60.5 74.5l7.9 28.9z m-285.3-45.8h220.8c-6.8-7.8-15.5-14.9-25.7-21-23.4-14-53.5-21.7-84.7-21.7-30.9 0-60.8 7.6-84.2 21.5-10.5 6.2-19.3 13.3-26.2 21.2z"></path></svg> <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"></path></svg> <svg viewBox="0 1 511 512" fill="currentColor"><path d="M498.7 222.7L289.8 13.8a46.8 46.8 0 00-66.7 0L14.4 222.6l-.2.2A47.2 47.2 0 0047 303h8.3v153.7a55.2 55.2 0 0055.2 55.2h81.7a15 15 0 0015-15V376.5a25.2 25.2 0 0125.2-25.2h48.2a25.2 25.2 0 0125.1 25.2V497a15 15 0 0015 15h81.8a55.2 55.2 0 0055.1-55.2V303.1h7.7a47.2 47.2 0 0033.4-80.4zm-21.2 45.4a17 17 0 01-12.2 5h-22.7a15 15 0 00-15 15v168.7a25.2 25.2 0 01-25.1 25.2h-66.8V376.5a55.2 55.2 0 00-55.1-55.2h-48.2a55.2 55.2 0 00-55.2 55.2V482h-66.7a25.2 25.2 0 01-25.2-25.2V288.1a15 15 0 00-15-15h-23A17.2 17.2 0 0135.5 244L244.4 35a17 17 0 0124.2 0l208.8 208.8v.1a17.2 17.2 0 010 24.2zm0 0"></path></svg> <svg viewBox="0 0 512 512" fill="currentColor"><path d="M467 76H45a45 45 0 00-45 45v270a45 45 0 0045 45h422a45 45 0 0045-45V121a45 45 0 00-45-45zm-6.3 30L287.8 278a44.7 44.7 0 01-63.6 0L51.3 106h409.4zM30 384.9V127l129.6 129L30 384.9zM51.3 406L181 277.2l22 22c14.2 14.1 33 22 53.1 22 20 0 38.9-7.9 53-22l22-22L460.8 406H51.3zM482 384.9L352.4 256 482 127V385z"></path></svg> <svg viewBox="0 0 512 512" fill="currentColor"><path d="M272 512h-32c-26 0-47.2-21.1-47.2-47.1V454c-11-3.5-21.8-8-32.1-13.3l-7.7 7.7a47.1 47.1 0 01-66.7 0l-22.7-22.7a47.1 47.1 0 010-66.7l7.7-7.7c-5.3-10.3-9.8-21-13.3-32.1H47.1c-26 0-47.1-21.1-47.1-47.1v-32.2c0-26 21.1-47.1 47.1-47.1H58c3.5-11 8-21.8 13.3-32.1l-7.7-7.7a47.1 47.1 0 010-66.7l22.7-22.7a47.1 47.1 0 0166.7 0l7.7 7.7c10.3-5.3 21-9.8 32.1-13.3V47.1c0-26 21.1-47.1 47.1-47.1h32.2c26 0 47.1 21.1 47.1 47.1V58c11 3.5 21.8 8 32.1 13.3l7.7-7.7a47.1 47.1 0 0166.7 0l22.7 22.7a47.1 47.1 0 010 66.7l-7.7 7.7c5.3 10.3 9.8 21 13.3 32.1h10.9c26 0 47.1 21.1 47.1 47.1v32.2c0 26-21.1 47.1-47.1 47.1H454c-3.5 11-8 21.8-13.3 32.1l7.7 7.7a47.1 47.1 0 010 66.7l-22.7 22.7a47.1 47.1 0 01-66.7 0l-7.7-7.7c-10.3 5.3-21 9.8-32.1 13.3v10.9c0 26-21.1 47.1-47.1 47.1zM165.8 409.2a176.8 176.8 0 0045.8 19 15 15 0 0111.3 14.5V465c0 9.4 7.7 17.1 17.1 17.1h32.2c9.4 0 17.1-7.7 17.1-17.1v-22.2a15 15 0 0111.3-14.5c16-4.2 31.5-10.6 45.8-19a15 15 0 0118.2 2.3l15.7 15.7a17.1 17.1 0 0024.2 0l22.8-22.8a17.1 17.1 0 000-24.2l-15.7-15.7a15 15 0 01-2.3-18.2 176.8 176.8 0 0019-45.8 15 15 0 0114.5-11.3H465c9.4 0 17.1-7.7 17.1-17.1v-32.2c0-9.4-7.7-17.1-17.1-17.1h-22.2a15 15 0 01-14.5-11.2c-4.2-16.1-10.6-31.6-19-45.9a15 15 0 012.3-18.2l15.7-15.7a17.1 17.1 0 000-24.2l-22.8-22.8a17.1 17.1 0 00-24.2 0l-15.7 15.7a15 15 0 01-18.2 2.3 176.8 176.8 0 00-45.8-19 15 15 0 01-11.3-14.5V47c0-9.4-7.7-17.1-17.1-17.1h-32.2c-9.4 0-17.1 7.7-17.1 17.1v22.2a15 15 0 01-11.3 14.5c-16 4.2-31.5 10.6-45.8 19a15 15 0 01-18.2-2.3l-15.7-15.7a17.1 17.1 0 00-24.2 0l-22.8 22.8a17.1 17.1 0 000 24.2l15.7 15.7a15 15 0 012.3 18.2 176.8 176.8 0 00-19 45.8 15 15 0 01-14.5 11.3H47c-9.4 0-17.1 7.7-17.1 17.1v32.2c0 9.4 7.7 17.1 17.1 17.1h22.2a15 15 0 0114.5 11.3c4.2 16 10.6 31.5 19 45.8a15 15 0 01-2.3 18.2l-15.7 15.7a17.1 17.1 0 000 24.2l22.8 22.8a17.1 17.1 0 0024.2 0l15.7-15.7a15 15 0 0118.2-2.3z"></path><path d="M256 367.4c-61.4 0-111.4-50-111.4-111.4s50-111.4 111.4-111.4 111.4 50 111.4 111.4-50 111.4-111.4 111.4zm0-192.8a81.5 81.5 0 000 162.8 81.5 81.5 0 000-162.8z"></path></svg> <svg viewBox="0 0 512 512" fill="currentColor"><path d="M255.2 468.6H63.8a21.3 21.3 0 01-21.3-21.2V64.6c0-11.7 9.6-21.2 21.3-21.2h191.4a21.2 21.2 0 100-42.5H63.8A63.9 63.9 0 000 64.6v382.8A63.9 63.9 0 0063.8 511H255a21.2 21.2 0 100-42.5z"></path><path d="M505.7 240.9L376.4 113.3a21.3 21.3 0 10-29.9 30.3l92.4 91.1H191.4a21.2 21.2 0 100 42.6h247.5l-92.4 91.1a21.3 21.3 0 1029.9 30.3l129.3-127.6a21.3 21.3 0 000-30.2z"></path></svg>`;
        t5 = space();
        div7 = element("div");
        div5 = element("div");
        div2 = element("div");
        div1 = element("div");
        div1.textContent = "Lota\xE7\xE3o";
        t7 = space();
        create_component(vacancychart0.$.fragment);
        t8 = space();
        div4 = element("div");
        div3 = element("div");
        div3.textContent = "Buscas";
        t10 = space();
        create_component(vacancychart1.$.fragment);
        t11 = space();
        div6 = element("div");
        create_component(spotstable.$.fragment);
        t12 = space();
        create_component(roomstable.$.fragment);
        t13 = space();
        create_component(roomsmodal.$.fragment);
        t14 = space();
        create_component(spotsmodal.$.fragment);
        attr(div0, "class", "left-side");
        attr(div1, "class", "title");
        attr(div2, "class", "activity card !w-full bg-red-900");
        set_style(div2, "--delay", ".2s");
        attr(div3, "class", "title");
        attr(div4, "class", "activity card w-full");
        set_style(div4, "--delay", ".4s");
        attr(div5, "class", "user-box gap-5 grid lg:grid-cols-2");
        attr(div6, "class", "user-box grid gap-5");
        attr(div7, "class", "main-container w-full pb-10");
        attr(div8, "class", "wrapper w-svw");
      },
      m(target, anchor) {
        insert(target, div8, anchor);
        append(div8, div0);
        append(div8, t5);
        append(div8, div7);
        append(div7, div5);
        append(div5, div2);
        append(div2, div1);
        append(div2, t7);
        mount_component(vacancychart0, div2, null);
        append(div5, t8);
        append(div5, div4);
        append(div4, div3);
        append(div4, t10);
        mount_component(vacancychart1, div4, null);
        append(div7, t11);
        append(div7, div6);
        mount_component(spotstable, div6, null);
        append(div6, t12);
        mount_component(roomstable, div6, null);
        insert(target, t13, anchor);
        mount_component(roomsmodal, target, anchor);
        insert(target, t14, anchor);
        mount_component(spotsmodal, target, anchor);
        current = true;
      },
      p(ctx2, [dirty]) {
        const spotsmodal_changes = {};
        if (dirty & /*$Quartos*/
        1)
          spotsmodal_changes.Quartos = /*$Quartos*/
          ctx2[0];
        spotsmodal.$set(spotsmodal_changes);
      },
      i(local) {
        if (current)
          return;
        transition_in(vacancychart0.$.fragment, local);
        transition_in(vacancychart1.$.fragment, local);
        transition_in(spotstable.$.fragment, local);
        transition_in(roomstable.$.fragment, local);
        transition_in(roomsmodal.$.fragment, local);
        transition_in(spotsmodal.$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(vacancychart0.$.fragment, local);
        transition_out(vacancychart1.$.fragment, local);
        transition_out(spotstable.$.fragment, local);
        transition_out(roomstable.$.fragment, local);
        transition_out(roomsmodal.$.fragment, local);
        transition_out(spotsmodal.$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div8);
          detach(t13);
          detach(t14);
        }
        destroy_component(vacancychart0);
        destroy_component(vacancychart1);
        destroy_component(spotstable);
        destroy_component(roomstable);
        destroy_component(roomsmodal, detaching);
        destroy_component(spotsmodal, detaching);
      }
    };
  }
  function instance6($self, $props, $invalidate) {
    let $Vagas;
    let $Quartos;
    let Vagas = writable([]);
    component_subscribe($self, Vagas, (value) => $invalidate(3, $Vagas = value));
    let Quartos = writable([]);
    component_subscribe($self, Quartos, (value) => $invalidate(0, $Quartos = value));
    onMount(async () => {
      set_store_value(Quartos, $Quartos = await pb.collection("quartos").getFullList({}), $Quartos);
      set_store_value(Vagas, $Vagas = await pb.collection("vagas").getFullList({}), $Vagas);
    });
    return [$Quartos, Vagas, Quartos];
  }
  var Vagas_1 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance6, create_fragment6, safe_not_equal, {});
    }
  };
  var Vagas_default = Vagas_1;

  // pages/Dashboard/Vagas.svelte.ts
  var app = new Vagas_default({ target: document.getElementById("app") });
})();
/*! Bundled license information:

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.30.1 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)
*/
</script>
</body></html>